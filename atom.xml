<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Andy&#39;s Blog</title>
  
  <subtitle>Quick notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://andyxw.com/"/>
  <updated>2019-08-21T09:36:21.439Z</updated>
  <id>https://andyxw.com/</id>
  
  <author>
    <name>Andy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>What are React Hooks</title>
    <link href="https://andyxw.com/archives/ef81.html"/>
    <id>https://andyxw.com/archives/ef81.html</id>
    <published>2019-08-21T09:31:54.000Z</published>
    <updated>2019-08-21T09:36:21.439Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 21 2019 19:08:35 GMT+0800 (GMT+08:00) --><blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.robinwieruch.de/react-hooks/" target="_blank" rel="noopener">https://www.robinwieruch.de/react-hooks/</a></p></blockquote><p>October 29, 2018 - <a href="https://github.com/rwieruch/blog_robinwieruch_content/blob/master/react-hooks.md" target="_blank" rel="noopener">Edit this Post on GitHub</a></p><p><img src="https://www.robinwieruch.de/img/posts/react-hooks/banner_1024.jpg" alt=""></p><p>React Hooks were introduced at <a href="https://www.youtube.com/watch?v=dpw9EHDh2bM" target="_blank" rel="noopener">React Conf October 2018</a> as a way to use state and side-effects in React function components. Whereas function components have been called functional stateless components (FSC) before, they are finally able to use state with React Hooks. Therefore, many people refer to them as function components now.</p><p>In this walkthrough, I want to explain the motivation behind hooks, what will change in React and why we shouldn’t panic, and how React hooks can be used in function components by showcasing common React Hooks such as the state and effect hooks by example.</p><p>React Hooks were invented by the React team to introduce state management and side-effects in function components. It’s their way of making it more effortless to use only React function components without the need to refactor a React function component to a React class component for using lifecycle methods, in order to use have side-effects, or local state. React Hooks enable us to write React applications with only function components.</p><p><strong>Unnecessary Component Refactorings:</strong> Previously, only React class components were used for local state management and lifecycle methods. The latter have been essential for introducing side-effects, such as listeners or data fetching, in React class components.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;() =&gt;</span><br><span class="line">            this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &gt;</span><br><span class="line">          Click me</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Counter;</span><br></pre></td></tr></table></figure><p>Only if you didn’t need state or lifecycle methods, React functional <em>stateless</em> components could be used. And because React function components are more lightweight (and elegant), people already used plenty of function components. This came with the drawback of refactoring components from React function components to React class components every time state or lifecycle methods were needed (and vice versa).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">// how to use the state hook in a React function component</span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Counter;</span><br></pre></td></tr></table></figure><p>With Hooks there is no need for this refactoring. Side-effects and state are finally available in React function components. That’s why a rebranding from functional stateless components to function components would be reasonable.</p><p><strong>Side-effect Logic:</strong> In React class components, side-effects were mostly introduced in lifecycle methods (e.g. componentDidMount, componentDidUpdate, componentWillUnmount). A side-effect could be <a href="https://www.robinwieruch.de/react-fetching-data/" target="_blank" rel="noopener">fetching data in React</a> or <a href="https://www.robinwieruch.de/react-intersection-observer-api/" target="_blank" rel="noopener">interacting with the Browser API</a>. Usually these side-effects came with a setup and clean up phase. For instance, if you would miss to remove your listener, you could run into <a href="https://www.robinwieruch.de/react-warning-cant-call-setstate-on-an-unmounted-component/" target="_blank" rel="noopener">React performance issues</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// side-effects in a React class component</span><br><span class="line">class MyComponent extends Component &#123;</span><br><span class="line">  // setup phase</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    // add listener for feature 1</span><br><span class="line">    // add listener for feature 2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // clean up phase</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    // remove listener for feature 1</span><br><span class="line">    // remove listener for feature 2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// side-effects in React function component with React Hooks</span><br><span class="line">function MyComponent() &#123;</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // add listener for feature 1 (setup)</span><br><span class="line">    // return function to remove listener for feature 1 (clean up)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // add listener for feature 2 (setup)</span><br><span class="line">    // return function to remove listener for feature 2 (clean up)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now, if you would introduce more than one of these side-effects in a React class component’s lifecycle methods, all side-effects would be grouped by lifecycle method but not by side-effect. That’s what React Hooks are going to change by encapsulating a side-effect in one hook whereas every hook has its own side-effect with a setup and clean up phase. You will see later in a tutorial how this works for real by adding and removing listeners in a React Hook.</p><p><strong>React’s Abstraction Hell:</strong> Abstraction and thus reusability were introduced with <a href="https://www.robinwieruch.de/gentle-introduction-higher-order-components/" target="_blank" rel="noopener">Higher-Order Components</a> and <a href="https://www.robinwieruch.de/react-render-props-pattern/" target="_blank" rel="noopener">Render Prop Components</a> in React. There is also <a href="https://www.robinwieruch.de/react-context-api/" target="_blank" rel="noopener">React’s Context with its Provider and Consumer Components</a> that introduce another level of abstraction. All of these advanced patterns in React are using so called wrapping components. The implementation of the following components shouldn’t be foreign to developers who are creating larger React applications.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; compose &#125; from &apos;recompose&apos;;</span><br><span class="line">import &#123; withRouter &#125; from &apos;react-router-dom&apos;;</span><br><span class="line"></span><br><span class="line">function App(&#123; history, state, dispatch &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;theme =&gt;</span><br><span class="line">        &lt;Content theme=&#123;theme&#125;&gt;</span><br><span class="line">          ...</span><br><span class="line">        &lt;/Content&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default compose(</span><br><span class="line">  withRouter,</span><br><span class="line">  withReducer(reducer, initialState)</span><br><span class="line">)(App);</span><br></pre></td></tr></table></figure><p>Sophie Alpert coined it “the wrapper hell” in React. You are not only seeing it in the implementation, but also when inspecting your components in the browser. There are dozens of wrapped components due to Render Prop Components (including Consumer components from React’s Context) and Higher-Order Components. It becomes an unreadable component tree, because all the abstracted logic is covered up in other React components. The actual visible components are hard to track down in the browser’s DOM. So what if these additional components were not needed because the logic is only encapsulated in functions as side-effects instead? Then you would remove all these wrapping components and flatten your component tree’s structure:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const theme = useTheme();</span><br><span class="line">  const history = useRouter();</span><br><span class="line">  const [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Content theme=&#123;theme&#125;&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/Content&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>That’s what React Hooks are bringing on the table. All side-effects are sitting directly in the component without introducing other components as container for business logic. The container disappears and the logic just sits in React Hooks that are only functions. <a href="https://github.com/acdlite/recompose/commit/7867de653abbb57a49934e52622a60b433bda918" target="_blank" rel="noopener">Andrew Clark already left a statement in favor of React Hooks in his popular Higher-Order Component library called recompose.</a></p><p><strong>JavaScript Class Confusion:</strong> JavaScript mixes two worlds pretty well: Object-oriented programming (OOP) and functional programming. React introduces many developers to both worlds. On the one side, React (and Redux) introduced people to functional programming (FP) with function compositions, general programming concepts with functions (e.g. higher-order functions, JavaScript built-in methods like map, reduce, filter) and other terms such as immutability and side-effects. React itself didn’t really introduce these things, because they are features of the language or the programming paradigm itself, but they are heavily used in React whereas <a href="https://www.robinwieruch.de/javascript-fundamentals-react-requirements/" target="_blank" rel="noopener">every React developer becomes automatically a better JavaScript developer</a>.</p><p>On the other side, React uses JavaScript classes as one way to define React components. A class is only the declaration whereas the actual usage of the component is the instantiation of it. It creates a class instance whereas the <code>this</code> object of the class instance is used to interact with class methods (e.g. setState, forceUpdate, other custom class methods). However, classes come with a steeper learning curve for React beginners who are not coming from an OOP background. That’s why class bindings, the <code>this</code> object and inheritance can be confusing. I have <a href="https://www.robinwieruch.de/the-road-to-learn-react/" target="_blank" rel="noopener">a few chapters in my React book</a> focusing only on this aspect of React which is always the most confusing thing about React for beginners.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// I THOUGHT WE ARE USING A CLASS. WHY IS IT EXTENDING FROM SOMETHING?</span><br><span class="line">class Counter extends Component &#123;</span><br><span class="line">  // WAIT ... THIS WORKS???</span><br><span class="line">  state = &#123; value: 0 &#125;;</span><br><span class="line"></span><br><span class="line">  // I THOUGH IT&apos;S THIS WAY, BUT WHY DO I NEED PROPS HERE?</span><br><span class="line">  // constructor(props) &#123;</span><br><span class="line">  //  SUPER???</span><br><span class="line">  //  super(props);</span><br><span class="line">  //</span><br><span class="line">  //  this.state = &#123;</span><br><span class="line">  //    value: 0,</span><br><span class="line">  //  &#125;;</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  // WHY DO I HAVE TO USE AN ARROW FUNCTION???</span><br><span class="line">  onIncrement = () =&gt; &#123;</span><br><span class="line">    this.setState(state =&gt; (&#123;</span><br><span class="line">      value: state.value + 1</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // SHOULDN&apos;T IT BE this.onDecrement = this.onDecrement.bind(this); in the constructor???</span><br><span class="line">  // WHAT&apos;S this.onDecrement = this.onDecrement.bind(this); DOING ANYWAY?</span><br><span class="line">  onDecrement = () =&gt; &#123;</span><br><span class="line">    this.setState(state =&gt; (&#123;</span><br><span class="line">      value: state.value - 1</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;this.state.value&#125;</span><br><span class="line"></span><br><span class="line">        &#123;/* WHY IS EVERYTHING AVAILABLE ON &quot;THIS&quot;??? */&#125;</span><br><span class="line">        &lt;button onClick=&#123;this.onIncrement&#125;&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.onDecrement&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now, many people argue React shouldn’t take JavaScript classes away because people don’t understand them. After all, they belong to the language. However, one of the hypotheses of introducing the Hooks API is a smoother learning curve for React beginners when writing their React components without JavaScript classes in the first place.</p><p>Every time a new feature is introduced, people are concerned about it. There is one side of the group that is ecstatic about the change, and the other side that fears the change. I heard the most common concerns for React Hooks are:</p><ul><li>Everything changes! <em>Subtle panic mode …</em></li><li>React is becoming bloated like Angular!</li><li>It’s useless, classes worked fine.</li><li>It’s magic!</li></ul><p><strong>Let me address these concerns here:</strong></p><p><strong>Everything changes:</strong> React Hooks will change how we write React applications in the future. However, at the moment, nothing changes. You can still write class components with local state and lifecycle methods and deploy advanced patterns such as Higher-Order Components or Render Prop Components. Nobody takes these learnings away from you. See how I upgraded all my open source projects from older versions to React 16.6. and none of of these projects had problems. They are using HOCs, Render Props and I believe even the old context API (correct me if am wrong). Everything I have learned all these years still works. The React team makes sure that React stays backward compatible. It will be the same with React 16.7.</p><p><img src="https://www.robinwieruch.de/img/posts/react-hooks/react-upgrades_1024.jpg" alt=""></p><p><strong>React is becoming bloated like Angular:</strong> React was always seen as a library with a slim API. That’s true and shall be true in the future. However, in order to adjust things that were the status quo of building component-based applications a few years ago, and not to be overtaken by other libraries who adapt to the new status quo, React introduces changes in favor of older APIs. If React would start out fresh this year, maybe there would be only function components and hooks. But React was released a couple of years ago and needs to adapt to keep up with the status quo or to invent a status quo. Maybe there will follow deprecations of React class components and lifecycle methods in a few years in favor of React function components and hooks, but at the moment, the React team keeps React class components in their repertoire of tools. After all, the React team utilizes hooks as an invention to run a marathon with React an not to win a sprint. Obviously, React Hooks add yet another API to React, but it is in favor to simplify React’s API in the future. I like this transition more than having a React 2 where everything is different.</p><p><strong>It’s useless, classes worked fine:</strong> Imagine you would start from zero to learn React and you would be introduced to React with Hooks. Maybe <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a> wouldn’t start out with a React class component but with a React function component. Everything you need to learn for your components would be React Hooks. They manage state and side-effects, so you would only need to know about the state and the effect hook. It’s everything a React class component did for you before. It will be simpler for React beginners to learn React without all the other overhead that comes with JavaScript classes (inheritance, this, bindings, super, …). Imagine React Hooks as a new way of how to write React components - It’s a new mindset. I am a skeptical person myself, but once I wrote a couple of simpler scenarios with React Hooks, I was convinced that this is the simplest way to write but also to learn React. As someone who is doing lots of React workshops, I argue that it takes away all the frustration classes bring on the table for React beginners.</p><p><strong>It’s magic:</strong> React is known to be down to earth with JavaScript. Writing React applications makes you a better JavaScript developer - that’s one of the best things about React when someone asks me: “Why should I learn React?”. Whether there comes another library in the future or not, everyone is prepared by honing their JavaScript skills and general programming skills when using React. It’s one of the things that made Redux, often used in React, popular: There is no magic, it is plain JavaScript. Now these React Hooks come along the way, introduce something stateful in a previously often pure function component, a couple of not easily to accept rules, and many don’t understand what’s going on under the hood. But think about it this way: A function component in React is not a mere function. You still have to import React as library to your source code file. It does something with your function, because the function becomes a function component in React land. This function component comes with hidden implementations that were there all the time. How else would it have been possible to use functions as function components as we did it before React Hooks were introduced? And people accepted it too, even though it’s kinda magic. Now, the only thing changed (and maybe it has already been this way before) is that these function components come with an extra hidden object that keeps track of hooks. To quote Dan Abramov from <a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889" target="_blank" rel="noopener">his article about hooks</a>: <em>“Perhaps you’re wondering where React keeps the state for Hooks. The answer is it’s kept in the exact same place where React keeps state for classes. React has an internal update queue which is the source of truth for any state, no matter how you define your components.”</em>.</p><p><strong>Finally, think about it this way:</strong> Component-based solutions such as Angular, Vue, and React are pushing the boundaries of web development with every release. They build up on top of technologies that were invented more than two decades ago. They adapt them to make web development effortless in 2018 and not 1998. They optimize them like crazy to meet the needs in the here and now. We are building web applications with components and not with HTML templates anymore. We are not there yet, but I imagine a future where we sit together and invent a component-based standard for the browser. Angular, Vue and React are only the spearhead of this movement.</p><p>In the following, I want to dive into a few popular React Hooks by example to get you up to speed. All examples can be found in this <a href="https://github.com/the-road-to-learn-react/react-hooks-introduction" target="_blank" rel="noopener">GitHub repository</a>.</p><p>You have seen the useState Hook before in a code snippet for a typical counter example. It is used to manage local state in function components. Let’s use the hook in a more elaborate example where we are going to manage an array of items. In another article of mine, you can learn more about <a href="https://www.robinwieruch.de/react-state-array-add-update-remove/" target="_blank" rel="noopener">managing arrays as state in React</a>, but this time we are doing it with React hooks. Let’s get started:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const INITIAL_LIST = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: &apos;0&apos;,</span><br><span class="line">    title: &apos;React with RxJS for State Management Tutorial&apos;,</span><br><span class="line">    url:</span><br><span class="line">      &apos;https://www.robinwieruch.de/react-rxjs-state-management-tutorial/&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: &apos;1&apos;,</span><br><span class="line">    title: &apos;A complete React with Apollo and GraphQL Tutorial&apos;,</span><br><span class="line">    url: &apos;https://www.robinwieruch.de/react-graphql-apollo-tutorial&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [list, setList] = useState(INITIAL_LIST);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;list.map(item =&gt; (</span><br><span class="line">        &lt;li key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>The useState hook accepts an initial state as argument and returns, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring" target="_blank" rel="noopener">by using array destructuring</a>, two variables that can be named however you want to name them. Whereas the first variable is the actual state, the second variable is a function to update the state by providing a new state.</p><p>The goal of this scenario is to remove an item from the list. In order to accomplish it, every item in the rendered list has a button with a click handler. The click handler can be inlined in the function component, because it will make use of <code>list</code> and <code>setList</code> later. Hence you don’t need to pass these variables to the handler, because they are already available from the outer scope of the component.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [list, setList] = useState(INITIAL_LIST);</span><br><span class="line"></span><br><span class="line">  function onRemoveItem() &#123;</span><br><span class="line">    // remove item from &quot;list&quot;</span><br><span class="line">    // set the new list in state with &quot;setList&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;list.map(item =&gt; (</span><br><span class="line">        &lt;li key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt;</span><br><span class="line">          &lt;button type=&quot;button&quot; onClick=&#123;onRemoveItem&#125;&gt;</span><br><span class="line">            Remove</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Somehow we need to know about the item that should be removed from the list. Using a higher-order function, we can pass the identifier of the item to the handler function. Otherwise we wouldn’t be able to identify the item that should be removed from the list.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [list, setList] = useState(INITIAL_LIST);</span><br><span class="line"></span><br><span class="line">  function onRemoveItem(id) &#123;</span><br><span class="line">    // remove item from &quot;list&quot;</span><br><span class="line">    // set the new list in state with &quot;setList&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;list.map(item =&gt; (</span><br><span class="line">        &lt;li key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt;</span><br><span class="line">          &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; onRemoveItem(item.id)&#125;&gt;</span><br><span class="line">            Remove</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Finally, use the identifier to filter the list with a built-in array method. It returns a new list which is used to set the new state of the list.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [list, setList] = useState(INITIAL_LIST);</span><br><span class="line"></span><br><span class="line">  function onRemoveItem(id) &#123;</span><br><span class="line">    const newList = list.filter(item =&gt; item.id !== id);</span><br><span class="line">    setList(newList);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;list.map(item =&gt; (</span><br><span class="line">        &lt;li key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt;</span><br><span class="line">          &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; onRemoveItem(item.id)&#125;&gt;</span><br><span class="line">            Remove</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>That should do the job. You are able to remove an item from the list based on the identifier you pass to the handler. The handler then filters the list and sets the new state of the list with the <code>setList</code> function.</p><p>The useState hook gives you everything you need to manage state in a function component: initial state, the latest state, and a state update function. Everything else is JavaScript again. Furthermore, you don’t need to bother about the state object with its shallow merge as before in a class component. Instead, you encapsulate one domain (e.g. list) with useState, but if you would need another state (e.g. counter), then just encapsulate this domain with another useState. You can read more about <a href="https://reactjs.org/docs/hooks-state.html" target="_blank" rel="noopener">the useState hook in React’s documentation</a>.</p><p>Let’s head over to the next hook called useEffect. As mentioned before, function components should be able to manage state and side-effects with hooks. Managing state was showcased with the useState hook. Now comes the useEffect hook into play for side-effects which are usually used for interactions with the Browser/DOM API or external API like data fetching. Let’s see how the useEffect hook can be used for interaction with the Browser API by implementing a simple stopwatch. You can see how it is done in a React class component in this <a href="https://github.com/the-road-to-learn-react/react-interval-setstate-unmounted-component-performance" target="_blank" rel="noopener">GitHub repository</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;!isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt;</span><br><span class="line">          Start</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line"></span><br><span class="line">      &#123;isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt;</span><br><span class="line">          Stop</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>There is no stopwatch yet. But at least there are is a <a href="https://www.robinwieruch.de/conditional-rendering-react/" target="_blank" rel="noopener">conditional rendering</a> to show either a “Start” or “Stop” button. The state for the boolean flag is managed by the useState hook.</p><p>Let’s introduce our side-effect with useEffect that registers an interval. The function used for the interval emits a console logging every second to your developer tools of your browser.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    setInterval(() =&gt; console.log(&apos;tick&apos;), 1000);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;!isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt;</span><br><span class="line">          Start</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line"></span><br><span class="line">      &#123;isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt;</span><br><span class="line">          Stop</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>In order to remove the interval when the component unmounts (but also after every other render update), you can return a function in useEffect for anything to be called for the clean up. For instance, there shouldn’t be any memory leak left behind when the component isn’t there anymore.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000);</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>Now, you want to setup the side-effect when mounting the component and the clean up the side-effect when unmounting the component. If you would log how many times the function within the effect is called, you would see that it sets a new interval every time the state of the component changes (e.g. click on “Start”/“Stop” button).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;effect runs&apos;);</span><br><span class="line">    const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000);</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>In order to only run the effect on mount and unmount of the component, you can pass it an empty array as second argument.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000);</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>However, since the interval is cleaned up after every render too, we need to set the interval in our update cycle too. But we can tell the effect to run only when the <code>isOn</code> variable changes. Only when one of the variables in the array changes, the effect will run during the update cycle. If you keep the array empty, the effect will only run on mount and unmount, because there is no variable to be checked for running the side-effect again.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000);</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;, [isOn]);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>The interval is running whether the <code>isOn</code> boolean is true or false. It would be great to only run it when the stopwatch is activated.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    let interval;</span><br><span class="line"></span><br><span class="line">    if (isOn) &#123;</span><br><span class="line">      interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;, [isOn]);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>Now introduce another state in your function component to keep track of the timer of the stopwatch. It is used to update the timer, but only when the stopwatch is activated.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line">  const [timer, setTimer] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    let interval;</span><br><span class="line"></span><br><span class="line">    if (isOn) &#123;</span><br><span class="line">      interval = setInterval(</span><br><span class="line">        () =&gt; setTimer(timer + 1),</span><br><span class="line">        1000,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;, [isOn]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;timer&#125;</span><br><span class="line"></span><br><span class="line">      &#123;!isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt;</span><br><span class="line">          Start</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line"></span><br><span class="line">      &#123;isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt;</span><br><span class="line">          Stop</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>There is still one mistake in the code. When the interval is running, it updates the timer every second by increasing it by one. However, it always relies on a stale state for the timer. Only when the <code>inOn</code> boolean flag changes the state is fine. In order to receive always the latest state for the timer when the interval is running, you can use a function instead for the state update function which always has the latest state.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line">  const [timer, setTimer] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    let interval;</span><br><span class="line"></span><br><span class="line">    if (isOn) &#123;</span><br><span class="line">      interval = setInterval(</span><br><span class="line">        () =&gt; setTimer(timer =&gt; timer + 1),</span><br><span class="line">        1000,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;, [isOn]);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>An alternative would have been to run the effect also when the timer changes. Then the effect would receive the latest timer state.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line">  const [timer, setTimer] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    let interval;</span><br><span class="line"></span><br><span class="line">    if (isOn) &#123;</span><br><span class="line">      interval = setInterval(</span><br><span class="line">        () =&gt; setTimer(timer + 1),</span><br><span class="line">        1000,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;, [isOn, timer]);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>That’s the implementation for the stopwatch that uses the Browser API If you want to continue, you can extend the example by providing a “Reset” button too.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line">  const [timer, setTimer] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    let interval;</span><br><span class="line"></span><br><span class="line">    if (isOn) &#123;</span><br><span class="line">      interval = setInterval(</span><br><span class="line">        () =&gt; setTimer(timer =&gt; timer + 1),</span><br><span class="line">        1000,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;, [isOn]);</span><br><span class="line"></span><br><span class="line">  const onReset = () =&gt; &#123;</span><br><span class="line">    setIsOn(false);</span><br><span class="line">    setTimer(0);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;timer&#125;</span><br><span class="line"></span><br><span class="line">      &#123;!isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt;</span><br><span class="line">          Start</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line"></span><br><span class="line">      &#123;isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt;</span><br><span class="line">          Stop</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line"></span><br><span class="line">      &lt;button type=&quot;button&quot; disabled=&#123;timer === 0&#125; onClick=&#123;onReset&#125;&gt;</span><br><span class="line">        Reset</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>That’s it. The useEffect hook is used for side-effects in React function components that are used for interacting with the Browser/DOM API or other third-party APIs (e.g. data fetching). You can read more about <a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="noopener">the useEffect hook in React’s documentation</a>.</p><p>Last but not least, after you have learned about the two most popular hooks that introduce state and side-effects in function components, there is one last thing I want to show you: custom hooks. That’s right, you can implement your own custom React Hooks that can be reused in your application or by others. Let’s see how they work with an example application which is able to detect whether your device is online or offline.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOffline, setIsOffline] = useState(false);</span><br><span class="line"></span><br><span class="line">  if (isOffline) &#123;</span><br><span class="line">    return &lt;div&gt;Sorry, you are offline ...&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;You are online!&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>Again, introduce the useEffect hook for the side-effect. In this case, the effect adds and removes listeners that check if the device is online or offline. Both listeners are setup only once on mount and cleaned up once on unmount (empty array as second argument). Whenever one of the listeners is called, it sets the state for the <code>isOffline</code> boolean.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOffline, setIsOffline] = useState(false);</span><br><span class="line"></span><br><span class="line">  function onOffline() &#123;</span><br><span class="line">    setIsOffline(true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function onOnline() &#123;</span><br><span class="line">    setIsOffline(false);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    window.addEventListener(&apos;offline&apos;, onOffline);</span><br><span class="line">    window.addEventListener(&apos;online&apos;, onOnline);</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      window.removeEventListener(&apos;offline&apos;, onOffline);</span><br><span class="line">      window.removeEventListener(&apos;online&apos;, onOnline);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  if (isOffline) &#123;</span><br><span class="line">    return &lt;div&gt;Sorry, you are offline ...&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;You are online!&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>Everything is nicely encapsulated in one effect now. It’s a great functionality which should be reuse somewhere else too. That’s why we can extract the functionality as its a custom hook which follows the same naming convention as the other hooks.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function useOffline() &#123;</span><br><span class="line">  const [isOffline, setIsOffline] = useState(false);</span><br><span class="line"></span><br><span class="line">  function onOffline() &#123;</span><br><span class="line">    setIsOffline(true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function onOnline() &#123;</span><br><span class="line">    setIsOffline(false);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    window.addEventListener(&apos;offline&apos;, onOffline);</span><br><span class="line">    window.addEventListener(&apos;online&apos;, onOnline);</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      window.removeEventListener(&apos;offline&apos;, onOffline);</span><br><span class="line">      window.removeEventListener(&apos;online&apos;, onOnline);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return isOffline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const isOffline = useOffline();</span><br><span class="line"></span><br><span class="line">  if (isOffline) &#123;</span><br><span class="line">    return &lt;div&gt;Sorry, you are offline ...&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;You are online!&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>Extracting the custom hook as function was not the only thing. You also have to return the <code>isOffline</code> state from the custom hook in order to use it in your application to show a message to users who are offline. Otherwise, it should render the normal application. That’s it for the custom hook that detects whether you are online or offline. You can read more about <a href="https://reactjs.org/docs/hooks-custom.html" target="_blank" rel="noopener">custom hooks in React’s documentation</a>.</p><p>React Hooks being reusable is the best thing about them, because there is the potential to grow an ecosystem of custom React Hooks that can be installed from npm for any React application. And not only for React applications. Evan You, creator of Vue, <a href="https://twitter.com/youyuxi/status/1056042395891105793" target="_blank" rel="noopener">is hooked (!) by them as well</a>. Maybe we will see a bridge between both ecosystems where it is possible to share hooks between Vue and React.</p><hr><p>If you want to dive deeper into the state and effect hooks, you can check out the following React hook tutorials:</p><ul><li><a href="https://www.robinwieruch.de/react-usereducer-hook/" target="_blank" rel="noopener">How to useReducer Hook?</a></li><li><a href="https://www.robinwieruch.de/react-hooks-migration" target="_blank" rel="noopener">Migration from Class Components to Hooks</a></li><li><a href="https://www.robinwieruch.de/react-usereducer-vs-usestate/" target="_blank" rel="noopener">Comparison useState vs useReducer</a></li><li><a href="https://www.robinwieruch.de/react-state-usereducer-usestate-usecontext" target="_blank" rel="noopener">Modern State Management with Hooks</a></li><li><a href="https://www.robinwieruch.de/react-hooks-fetch-data" target="_blank" rel="noopener">How to fetch data with React Hooks</a></li></ul><p>Checkout the official <a href="https://reactjs.org/docs/hooks-faq.html" target="_blank" rel="noopener">FAQ</a> and <a href="https://reactjs.org/docs/hooks-rules.html" target="_blank" rel="noopener">Rules</a> for hooks in React’s documentation to learn more about their fine-grained behaviour. In addition, you can checkout <a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener">all officially available React Hooks</a> too.</p><p>For everyone who is still concerned about React Hooks: Give them a shot yourself. Implement a couple of React function components with state and side-effects. I had to do it myself to understand how they work and to feel comfortable with them. And I must say it feels pretty great to use them.</p><h2 id="The-Road-to-learn-React"><a href="#The-Road-to-learn-React" class="headerlink" title="The Road to learn React"></a>The Road to learn React</h2><p><img src="https://www.robinwieruch.de/img/page/cover.png" alt=""></p><p>Build a Hacker News App along the way. No setup configuration. No tooling. No Redux. Plain React in 200+ pages of learning material. Learn React like <strong>50.000+ readers</strong>.</p><p><a href="https://roadtoreact.com/" target="_blank" rel="noopener">Get the Book for free</a></p><h3 id="Never-miss-an-article-about-web-development-JavaScript-and-self-growth"><a href="#Never-miss-an-article-about-web-development-JavaScript-and-self-growth" class="headerlink" title="Never miss an article about web development, JavaScript and self-growth."></a>Never miss an article about web development, JavaScript and self-growth.</h3><h2 id="Take-Part"><a href="#Take-Part" class="headerlink" title="Take Part"></a>Take Part</h2><h3 id="Join-30-000-Developers"><a href="#Join-30-000-Developers" class="headerlink" title="Join 30.000+ Developers"></a>Join 30.000+ Developers</h3><h3 id="Learn-Web-Development-with-JavaScript"><a href="#Learn-Web-Development-with-JavaScript" class="headerlink" title="Learn Web Development with JavaScript"></a>Learn Web Development with JavaScript</h3><h3 id="Tips-and-Tricks"><a href="#Tips-and-Tricks" class="headerlink" title="Tips and Tricks"></a>Tips and Tricks</h3><h3 id="Access-Tutorials-eBooks-and-Courses"><a href="#Access-Tutorials-eBooks-and-Courses" class="headerlink" title="Access Tutorials, eBooks and Courses"></a>Access Tutorials, eBooks and Courses</h3><h3 id="Personal-Development-as-a-Software-Engineer"><a href="#Personal-Development-as-a-Software-Engineer" class="headerlink" title="Personal Development as a Software Engineer"></a>Personal Development as a Software Engineer</h3><p><strong>本文作者</strong>： Andy<br><strong>本文地址</strong>： <a href="https://andyxw.com/archives/ef81.html">https://andyxw.com/archives/ef81.html</a><br><strong>版权声明</strong>： 转载请注明出处！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      RWieruch - What are React Hooks
    
    </summary>
    
      <category term="前端" scheme="https://andyxw.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="https://andyxw.com/tags/React/"/>
    
      <category term="前端" scheme="https://andyxw.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React Hooks" scheme="https://andyxw.com/tags/React-Hooks/"/>
    
  </entry>
  
  <entry>
    <title>前端相关文章收藏</title>
    <link href="https://andyxw.com/archives/f37d.html"/>
    <id>https://andyxw.com/archives/f37d.html</id>
    <published>2018-10-24T02:15:36.000Z</published>
    <updated>2019-08-21T02:07:23.815Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 21 2019 19:08:35 GMT+0800 (GMT+08:00) --><h6 id="前端架构"><a href="#前端架构" class="headerlink" title="前端架构"></a>前端架构</h6><blockquote><p><a href="https://github.com/sorrycc/blog/issues/6" target="_blank" rel="noopener">支付宝前端应用架构的发展和选择</a></p></blockquote><p><strong>本文作者</strong>： Andy<br><strong>本文地址</strong>： <a href="https://andyxw.com/archives/f37d.html">https://andyxw.com/archives/f37d.html</a><br><strong>版权声明</strong>： 转载请注明出处！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      前端相关文章收藏
    
    </summary>
    
      <category term="前端" scheme="https://andyxw.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://andyxw.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="链接" scheme="https://andyxw.com/tags/%E9%93%BE%E6%8E%A5/"/>
    
      <category term="收藏" scheme="https://andyxw.com/tags/%E6%94%B6%E8%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>服务器重置密码</title>
    <link href="https://andyxw.com/archives/fe92.html"/>
    <id>https://andyxw.com/archives/fe92.html</id>
    <published>2018-10-15T09:33:12.000Z</published>
    <updated>2018-10-15T12:00:55.263Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 21 2019 19:08:35 GMT+0800 (GMT+08:00) --><p>有时候会忘记服务器密码，但是可以通过官网面板等方式连上时，可使用下面的命令修改root密码：<br>整段赋值下面的命令（”新密码”处 替换为要修改的密码）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo root:新密码 |sudo chpasswd root</span><br><span class="line">sudo sed -i &apos;s/^.*PermitRootLogin.*/PermitRootLogin yes/g&apos; /etc/ssh/sshd_config;</span><br><span class="line">sudo sed -i &apos;s/^.*PasswordAuthentication.*/PasswordAuthentication yes/g&apos; /etc/ssh/sshd_config;</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>重启后用root账户登录即可。</p><p><strong>本文作者</strong>： Andy<br><strong>本文地址</strong>： <a href="https://andyxw.com/archives/fe92.html">https://andyxw.com/archives/fe92.html</a><br><strong>版权声明</strong>： 转载请注明出处！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Linux服务器重置密码
    
    </summary>
    
      <category term="服务器" scheme="https://andyxw.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="服务器" scheme="https://andyxw.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Linux" scheme="https://andyxw.com/tags/Linux/"/>
    
      <category term="重置密码" scheme="https://andyxw.com/tags/%E9%87%8D%E7%BD%AE%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>解密传统组件间通信与React组件间通信</title>
    <link href="https://andyxw.com/archives/ac71.html"/>
    <id>https://andyxw.com/archives/ac71.html</id>
    <published>2018-08-17T08:39:36.000Z</published>
    <updated>2018-08-17T08:44:40.533Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 21 2019 19:08:35 GMT+0800 (GMT+08:00) --><p>在React中最小的逻辑单元是组件，组件之间如果有耦合关系就会进行通信，本文将会介绍React中的组件通信的不同方式</p><p>通过归纳范，可以将任意组件间的通信归类为四种类型的组件间通信，分别是父子组件，爷孙组件，兄弟组件和任意组件，<br>需要注意的是前三个也可以算作任意组件的范畴，所以最后一个是万能方法</p><h3 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h3><p>父子组件间的通信分为父组件向子组件通信和子组件向父组件通信两种情况，下面先来介绍父组件向子组件通信，<br>传统做法分为两种情况，分别是初始化时的参数传递和实例阶段的方法调用，例子如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="comment">// 获取dom引用</span></span><br><span class="line">        <span class="keyword">this</span>.$div = <span class="built_in">document</span>.querySelector(<span class="string">'#wp'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化时传入name</span></span><br><span class="line">        <span class="keyword">this</span>.updateName(name);</span><br><span class="line">    &#125;</span><br><span class="line">    updateName(name) &#123;</span><br><span class="line">        <span class="comment">// 对外提供更新的api</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 更新dom</span></span><br><span class="line">        <span class="keyword">this</span>.$div.innerHTML = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化阶段</span></span><br><span class="line">        <span class="keyword">this</span>.child = <span class="keyword">new</span> Child(<span class="string">'yan'</span>);</span><br><span class="line">        </span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化阶段</span></span><br><span class="line">            <span class="keyword">this</span>.child.updateName(<span class="string">'hou'</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在React中将两个情况统一处理，全部通过属性来完成，之所以能够这样是因为React在属性更新时会自动重新渲染子组件，<br>下面的例子中，2秒后子组件会自动重新渲染，并获取新的属性值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化阶段</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">name</span>: <span class="string">'yan'</span>&#125;;</span><br><span class="line"></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化阶段</span></span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>: <span class="string">'hou'</span>&#125;)</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&#123;this.state.name&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>下面来看一下子组件如何向父组件通信，传统做法有两种，一种是回调函数，另一种是为子组件部署消息接口</p><p>先来看回调函数的例子，回调函数的优点是非常简单，缺点就是必须在初始化的时候传入，并且不可撤回，并且只能传入一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(cb) &#123;</span><br><span class="line">        <span class="comment">// 调用父组件传入的回调函数，发送消息</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; cb() &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化阶段，传入回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.child = <span class="keyword">new</span> Child(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'child update'</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看看消息接口方法，首先需要一个可以发布和订阅消息的基类，比如下面实现了一个简单的<code>EventEimtter</code>，实际生产中可以直接使用别人写好的类库，比如<a href="https://github.com/jsmini/event" target="_blank" rel="noopener">@jsmini/event</a>，子组件继承消息基类，就有了发布消息的能力，然后父组件订阅子组件的消息，即可实现子组件向父组件通信的功能</p><p>消息接口的优点就是可以随处订阅，并且可以多次订阅，还可以取消订阅，缺点是略显麻烦，需要引入消息基类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息接口，订阅发布模式，类似绑定事件，触发事件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEimtter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventMap = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sub(name, cb) &#123;</span><br><span class="line">        <span class="keyword">const</span> eventList = <span class="keyword">this</span>.eventMap[name] = <span class="keyword">this</span>.eventMap[name] || &#123;&#125;;</span><br><span class="line">        eventList.push(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    pub(name, ...data) &#123;</span><br><span class="line">        (<span class="keyword">this</span>.eventMap[name] || []).forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(...data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">EventEimtter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// 通过消息接口发布消息</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">this</span>.pub(<span class="string">'update'</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化阶段，传入回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.child = <span class="keyword">new</span> Child();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 订阅子组件的消息</span></span><br><span class="line">        <span class="keyword">this</span>.child.sub(<span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'child update'</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Backbone.js就同时支持回调函数和消息接口方式，但React中选择了比较简单的回调函数模式，下面来看一下React的例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">this</span>.props.cb() &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">cb</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;console.log('update')&#125;&#125; /&gt;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="爷孙组件"><a href="#爷孙组件" class="headerlink" title="爷孙组件"></a>爷孙组件</h3><p>父子组件其实可以算是爷孙组件的一种特例，这里的爷孙组件不光指爷爷和孙子，而是泛指祖先与后代组件通信，可能隔着很多层级，我们已经解决了父子组件通信的问题，根据化归法，很容易得出爷孙组件的答案，那就是层层传递属性么，把爷孙组件通信分解为多个父子组件通信的问题</p><p>层层传递的优点是非常简单，用已有知识就能解决，问题是会浪费很多代码，非常繁琐，中间作为桥梁的组件会引入很多不属于自己的属性</p><p>在React中，通过context可以让祖先组件直接把属性传递到后代组件，有点类似星际旅行中的虫洞一样，通过context这个特殊的桥梁，可以跨越任意层次向后代组件传递消息</p><p>怎么在需要通信的组件之间开启这个虫洞呢？需要双向声明，也就是在祖先组件声明属性，并在后代组件上再次声明属性，然后在祖先组件上放上属性就可以了，就可以在后代组件读取属性了，下面看一个例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 后代组件声明需要读取context上的数据</span></span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">        text: PropTypes.string</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">// 通过this.context 读取context上的数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.context.text&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ancestor</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 祖先组件声明需要放入context上的数据</span></span><br><span class="line">    <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">        text: PropTypes.string</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 祖先组件往context放入数据</span></span><br><span class="line">    getChildContext() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">text</span>: <span class="string">'yanhaijing'</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>context的优点是可以省去层层传递的麻烦，并且通过双向声明控制了数据的可见性，对于层数很多时，不失为一种方案；但缺点也很明显，就像全局变量一样，如果不加节制很容易造成混乱，而且也容易出现重名覆盖的问题</p><p>个人的建议是对一些所有组件共享的只读信息可以采用context来传递，比如登录的用户信息等</p><p><em>小贴士：React Router路由就是通过context来传递路由属性的</em></p><h3 id="兄弟组件"><a href="#兄弟组件" class="headerlink" title="兄弟组件"></a>兄弟组件</h3><p>如果两个组件是兄弟关系，可以通过父组件作为桥梁，来让两个组件之间通信，这其实就是主模块模式</p><p>下面的例子中，两个子组件通过父组件来实现显示数字同步的功能</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.onChange = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;num&#125;)</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Child1 num=&#123;<span class="keyword">this</span>.state.num&#125; onChange=&#123;<span class="keyword">this</span>.onChange&#125;&gt;</span><br><span class="line">                &lt;Child2 num=&#123;<span class="keyword">this</span>.state.num&#125; onChange=&#123;<span class="keyword">this</span>.onChange&#125;&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>主模块模式的优点就是解耦，把两个子组件之间的耦合关系，解耦成子组件和父组件之间的耦合，把分散的东西收集在一起好处非常明显，能带来更好的可维护性和可扩展性</p><h3 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h3><p>任意组件包括上面的三种关系组件，上面三种关系应该优先使用上面介绍的方法，对于任意的两个组件间通信，总共有三种办法，分别是共同祖先法，消息中间件和状态管理</p><p>基于我们上面介绍的爷孙组件和兄弟组件，只要找到两个组件的共同祖先，就可以将任意组件之间的通信，转化为任意组件和共同祖先之间的通信，这个方法的好处就是非常简单，已知知识就能搞定，缺点就是上面两种模式缺点的叠加，除了临时方案，不建议使用这种方法</p><p>另一种比较常用的方法是消息中间件，就是引入一个全局消息工具，两个组件通过这个全局工具进行通信，这样两个组件间的通信，就通过全局消息媒介完成了</p><p>还记得上面介绍的消息基类吗？下面的例子中，组件1和组件2通过全局event进行通信</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEimtter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventMap = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sub(name, cb) &#123;</span><br><span class="line">        <span class="keyword">const</span> eventList = <span class="keyword">this</span>.eventMap[name] = <span class="keyword">this</span>.eventMap[name] || &#123;&#125;;</span><br><span class="line">        eventList.push(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    pub(name, ...data) &#123;</span><br><span class="line">        (<span class="keyword">this</span>.eventMap[name] || []).forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(...data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局消息工具</span></span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> EventEimtter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element1</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 订阅消息</span></span><br><span class="line">        event.sub(<span class="string">'element2update'</span>, () =&gt; &#123;<span class="built_in">console</span>.log(<span class="string">'element2 update'</span>)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个组件。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element2</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; event.pub(<span class="string">'element2update'</span>) &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息中间件的模式非常简单，利用了观察者模式，将两个组件之间的耦合解耦成了组件和消息中心+消息名称的耦合，但为了解耦却引入全局消息中心和消息名称，消息中心对组件的侵入性很强，和第三方组件通信不能使用这种方式</p><p>小型项目比较适合使用这种方式，但随着项目规模的扩大，达到中等项目以后，消息名字爆炸式增长，消息名字的维护成了棘手的问题，重名概率极大，没有人敢随便删除消息信息，消息的发布者找不到消息订阅者的信息等</p><p>其实上面的问题也不是没有解决办法，重名的问题可以通过制定规范，消息命名空间等方式来极大降低冲突，其他问题可以通过把消息名字统一维护到一个文件，通过对消息的中心化管理，可以让很多问题都很容易解决</p><p>如果你的项目非常大，上面两种方案都不合适，那你可能需要一个状态管理工具，通过状态管理工具把组件之间的关系，和关系的处理逻辑从组建中抽象出来，并集中化到统一的地方来处理，Redux就是一个非常不错的状态管理工具</p><p>除了Redux，还有Mobx，Rematch，reselect等工具，本文不展开介绍，有机会后面单独成文，这些都是用来解决不同问题的，只要根据自己的场景选择合适的工具就好了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>组件间的关系千变万化，都可以用上面介绍的方法解决，对于不同规模的项目，应该选择适合自己的技术方案，上面介绍的不同方式解耦的程度是不一样的，关于不同耦合关系的好坏，可以看我之前的文章《<a href="https://andyxw.com/archives/7e29.html">图解7种耦合关系</a>》</p><p><strong>本文作者</strong>： Andy<br><strong>本文地址</strong>： <a href="https://andyxw.com/archives/ac71.html">https://andyxw.com/archives/ac71.html</a><br><strong>版权声明</strong>： 转载请注明出处！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本文介绍传统组件间通信与React中的组件通信4种方式
    
    </summary>
    
      <category term="React" scheme="https://andyxw.com/categories/React/"/>
    
    
      <category term="React" scheme="https://andyxw.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>图解7种耦合关系</title>
    <link href="https://andyxw.com/archives/7e29.html"/>
    <id>https://andyxw.com/archives/7e29.html</id>
    <published>2018-08-17T08:36:01.000Z</published>
    <updated>2018-08-17T08:42:17.490Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 21 2019 19:08:35 GMT+0800 (GMT+08:00) --><p>深入讲讲模块之间的耦合关系这个事情。</p><p>本文将用图文详细讲解七种耦合的不同之处。</p><h2 id="高内聚与低耦合"><a href="#高内聚与低耦合" class="headerlink" title="高内聚与低耦合"></a>高内聚与低耦合</h2><p>高内聚与低耦合是每个软件开发者追求的目标，那么内聚和耦合分别是什么意思呢？</p><p><img src="!--￼0--&gt;416.png" alt=""></p><blockquote><p>内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</p></blockquote><blockquote><p>耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</p></blockquote><h2 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h2><p>不同模块之间的关系就是耦合，根据耦合程度可以分为7种，耦合度依次变低。</p><ul><li>内容耦合</li><li>公共耦合</li><li>外部耦合</li><li>控制耦合</li><li>标记耦合</li><li>数据耦合</li><li>非直接耦合</li></ul><p>下面我们来说说每种耦合是什么，开始之前先来说下要实现的功能。m1和m2是两个独立的模块，其中m2种会显示m1的输入，m1会显示m2的输入。</p><p><img src="!--￼1--&gt;417.png" alt=""></p><p>很显然，m1和m2两个模块之间会有一些联系（耦合），你也可以想想如何实现这个功能，下面用7种不同的方式来实现这个功能。</p><p><strong>注：</strong>项目的代码我放到了<a href="https://github.com/yanhaijing/coupling" target="_blank" rel="noopener">github</a>，项目的demo，可以在<a href="http://yanhaijing.com/coupling/" target="_blank" rel="noopener">这里查看</a>。</p><h3 id="内容耦合"><a href="#内容耦合" class="headerlink" title="内容耦合"></a>内容耦合</h3><p>内容耦合是最紧的耦合程度，一个模块直接访问另一模块的内容，则称这两个模块为内容耦合。</p><p><img src="!--￼2--&gt;418.png" alt=""></p><p>为了实现功能，我们将m1的输入放到m2.m1input上，将m2的输入放到m1.m2input上。</p><pre><code>// m1.jsroot.m2.m1input = this.value;m2.update();// m2.jsroot.m1.m2input = this.value;m1.update();</code></pre><p><strong>PS:</strong>不知道谁会这么写代码，除了我为了做演示之外。。。</p><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo1" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo1/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="公共耦合"><a href="#公共耦合" class="headerlink" title="公共耦合"></a>公共耦合</h3><p>一组模块都访问同一个全局数据结构，则称之为公共耦合。</p><p><img src="!--￼3--&gt;419.png" alt=""></p><p>在这种case中，m1和m2将自己的输入放到全局的data上。</p><pre><code>// m1.jsroot.data.m1input = this.value;m2.update();// m2.jsroot.data.m2input = this.value;m1.update();</code></pre><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo2" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo2/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="外部耦合"><a href="#外部耦合" class="headerlink" title="外部耦合"></a>外部耦合</h3><p>一组模块都访问同一全局简单变量，而且不通过参数表传递该全局变量的信息，则称之为外部耦合。外部耦合和公共耦合很像，区别就是一个是简单变量，一个是复杂数据结构。</p><p><img src="!--￼4--&gt;420.png" alt=""></p><p>在这种case中，m1和m2都将自己的输入放到全局上。</p><pre><code>// m1.jsroot.m1input = this.value;m2.update();// m2.jsroot.m2input = this.value;m1.update();</code></pre><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo3" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo3/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="控制耦合"><a href="#控制耦合" class="headerlink" title="控制耦合"></a>控制耦合</h3><p>模块之间传递的不是数据信息，而是控制信息例如标志、开关量等，一个模块控制了另一个模块的功能。</p><p>从控制耦合开始，模块的数据就放在自己内部了，不同模块之间通过接口互相调用。</p><p><img src="!--￼5--&gt;421.png" alt=""></p><p>在这个case中，得增加一个需求，就是当m1的输入为空时，隐藏m2的显示信息。</p><pre><code>// m1.jsroot.m1input = this.value;m2.update();m2.toggle(!!this.value); // 传递flag</code></pre><p>上面的代码中m1直接控制了m2的显示和隐藏。</p><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo4" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo4/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="标记耦合"><a href="#标记耦合" class="headerlink" title="标记耦合"></a>标记耦合</h3><p>调用模块和被调用模块之间传递数据结构而不是简单数据，同时也称作特征耦合。</p><p><img src="!--￼6--&gt;422.png" alt=""></p><p>在这个case中，m1传给m2的是一个对象。</p><pre><code>// m1.jsme.m1input = this.value;m2.update(me); // 传递引用// m2.jsme.m2input = this.value;m1.update(me);</code></pre><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo5" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo5/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="数据耦合"><a href="#数据耦合" class="headerlink" title="数据耦合"></a>数据耦合</h3><p>调用模块和被调用模块之间只传递简单的数据项参数。相当于高级语言中的值传递。</p><p><img src="!--￼7--&gt;423.png" alt=""></p><p>在这个case中，m1传给m2的是一个简单数据结构。</p><pre><code>// m1.jsme.m1input = this.value;m2.update(me.m1input); // 传递值// m2.jsme.m2input = this.value;m1.update(me.m2input);</code></pre><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo6" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo6/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="非直接耦合"><a href="#非直接耦合" class="headerlink" title="非直接耦合"></a>非直接耦合</h3><p>两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。耦合度最弱，模块独立性最强。</p><p>子模块无需知道对方的存在，子模块之间的联系，全部变成子模块和主模块之间的联系。</p><p><img src="!--￼8--&gt;424.png" alt=""></p><p>在这个case种，增加一个index.js作为主模块。</p><pre><code>// index.jsvar m1 = root.m1;var m2 = root.m2;m1.init(function (str) {    m2.update(str);});m2.init(function (str) {    m1.update(str);});// m1.jsme.m1input = this.value;inputcb(me.m1input); // inputcb是回调函数// m2.jsme.m2input = this.value;inputcb(me.m2input);</code></pre><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo7" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo7/demo.html" target="_blank" rel="noopener">demo</a>。</p><h2 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h2><p>其实关于内聚也分为很多种，如下所示，如果你感兴趣可以自己研究研究，我们下次再来分享内聚的问题。</p><ul><li>偶然内聚</li><li>逻辑内聚</li><li>时间内聚</li><li>通信内聚</li><li>顺序内聚</li><li>功能内聚</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望你看完上面的文章，搞懂了耦合的种类，也希望你以后能使用非直接耦合这种方式来写代码，祝好。</p><p><strong>本文作者</strong>： Andy<br><strong>本文地址</strong>： <a href="https://andyxw.com/archives/7e29.html">https://andyxw.com/archives/7e29.html</a><br><strong>版权声明</strong>： 转载请注明出处！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本文将用图文详细讲解七种耦合的不同之处
    
    </summary>
    
      <category term="模块化" scheme="https://andyxw.com/categories/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    
      <category term="模块化" scheme="https://andyxw.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>鸡汤</title>
    <link href="https://andyxw.com/archives/201.html"/>
    <id>https://andyxw.com/archives/201.html</id>
    <published>2018-08-05T02:32:11.000Z</published>
    <updated>2019-08-21T02:40:43.323Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="这是篇有密码的博客" />    <label for="pass">这是篇有密码的博客</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19EiZKRUynYjFmuHGI9LK8gwb68Slsb6s6HJhENHHGU8e8gu3kRieeWstCNwV9QLmH6Adyvhf/rs9w7qPT6gupFZpVNhlHh61RCdfnCzE5rVW5a0Fe7NWrLUgSv+93lsiUAi1EmiEjjws9esefMKjMYwM2Xd5vrLqXrAGwGEyLvr6z6/BEl7V84CKPc7b5irGO3946yQKYqYprhlCNb7161hhCQH/OwosUd5RH6VEL2tU3cayh+u6vp5UH+CSaH0pD5jiHsFu5sqwPnvrC3A7ECnz3kBmdv1HCPJ87uRS8zxOxZUkbIqYdDpIQKT32Rxo8pDAA4FLpeDkNME587vgWHGiyg+wbzzoKoJAwZJ+hffWqaBoCPtC3eFWFZnDzTW2J6m0d209JsUbjNK3Kc+rRZy3FyOvjmqPaaaywFPnWiQBkKUoVPH7iwc+61YaKVjRAi9yliZYxuJ2cUG5a6puvzqNLhygDWjkr07ZHrG3TRrLJMaM02n5lmuqkY+/iuvUuuEA6eEXgPFWuMiG1+9V2X6oveaZ1KZUs1m/WdEWbrPSK6COWYXiROODYg/mcskP/HIQM7J0oucsCflROn+iAi4PIcJf6ypb80PlSVrSqqLANyG1QHgIEVk9YZXC6XA3whPCDZXNmibyNpJpXCoks2Pc/hOO6dVqFLpzgbkj7y+VGCtitwOWF2hJD2PQiho9/PwtGGTtUbA2pA2d/e0EJNDEibcENe8tP/ltZTHaQViGAonT/4RnEsM/6di4F5gXS7oYEkPgrxDFSxeb4HunlqB9maJ9tzfFM5Q+S0BXSNRoRazIW9VFTL1NcVDbkZZrNRCVz8Bqx4dXAxCX4drrwIAqup19ydfvzD+CaG2XQtxdQdefQ+7+oOz6HfALal+5IlXg1GIu7gq4Jzl9f1HBVLhHgCSyNZj5hUnZXc+MXCdafSKtOaa+XcPCKhIhZBRMCfZK0YOEXrqHAJHgv3W4abp9ZOj3YofGCJRE8eB/JfwMUKqrZufVCOUJfJzUmUht2TC+6NjpWOVEn75MRY7RU+KLZeui0cL55qC3Hjfv6iJYtnvXuJ3vVwajS0zuFOgQBho2FXs2qCj89fxupEYKZbVMPNLl5QMclWz/+lj0u9iy74GDuDiZP8gNLrYuPupsvxnTGLNMFCTbFQAzFTGkV1g0OsD3f/ilX3IAmhBKmz5hjSQipNtqzYg8Dofzyt78IloalcBP3+ABabkAfU7Yd7M0QEYgZgXJGTeBk49pk5N7ItM0ahAxzXvQLsXQk+GSKEMtt5rYifeXT+OTP6BwxfHow62w7EBlhFKiwoC2m/55ndpk3LL6QDSqxJqGf6ALZvSisGshkturQk5z192DRbj6R6a8shIZN9lAXQQ9/H7Tt/b7NgZW4OFWhXGBt/BD8vTNp2K3J1+OKjuuiyO0YQeFvxjcNfjG64DdXX5Y54h0rA0wE1ct7f915FwiSum+bmF3FoB797ex9Hs+MwHT17zIxipbciN0HBxKVeDFASldsEaf6rakU+NMsu+D73UyIiLSzYkyzhMenx23VAgzBNPh4aQnFjbQulNx9U0zfKzNf6c47cJHCoeF2xmBlJgT5jkrBLK6CGyBcb6/fRteJfS1rDQXJFCZbQJsstKQ1JIoGX7o7sMIRSNEHp1ODJw0vgwTfZOKMT0Nq6+t6GPDFTckX2pthz4BhNRec+yAF2tvkPfRCWazlueeVgCslpCZjsOACUjkP8ZT5vpC9qwvFnY4iG4ahSuv2oiVpD72p4rEpZAdMHVsLY66nYCw3j+hKoRI5zFLWDffTcS8wTcFgFcHfpDiP8FASdzsAWKDJnaEMFOP42rxLgbd29reD4FPsH1Ce/ujlhvGnZynv6AFGf4VjkSJiX8NO8Wbm933w+d/p1I/KZp5YFZM0K23qc82H17XYJclCl2y6o21L6Gyy9VLt4v9h/gC10TPoQTCVaxz+EQhbg0UeKjmHJC/sOP4qP+1bmV5qSr//ZIAPNU5vJLPSU4ZM0Oh/pZwv45lkpnPKF/9jQ/3fkvqr16ml1EQNRPibCJQXopa/HDzGd2Mc0QDBrt0acTWH03iBGfXEaT7bQOyvE+8GAeFo3TGRjNFsbnM4X3JCIC/534ugn3p3wQWIcy81wdetqnBhKj6HWi3VApiD+/qzTLlIDnFcwH2GB+fgro06qIv5xOnF1xd8QfOnQe+33JlinQE1OOPpzL9OxDtjlXjcHMOrBaTdkHM0d8HHfoDWhsAwiIQDUCthkqeHZRiWkxlsPAFLiyVIECxU0+Y8UnbWBu3DTpUk6nz+X9Rh4o5nC4jl1j+A9IG47MmO/LN9GeyYhgX2oUqwv0Fw4uIY6bB6tXbQIyB3l3GIUsgyk1L5VsJ5+B4IZZxmftP2lxodaKk0m60xWxW6IKqSta8k/+SLTMq92Ij+sN2WcglF2WLZfG2oqpLmEPSbfXALV8GyvE8WyBDWEdX1AZhoV6VE6lul9xkjfThT/pgxGkAK0BbqHrlc0mZm9TAZpbiQkx38VKf1CGky+hAb1b3yu6hkVyFdxAP/korrah55THGVuVXmrwKgawLGUAReP/JzwDOt03nnCH/cWEICsg4U7Z2wr4gpNWbqtkkivKKbqrazxSRqGKK33EBfDv0FTXkgo8hi/UCfPSz9+ms7np/0N86ekwJsxATcku7zLab1VVgu877sRLRpT8UnrKnHKM3ZI+YdyiQtZf6szn0yUbeV+z3OREmZbKtAhltN9S/9d2C6ekfhzuZDh+P/G8A9mS5v4AY+yl3//F5XHLnP/QofUAbZp+L1DLSOXrj2vEUCAswlNUctR0yARrm2ecnP4BtQyUd+Uy55K8Xjw7l0xnTGWzhdlwQeX1nDOIRDWCHQ8XpcZFrjltX6mS9gK78vEa6t57Vu3XCj3cvmRdCwGzZ25ylmNgeZ59YyrZ6Gmg5CZTHAo/YUiQbcKTOICVUEArwQ4ynJaavqh+BVamPTRhZUWpgtXM8mcF4Kv8GF2cUTdFVn7399IsySdeolo7ZLT7fUtjTvzRcqocBR9rJsUgyP+iLbH064MWZvBnRhd+gB4XTI2uwY/BytboKiOBofm0Vh5zM38pKKoa6YcVQW4nJe/8WcrveltiCQlsyeVToUJLlOJMTYMhr0RwmLMyB+wyFQNmZCjif+6SUKHgeL6v3SxrCMQ2sThbMwG0asscImgUV2ALHvsq1BghkIIJ8NtJIl8XtfPZH6xES9mp/L1+omH4AycmMB1K2zhHyabGYnC1XrtFtJGHro4mBDzRgKqGa4TZkEvYK0RuHMAm1bpUHxIl1Kjqv0n8hI9TSY7xznAhh8mQgEUFgoeujjHy6KNiDziDMjRnTuATQ9Q4+EF7vP6TGKuvQs55kH29sN0kMQ/EdxfreA57FzNSaWSyxF3gI19G45z3jAvATdvWYWWzFwBgv4MmTMQQpYt0bnMJr4ZgSvBX6oUDtXjpTHJ8xd0amo2PlZooPo1iSs64Mxe7DoMa4UD+y/KV6wtyxiVcicScsNBhyJWsLx5y/nu0Ej09gP2jHouCFcnfrWPamZ5wTVsK7THA70L21JvRfKfGvDlA+5/USBXYSQzSlCfAj+U1o/RVu9zNg7dYoUE9rspcX0iSf9gv+o+Lu0oTn3IQQ3wM1/hvAzs0s8a2ewXfwHneuIam+bcenroSVRO61lJRdHyWpDDL81jaU36HDlzoZCbMZXtJss4Re9rSXwx5MoZAJLE6GEeVrk5VF4TwL72TbacMYHbnMJYfr3ZIsrGfjgIKfySdNpSKR11Il/X8R3/6UA5yUUy0+9n2gueJgigsIL9Qiypm/KiZbuO31W951vBwIsdwlZye555SB9vSsKZh+yGxRjhThrSr+TYz+WOImfBuSWBD06Cg9+3c+LykVfByRR/k5Xt2LKZKwXqqpeWMcLvjlSF8Pc11lTMQVKuweiWHHdlF2/WSIe61eJgJKl3AoTIMM6KGJvLH4HD2NuUUnFJe2Td1j8A8kBHTWl0kGxjYvH/bWFqEfJJXZTW1AE5Q7Ah5YFUR9dYQgFv5Gx9foVWhjt/fSYO2DI43ldEhx0o/TY+m/JDDz5Gyp+vySeXvLGFgrUxTF2biNBAzcHciXzaEsYl9dKreOukTlp+Axskfra8fjejj1nPfWwJCloJ9kTHG31QUr7jpLV6rupik98o49oRDUIqH3YMp0/GhT0K1hgJ3ol2gRo8unkEIg5w8mwUcXschwlN+fMb9v3/+kCTs0ttVDH73vEwmMWIbJk4EamJYsMG+i0XwvYXy5zwK8N/gnoQHa/yDVp/zmgFyGhu5aR+2PuoizffGtjXR06OmPBoewMIwy4FV2MQMF+jKLdhMBnSL6aymEgpnMASCnzb1b+bst9alC7GLa7lhoBqiK10yjIQlOgmXYK4fts3XmFiaLSvSqHiQJD0/UC2dZ2NE4o5/nVUaqtK22I33ZVs6shnpdVwUAEXPD/5X9o+/dwvctpPxfpf2f4yRF3Tzmae1IYv3+Em83zZkFKqC0NAfYvf4eN1Ji1E9B9bTcBp4OV1gCFlExMiSi8yyEzJiNvLw3trxU3/UdROZBz9G9mbdIMcMMdb+J/gY0tt9repLG1RYXWDgx8gutJqSG0RIrMsi0T4Hht5OxXs9FhmthLO0dzpeCiaHBNrPY0J74ZlgGFNWheGT823Upuy+wu5SfeosFiOOcGd6kbNHzjMzJlHPteWnN+cnkIjtD/uOmB2uDD+vxpyc816L7pMLiDgSJ0AlFDJUL99Wh5hqQHmsZ9gYOZCayyqXwJKJldgqco1rY5nJn8wAF/kwfre15b8l0zA/nnZWpAYpwxaryHTNkamTKsGQLBDdSHy/MTqgvDUqToSI7Y0TMSceccLXwlALz3ugYSGWE0iuTdAEA5bEdIPFxAZstnc0cuEzgc0oVa723WWfEB8CtY+yCwO/7i2m9WlBaBSnVbG94xaIJcrkAmiFzF3iI8FClz9fnPY5j8ZWvkSanzlIriawq6mE5dx4ewCslS5G1QzGgDD/5FCC5Y+yxpdzjnmk3TICS0Y15wvvRduEk2V5Oplw8/YKhcNxJt91sD0+UasssGY6I1+sGduIP6wJciJTynfMiGkymKHtFda7uAPSLpjw09H4XgkRiwDypxILkEMEqtEOpyLPbQoCF0c1QNtajNIcstolGLfH54ndLCFigxTk8D2ZF2yrEDzehpnoGJISA7gEWhGd/4Ic+pgQZlwDNmoYQcwUXwg+0TLr9lmT1CB6ThaQ8Srb1lO+KHOA5BN9Rbtny9DZMrUlJIMnqF7H8cLMSHB5Y1shjiTZyEryfeIGeTp5PhZ9pP/+1J/WQ9+w/GzdPPRgZuIyQZuzjw4UQAzolQ+SBks7bZNPM2Nx1JgJUo/5L7EL8MNvzXTNdB18t062cG+rxSVF/RPGV9UnJdlCuXNWHXTdsPhKwvNXIIMUeTbnPw8ZihO6h9un4edZrLe+N8m2jdBDb+bAQAgxoAYCrLu8GDlyEL9dyUTdme8Hgvw4PUAuxCSGy50wD92Jn0uiTlzONyhSe/hTZ4RXM1AiCDJ5xaZBONuW7JhLi8b2gjWnR5v3EE/hqcQ7On4BHDZcLmKxI6JZiPniciH0pwSbXWMZDgiwqFuGfu+RJ7ZsXbONDM9PwnzQ6NBpCHyGH+qcQ8sCOxEuErIWBTveYiD+uvFBxKDcstbWSWEWi5LcG9nTbAOAr5wnuWnMW+eaWU1uCrgMmihcSJ6LtZOvJv3XcotUv0mPIUMJruS9P7HATOvpeKtfOMhr2GHob0nMMc7c6nnnQexytzl1Wm6U4SbGqEr61lbRjpKBBbtHcCJJNntrPxtVd0Mv7vPkoBDtg8ucSrndWVRkiEHMPz7GAUCrnWoDpOBA4nmS7wHvZ5unRK/eDUSoPsFCMWwSa48NUBSp8k14d8dcEMrCzTeQoghVNEMK8UNTJ4bCtwm6PemLT8kTfHsYhMmxPqPGKm7rYXB9Iqc2btNmgBGns5e9hMACz4j7u57sT+F10NeoZ4JxNIh5haM6+wtolnjHVYnr263vTcm7gfKnj3l/hvyWzwohPYcgkL77wXnTdlt7eP947Cugz6rYj/rqb8/+vx7FBaW8PvnoDnxWV4UfyATd4ry6TCoe2GWk7clm5cSAAUoe3fQcLjrvqRV3jL/lJI8uaVXiOGzBv4Hkr2b65jYd5gSms1dbRUQDOfrI/iwep8dw45wVraMbaaIMosvKdwVa0WPkiP+pNbjE9A75lHQE8SfGFX7RHghXhtEeJY7SDgMpHrCyEQp1MA3B8BkzKMYPGJKFZQZRu1lzJ0Ga435OAWnkI8DpXQDWLpNlDSScDU7Jn8goYVtVDhV4+/58jSBoFZtBe60pnzKkn9wmwOdzZbGVqOAHdCiOOw4Zz0U0Lt+9brGP/pQMI/PtjweGTKXe4rnDmZCe7euh8eN6iobmbrv2uSNKuQFHxYwewPJpHWp75Umv3J0fiGVri8BwHZDhJvKmgvs97kMlCSEJd/o2fHmO20IJBBy3H4GCsHjshZ6/VVRX4zsaZ5ia0h0PpBuwBv9ofimIQhSGo6nMv9fdsV6lYhjfNzptWSaxHGNhna5U0NUDjB3eVKt366jkmvd1oqiZIh2CQpFMBsABNEBHn51aeoVw1a7r3wBDjZdNVhtkLIH3uXYc3za9Y/eBhbzPm/blAjYHJpWCx8KVDkx/59X8BX3gDPl8KER309POh6ycc1LT/LV+BpU13/6Bqrya420QyOeF87345yP6rOvGRUMqBcES+S+Oma46tQnVMfNuPancNqIRr6+m8fxs7s+nNde1A9C0tzUPYqmx7kfjMR4j866Kk4rSMobUFPRYeD/c50NkwXBcRyhQP4Vl1tlnAu5McfDZ84PbKoVvbb1O4uAKedki3XI2SoPnFatYfiNnEii6MG2XbsIdSmP31HNb7Uo4qyM5iW6104SaP0nRdYXiubbKG5IuDgej3BNUUYfWQTAQwlgPrSSLkRHkXIITtMxaQHrT+pw+ECVoKmoSrUyO/n21FVWteCoTkwOdVmxdHEaanBF0rn4M4/DiXdZULsVLBeuUH7RS0mqw3gDHzQWfaScnEDBMcIT9OhUC4WDaKCQB7C4cSlbhKRr7Duul2cUUpZ847+4uf1+0lFs18hP33s2jvEaOMKEr1kLRAr8BT6WF/etXZpCKrOHdkEGnihD8mwRm3aC6F/5ttOrTBoB0khOYltbtxfpvHZYZQ8vc/vmc0uyO/Dmx/2YNM/9SXqLV6C4qmvoXNUg2YJJa1RR8KqAqeWHsW7JFfn1MhR6OUCZMyd0HJYZKr5957F2nOdS+dQ6j9VYOZngErng3n2Ut2i31n4g7JNuWGfEm93f95G5NLxJtjOkT69JIBSRi9/79S17y38jkWExBHSVFrC97pp2lCfmJFUIWyjS85EuEoTlbctLlKJ9wBWwFNBW6QisFyR05SZtL1qtx01Cx1LJeGb+UCOO5RVjHsdjnpQ4/6isOc2x0JlRsPxUjWkdbkhLnjsXK30DvK8sVxfTmmEOGMpE3MP+f9vYD1FoPPoShXCIN6u9JubOC9a6GMYtZp/rwBXnJ1bIIMZ3wfOY/fyoD6Pc5GbEv6JeH9cOYBRqDp/teNG0GvOhQp5rJp0xxolESufrKjMBPBeMEglhrrOXPN7S+wnpQiGzcxPYg812MssllO58DnCCc9H4JCBDjQB0/miXfdTLHZ7OhaIMEcfbb6AIuHVrO5jO53NjMNvUPjBeDF+rzfdfDFEl3ljSLEkhwF4DwcnDQtwvrTWh1d9FNrHaf/NBQgoUV/i0PJqntx5Fx0E02vlBYjPXUoQa+GU/wqNR5QVuLL1KdlMz61vHdTBBXhjxh9Z92VO5qMBVUlVk8DieKPFUsQxpfZ7rEP39lf0H/ULNcTEkF3ru7lJTdcKeA/zSyNJZ4D7z/0S8zWoNtbDz31H91BF0uWISVyej7k237g5SzAqy7X+CCBqnwRkO8PtfzCeeJnO3vG01UK6X5PnGy/C4i/5wboQrPc6o+hqXm4bhHZZvYzt5QmQ22SubaLuSzNzI8BcDVdY4XiOziJPaYYpNEBj0+//cFeuB3MvkxIzroRhw0EvDG5aagi1eTbRMKBb4cMhM/AIKOs6sPfL9JacOpGk7hKmAUYxNccPgMvobn/+t0sZ9IKmQg9sRJqSApcVL4J1X8N3VAfRoMz0iaZSVNgQk7mkXaZm2kCdygMHGuoN3SGm7OCT/ljUFFqd+WDt4lOOdtUKbZgDGS8E42hk4CFL1WRkO+RbT7/wKYk/L+amhCd2n2GbJr0VtN83HYazyHGw6B8rFcJFALxY1oskr72sXXXwEFDNUbVdGxkxIHwCqOlOExt/prAnfd18IQHkf5Yzd5P47oGdCCIJbcv+UiZ6zh173MmA+4qP2u1NEZVCLrC4A3qaLkHBZHUK5/8TcboaXGkUFnQrVoW4Kvg1nvnT5AYaJFc+E2hDD3wQ23tOo17bQe9RSuL1BrMJEdj8fnVxFiwKMM+Ny0kzk4LrJ/TieelaNI99xI9Et/+NFmndZYyeJ+TWqSUvc1I07iQQSx8uNCm0cgY5DOny5Zgfv29qrOFXZoOQi72uOkutLnUXfoFGOoKZyXU3T5XAkztCSFsvy+3mllk43qeX/3PASo0ml54hIHxp8Cy3qgQQhoJuGQNiw</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      鸡汤 总结
    
    </summary>
    
      <category term="其他" scheme="https://andyxw.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://andyxw.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>React 技术栈</title>
    <link href="https://andyxw.com/archives/4a9b.html"/>
    <id>https://andyxw.com/archives/4a9b.html</id>
    <published>2018-07-26T02:26:34.000Z</published>
    <updated>2018-08-17T08:25:22.939Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 21 2019 19:08:35 GMT+0800 (GMT+08:00) --><h1 id="React-技术栈"><a href="#React-技术栈" class="headerlink" title="React 技术栈"></a>React 技术栈</h1><p>React 是目前最热门的前端框架。</p><ul><li>Facebook 公司2013年推出</li><li>现在最好的社区支持和生态圈</li><li>大量的第三方工具</li></ul><p><img src="./images/react-logo.png" alt=""></p><hr><h2 id="React-的优点"><a href="#React-的优点" class="headerlink" title="React 的优点"></a>React 的优点</h2><ul><li>组件模式：代码复用和团队分工</li><li>虚拟 DOM：性能优势</li><li>移动端支持：跨终端</li></ul><hr><h2 id="React-的缺点"><a href="#React-的缺点" class="headerlink" title="React 的缺点"></a>React 的缺点</h2><ul><li>学习曲线较陡峭</li><li>全新的一套概念，与其他所有框架截然不同</li><li>只有采用它的整个技术栈，才能发挥最大威力</li></ul><p>总结：React 非常先进和强大，但是学习和实现成本都不低</p><hr><h2 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h2><p>React 使用 JSX 语法，JavaScript 代码中可以写 HTML 代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTitle = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><hr><h2 id="JSX-语法解释"><a href="#JSX-语法解释" class="headerlink" title="JSX 语法解释"></a>JSX 语法解释</h2><p>（1）JSX 语法的最外层，只能有一个节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">let</span> myTitle = &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;;</span><br></pre></td></tr></table></figure><p>（2）JSX 语法中可以插入 JavaScript 代码，使用大括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTitle = &lt;p&gt;&#123;'Hello ' + 'World'&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="Babel-转码器"><a href="#Babel-转码器" class="headerlink" title="Babel 转码器"></a>Babel 转码器</h2><p>JavaScript 引擎（包括浏览器和 Node）都不认识 JSX，需要首先使用 Babel 转码，然后才能运行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"react.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"babel.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// ** Our code goes here! **</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React 需要加载两个库：React 和 React-DOM，前者是 React 的核心库，后者是 React 的 DOM 适配库。</p><p>Babel 用来在浏览器转换 JSX 语法，如果服务器已经转好了，浏览器就不需要加载这个库。</p><hr><h2 id="课堂练习：JSX-语法"><a href="#课堂练习：JSX-语法" class="headerlink" title="课堂练习：JSX 语法"></a>课堂练习：JSX 语法</h2><p>浏览器打开<code>demos/jsx-demo/index.html</code>，按照<a href="../demos/README.md#jsx">《操作说明》</a>，完成练习。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;span&gt;Hello World!<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h2 id="示例：React-组件"><a href="#示例：React-组件" class="headerlink" title="示例：React 组件"></a>示例：React 组件</h2><p>React 允许用户定义自己的组件，插入网页。</p><p>浏览器打开<code>demos/react-component-demo/index1.html</code>，按照<a href="../demos/README.md#react-组件语法">《操作说明》</a>，仔细查看源码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTitle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;MyTitle/&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h2 id="课堂练习：组件的参数"><a href="#课堂练习：组件的参数" class="headerlink" title="课堂练习：组件的参数"></a>课堂练习：组件的参数</h2><p>组件可以从外部传入参数，内部使用<code>this.props</code>获取参数。</p><p>打开<code>demos/react-component-demo/index2.html</code>，按照<a href="../demos/README.md#react-组件的参数">《操作说明》</a>，完成练习。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTitle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span></span></span></span><br><span class="line"><span class="xml">      style=&#123;&#123;color: this.props.color&#125;&#125;</span></span><br><span class="line"><span class="xml">    &gt;Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;MyTitle color=<span class="string">"red"</span> /&gt;,</span><br></pre></td></tr></table></figure><hr><h2 id="示例：组件的状态"><a href="#示例：组件的状态" class="headerlink" title="示例：组件的状态"></a>示例：组件的状态</h2><p>组件往往会有内部状态，使用<code>this.state</code>表示。</p><p>浏览器打开<code>demos/react-component-demo/index3.html</code>，按照<a href="../demos/README.md#react-组件的状态">《操作说明》</a>，仔细查看源码。</p><p><img src="./images/react-component-state.png" alt=""></p><hr><h2 id="课堂练习：React-组件实战"><a href="#课堂练习：React-组件实战" class="headerlink" title="课堂练习：React 组件实战"></a>课堂练习：React 组件实战</h2><p>浏览器打开<code>demos/react-component-demo/index4.html</code>，按照<a href="../demos/README.md#react-组件实战">《操作说明》</a>，完成练习。</p><hr><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>React 为组件的不同生命阶段，提供了近十个钩子方法。</p><ul><li><code>componentWillMount()</code>：组件加载前调用</li><li><code>componentDidMount()</code>：组件加载后调用</li><li><code>componentWillUpdate()</code>: 组件更新前调用</li><li><code>componentDidUpdate()</code>: 组件更新后调用</li><li><code>componentWillUnmount()</code>：组件卸载前调用</li><li><code>componentWillReceiveProps()</code>：组件接受新的参数时调用</li></ul><p>我们可以利用这些钩子，自动完成一些操作。</p><hr><h2 id="课堂练习：组件的生命周期"><a href="#课堂练习：组件的生命周期" class="headerlink" title="课堂练习：组件的生命周期"></a>课堂练习：组件的生命周期</h2><p>组件可以通过 Ajax 请求，从服务器获取数据。Ajax 请求一般在<code>componentDidMount</code>方法里面发出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">'...'</span>;</span><br><span class="line">  $.getJSON(url)</span><br><span class="line">    .done()</span><br><span class="line">    .fail();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开<code>demos/react-lifecycle-demo/index.html</code>，按照<a href="../demos/README.md#react-组件的生命周期">《操作说明》</a>，完成练习。</p><hr><h2 id="React-组件库"><a href="#React-组件库" class="headerlink" title="React 组件库"></a>React 组件库</h2><p>React 的一大优势，就是网上有很多已经写好的组件库，可以使用。</p><p>React-Bootstrap：<a href="https://react-bootstrap.github.io/" target="_blank" rel="noopener">https://react-bootstrap.github.io/</a></p><p><img src="./images/react-bootstrap.png" alt=""></p><hr><h2 id="示例：ReCharts"><a href="#示例：ReCharts" class="headerlink" title="示例：ReCharts"></a>示例：ReCharts</h2><p>ReCharts 是一个 React 图表组件库。<a href="http://recharts.org/" target="_blank" rel="noopener">http://recharts.org/</a></p><p>浏览器打开<code>demos/recharts-demo/index.html</code>，按照<a href="../demos/README.md#recharts">《操作说明》</a>，仔细查看源码，体会 JSX 语法对表达复杂组件的优势。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LineChart</span> <span class="attr">width</span>=<span class="string">&#123;1000&#125;</span> <span class="attr">height</span>=<span class="string">&#123;400&#125;</span> <span class="attr">data</span>=<span class="string">&#123;data&#125;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">XAxis</span> <span class="attr">dataKey</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">YAxis</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CartesianGrid</span> <span class="attr">stroke</span>=<span class="string">"#eee"</span> <span class="attr">strokeDasharray</span>=<span class="string">"5 5"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Line</span> <span class="attr">type</span>=<span class="string">"monotone"</span> <span class="attr">dataKey</span>=<span class="string">"uv"</span> <span class="attr">stroke</span>=<span class="string">"#8884d8"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Line</span> <span class="attr">type</span>=<span class="string">"monotone"</span> <span class="attr">dataKey</span>=<span class="string">"pv"</span> <span class="attr">stroke</span>=<span class="string">"#82ca9d"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LineChart</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="React-的核心思想"><a href="#React-的核心思想" class="headerlink" title="React 的核心思想"></a>React 的核心思想</h2><p>View 是 State 的输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view = f(state)</span><br></pre></td></tr></table></figure><p>上式中，<code>f</code>表示函数关系。只要 State 发生变化，View 也要随之变化。</p><hr><p>React 的本质是将图形界面（GUI）函数化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"michel"</span>,</span><br><span class="line">  age: <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">&#123; person &#125;</span>) =&gt;</span> &lt;h1&gt;&#123; person.name &#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App person=&#123;person&#125; /</span>&gt;, <span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure><hr><h2 id="React-没有解决的问题"><a href="#React-没有解决的问题" class="headerlink" title="React 没有解决的问题"></a>React 没有解决的问题</h2><p>React 本身只是一个 DOM 的抽象层，使用组件构建虚拟 DOM。</p><p>如果开发大应用，还需要解决两个问题。</p><ul><li>架构：大型应用程序应该如何组织代码？</li><li>通信：组件之间如何通信？</li></ul><hr><h2 id="架构问题"><a href="#架构问题" class="headerlink" title="架构问题"></a>架构问题</h2><p>React 只是视图层的解决方案，可以用于任何一种架构。</p><ul><li>MVC</li><li>MVVM</li><li>Observer</li><li>Reactive</li><li>…</li></ul><p>到底哪一种架构最合适 React ？</p><hr><h2 id="通信问题"><a href="#通信问题" class="headerlink" title="通信问题"></a>通信问题</h2><p>组件会发生三种通信。</p><ul><li>向子组件发消息</li><li>向父组件发消息</li><li>向其他组件发消息</li></ul><p>React 只提供了一种通信手段：传参。对于大应用，很不方便。</p><hr><h2 id="状态的同步"><a href="#状态的同步" class="headerlink" title="状态的同步"></a>状态的同步</h2><p>通信的本质是状态的同步。</p><p>React 同步状态的基本方法：找到通信双方最近的共同父组件，通过它的<code>state</code>，使得子组件的状态保持同步。</p><hr><h2 id="Flux-架构"><a href="#Flux-架构" class="headerlink" title="Flux 架构"></a>Flux 架构</h2><p>Facebook 提出 Flux 架构的概念，被认为是 React 应用的标准架构。</p><p><img src="./images/flow.png" alt=""></p><p>最大特点：数据单向流动。与 MVVM 的数据双向绑定，形成鲜明对比。</p><hr><h2 id="Flux-的核心思想"><a href="#Flux-的核心思想" class="headerlink" title="Flux 的核心思想"></a>Flux 的核心思想</h2><ul><li>不同组件的<code>state</code>，存放在一个外部的、公共的 Store 上面。</li><li>组件订阅 Store 的不同部分。</li><li>组件发送（dispatch）动作（action），引发 Store 的更新。</li></ul><p>Flux 只是一个概念，有30多种实现。</p><hr><h2 id="目前最流行的两个-React-架构"><a href="#目前最流行的两个-React-架构" class="headerlink" title="目前最流行的两个 React 架构"></a>目前最流行的两个 React 架构</h2><p>React 架构的最重要作用：管理 Store 与 View 之间的关系。</p><ul><li>MobX：响应式（Reactive）管理，state 是可变对象，适合中小型项目</li><li>Redux：函数式（Functional）管理，state 是不可变对象，适合大型项目</li></ul><hr><h2 id="MobX-架构"><a href="#MobX-架构" class="headerlink" title="MobX 架构"></a>MobX 架构</h2><p>MobX 的核心是观察者模式。</p><ul><li>Store 是被观察者（observable）</li><li>组件是观察者（observer）</li></ul><p>一旦<code>Store</code>有变化，会立刻被组件观察到，从而引发重新渲染。</p><hr><h2 id="MobX-的最简单例子"><a href="#MobX-的最简单例子" class="headerlink" title="MobX 的最简单例子"></a>MobX 的最简单例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;observable&#125; = mobx;</span><br><span class="line"><span class="keyword">const</span> &#123;observer&#125; = mobxReact;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = observable(&#123;<span class="attr">name</span>: <span class="string">"张三"</span>, <span class="attr">age</span>: <span class="number">31</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = observer(</span><br><span class="line">  (&#123; person &#125;) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123; person.name &#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">person</span>=<span class="string">&#123;person&#125;</span> /&gt;</span>, document.body);</span></span><br><span class="line"><span class="xml">person.name = "李四";</span></span><br></pre></td></tr></table></figure><p>代码：<code>demos/mobx-demo/browser-demo</code>目录</p><hr><h2 id="示例：MobX"><a href="#示例：MobX" class="headerlink" title="示例：MobX"></a>示例：MobX</h2><p>进入<code>demos/mobx-demo</code>目录，按照<a href="../demos/README.md#mobx">《操作说明》</a>，理解 MobX 框架。</p><hr><p>UI 层是观察者，Store 是被观察者。</p><p>Store 所有的属性，分成两大类：直接被观察的属性和自动计算出来的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  @observable name = <span class="string">'Bartek'</span>;</span><br><span class="line">  @computed get decorated() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is awesome!`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UI 会观察到 Store 的变化，自动重新渲染。</p><hr><h2 id="Redux-架构"><a href="#Redux-架构" class="headerlink" title="Redux 架构"></a>Redux 架构</h2><p>Redux 的核心概念</p><ul><li>所有的状态存放在<code>Store</code>。组件每次重新渲染，都必须由状态变化引起。</li><li>用户在 UI 上发出<code>action</code>。</li><li><code>reducer</code>函数接收<code>action</code>，然后根据当前的<code>state</code>，计算出新的<code>state</code>。</li></ul><p><img src="./images/redux-architecture.png" alt=""></p><hr><h2 id="Redux-应用的架构"><a href="#Redux-应用的架构" class="headerlink" title="Redux 应用的架构"></a>Redux 应用的架构</h2><p><img src="./images/architecture-redux.png" alt=""></p><p>Redux 层保存所有状态，React 组件拿到状态以后，渲染出 HTML 代码。</p><hr><h2 id="示例：Redux"><a href="#示例：Redux" class="headerlink" title="示例：Redux"></a>示例：Redux</h2><p>进入<code>demos/redux-demo</code>目录，按照<a href="../demos/README.md#redux">《操作说明》</a>，理解 Redux 框架。</p><hr><ul><li>Redux 将组件分成 UI 组件和容器组件两类。</li><li>UI 组件是纯组件，不包含 state 和生命周期方法，不涉及组件的行为，只涉及组件的外观。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">"index"</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;<span class="keyword">this</span>.props.text&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input</span></span><br><span class="line"><span class="regexp">    defaultValue=&#123;this.props.name&#125;</span></span><br><span class="line"><span class="regexp">    onChange=&#123;this.props.onChange&#125;</span></span><br><span class="line"><span class="regexp">  /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><hr><p>容器组件正好相反。</p><ul><li>不涉及组件的外观，只涉及组件的行为。</li><li>负责订阅 Store，将 Store 的数据处理以后，再通过参数传给 UI 组件。</li><li>用户给出配置以后，由 Redux 生成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// MyComponent 是纯的 UI 组件</span><br><span class="line">const App = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(MyComponent);</span><br></pre></td></tr></table></figure><ul><li>mapStateToProps: 定义 UI 组件参数与 State 之间的映射</li><li>mapDispatchToProps：定义 UI 组件与 Action 之间的映射</li></ul><hr><h2 id="拆分-UI-组件和容器组件的好处"><a href="#拆分-UI-组件和容器组件的好处" class="headerlink" title="拆分 UI 组件和容器组件的好处"></a>拆分 UI 组件和容器组件的好处</h2><ul><li>UI 组件与后台数据无关，可以由设计师负责</li><li>容器组件只负责数据和行为，一旦 Store 的数据结构变化，只要调整容器组件即可</li><li>表现层和功能层脱钩，有利于代码重用，也有利于看清应用的数据结构和业务逻辑</li></ul><hr><h2 id="Reducer-函数"><a href="#Reducer-函数" class="headerlink" title="Reducer 函数"></a>Reducer 函数</h2><p><code>reducer</code>是一个纯函数，用来接收<code>action</code>，算出新的<code>state</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  text: <span class="string">'你好，访问者'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  name: <span class="string">'访问者'</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'change'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        name: action.payload,</span><br><span class="line">        text: <span class="string">'你好，'</span> + action.payload</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><code>Store</code>由 Redux 提供的<code>createStore</code>方法生成，该方法接受<code>reducer</code>作为参数。</li><li>为了把<code>Store</code>传入组件，必须使用 Redux 提供的<code>Provider</code>组件在应用的最外面，包裹一层。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.body.appendChild(document.createElement('div'))</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><strong>本文作者</strong>： Andy<br><strong>本文地址</strong>： <a href="https://andyxw.com/archives/4a9b.html">https://andyxw.com/archives/4a9b.html</a><br><strong>版权声明</strong>： 转载请注明出处！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      React技术栈——阮一峰
    
    </summary>
    
      <category term="React" scheme="https://andyxw.com/categories/React/"/>
    
    
      <category term="React" scheme="https://andyxw.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 设计思想</title>
    <link href="https://andyxw.com/archives/7615.html"/>
    <id>https://andyxw.com/archives/7615.html</id>
    <published>2018-07-26T02:25:48.000Z</published>
    <updated>2018-08-17T07:35:48.233Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 21 2019 19:08:35 GMT+0800 (GMT+08:00) --><h1 id="React-设计思想"><a href="#React-设计思想" class="headerlink" title="React 设计思想"></a>React 设计思想</h1><blockquote><p>译者序：本文是 React 核心开发者、有 React API 终结者之称的 Sebastian Markbåge 撰写，阐述了他设计 React 的初衷。阅读此文，你能站在更高的高度思考 React 的过去、现在和未来。原文地址：<a href="https://github.com/reactjs/react-basic" target="_blank" rel="noopener">https://github.com/reactjs/react-basic</a></p></blockquote><a id="more"></a><p>我写此文是想正式地阐述我心中 React 的<a href="http://baike.baidu.com/view/2333986.htm" target="_blank" rel="noopener">心智模型</a>。目的是解释为什么我们会这样设计 React，同时你也可以根据这些论点反推出 React。</p><p>不可否认，此文中的部分论据或前提尚存争议，而且部分示例的设计可能存在 bug 或疏忽。这只是正式确定它的最初阶段。如果你有更好的完善它的想法可以随时提交 pull request。本文不会介绍框架细节中的奇技淫巧，相信这样能提纲挈领，让你看清 React 由简单到复杂的设计过程。</p><p>React.js 的真实实现中充满了具体问题的解决方案，渐进式的解法，算法优化，历史遗留代码，debug 工具以及其他一些可以让它真的具有高可用性的内容。这些代码可能并不稳定，因为未来浏览器的变化和功能权重的变化随时面临改变。所以具体的代码很难彻底解释清楚。</p><p>我偏向于选择一种我能完全 hold 住的简洁的心智模型来作介绍。</p><h2 id="变换（Transformation）"><a href="#变换（Transformation）" class="headerlink" title="变换（Transformation）"></a>变换（Transformation）</h2><p>设计 React 的核心前提是认为 UI 只是把数据通过映射关系变换成另一种形式的数据。同样的输入必会有同样的输出。这恰好就是纯函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NameBox</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">fontWeight</span>: <span class="string">'bold'</span>, <span class="attr">labelContent</span>: name &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;Sebastian Markbåge&apos; -&gt;</span><br><span class="line">&#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125;;</span><br></pre></td></tr></table></figure><h2 id="抽象（Abstraction）"><a href="#抽象（Abstraction）" class="headerlink" title="抽象（Abstraction）"></a>抽象（Abstraction）</h2><p>你不可能仅用一个函数就能实现复杂的 UI。重要的是，你需要把 UI 抽象成多个隐藏内部细节，又可复用的函数。通过在一个函数中调用另一个函数来实现复杂的 UI，这就是抽象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyUserBox</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    borderStyle: <span class="string">'1px solid blue'</span>,</span><br><span class="line">    childContent: [</span><br><span class="line">      <span class="string">'Name: '</span>,</span><br><span class="line">      NameBox(user.firstName + <span class="string">' '</span> + user.lastName)</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; firstName: &apos;Sebastian&apos;, lastName: &apos;Markbåge&apos; &#125; -&gt;</span><br><span class="line">&#123;</span><br><span class="line">  borderStyle: &apos;1px solid blue&apos;,</span><br><span class="line">  childContent: [</span><br><span class="line">    &apos;Name: &apos;,</span><br><span class="line">    &#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h2><p>为了真正达到重用的特性，只重用叶子然后每次都为他们创建一个新的容器是不够的。你还需要可以包含其他抽象的容器再次进行组合。我理解的“组合”就是将两个或者多个不同的抽象合并为一个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBox</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    borderStyle: <span class="string">'1px solid blue'</span>,</span><br><span class="line">    children: children</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserBox</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox([</span><br><span class="line">    <span class="string">'Name: '</span>,</span><br><span class="line">    NameBox(user.firstName + <span class="string">' '</span> + user.lastName)</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h2><p>UI 不单单是对服务器端或业务逻辑状态的复制。实际上还有很多状态是针对具体的渲染目标。举个例子，在一个 text field 中打字。它不一定要复制到其他页面或者你的手机设备。滚动位置这个状态是一个典型的你几乎不会复制到多个渲染目标的。</p><p>我们倾向于使用不可变的数据模型。我们把可以改变 state 的函数串联起来作为原点放置在顶层。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyNameBox</span>(<span class="params">user, likes, onClick</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox([</span><br><span class="line">    <span class="string">'Name: '</span>, NameBox(user.firstName + <span class="string">' '</span> + user.lastName),</span><br><span class="line">    <span class="string">'Likes: '</span>, LikeBox(likes),</span><br><span class="line">    LikeButton(onClick)</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现细节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> likes = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOneMoreLike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  likes++;</span><br><span class="line">  rerender();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">FancyNameBox(</span><br><span class="line">  &#123; <span class="attr">firstName</span>: <span class="string">'Sebastian'</span>, <span class="attr">lastName</span>: <span class="string">'Markbåge'</span> &#125;,</span><br><span class="line">  likes,</span><br><span class="line">  addOneMoreLike</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><em>注意：本例更新状态时会带来副作用（addOneMoreLike 函数中）。我实际的想法是当一个“update”传入时我们返回下一个版本的状态，但那样会比较复杂。此示例待更新</em></p><h2 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a>Memoization</h2><p>对于纯函数，使用相同的参数一次次调用未免太浪费资源。我们可以创建一个函数的 memorized 版本，用来追踪最后一个参数和结果。这样如果我们继续使用同样的值，就不需要反复执行它了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cachedArg;</span><br><span class="line">  <span class="keyword">var</span> cachedResult;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cachedArg === arg) &#123;</span><br><span class="line">      <span class="keyword">return</span> cachedResult;</span><br><span class="line">    &#125;</span><br><span class="line">    cachedArg = arg;</span><br><span class="line">    cachedResult = fn(arg);</span><br><span class="line">    <span class="keyword">return</span> cachedResult;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> MemoizedNameBox = memoize(NameBox);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NameAndAgeBox</span>(<span class="params">user, currentTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox([</span><br><span class="line">    <span class="string">'Name: '</span>,</span><br><span class="line">    MemoizedNameBox(user.firstName + <span class="string">' '</span> + user.lastName),</span><br><span class="line">    <span class="string">'Age in milliseconds: '</span>,</span><br><span class="line">    currentTime - user.dateOfBirth</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="列表（Lists）"><a href="#列表（Lists）" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h2><p>大部分 UI 都是展示列表数据中不同 item 的列表结构。这是一个天然的层级。</p><p>为了管理列表中的每一个 item 的 state ，我们可以创造一个 Map 容纳具体 item 的 state。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserList</span>(<span class="params">users, likesPerUser, updateUserLikes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> users.map(<span class="function"><span class="params">user</span> =&gt;</span> FancyNameBox(</span><br><span class="line">    user,</span><br><span class="line">    likesPerUser.get(user.id),</span><br><span class="line">    () =&gt; updateUserLikes(user.id, likesPerUser.get(user.id) + <span class="number">1</span>)</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> likesPerUser = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateUserLikes</span>(<span class="params">id, likeCount</span>) </span>&#123;</span><br><span class="line">  likesPerUser.set(id, likeCount);</span><br><span class="line">  rerender();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserList(data.users, likesPerUser, updateUserLikes);</span><br></pre></td></tr></table></figure><p><em>注意：现在我们向 FancyNameBox 传了多个不同的参数。这打破了我们的 memoization 因为我们每次只能存储一个值。更多相关内容在下面。</em></p><h2 id="连续性（Continuations）"><a href="#连续性（Continuations）" class="headerlink" title="连续性（Continuations）"></a>连续性（Continuations）</h2><p>不幸的是，自从 UI 中有太多的列表，明确的管理就需要大量的重复性样板代码。</p><p>我们可以通过推迟一些函数的执行，进而把一些模板移出业务逻辑。比如，使用“柯里化”（JavaScript 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener"><code>bind</code></a>）。然后我们可以从核心的函数外面传递 state，这样就没有样板代码了。</p><p>下面这样并没有减少样板代码，但至少把它从关键业务逻辑中剥离。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyUserList</span>(<span class="params">users</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox(</span><br><span class="line">    UserList.bind(<span class="literal">null</span>, users)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> box = FancyUserList(data.users);</span><br><span class="line"><span class="keyword">const</span> resolvedChildren = box.children(likesPerUser, updateUserLikes);</span><br><span class="line"><span class="keyword">const</span> resolvedBox = &#123;</span><br><span class="line">  ...box,</span><br><span class="line">  children: resolvedChildren</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="State-Map"><a href="#State-Map" class="headerlink" title="State Map"></a>State Map</h2><p>之前我们知道可以使用组合避免重复执行相同的东西这样一种重复模式。我们可以把执行和传递 state 逻辑挪动到被复用很多的低层级的函数中去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBoxWithState</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  stateMap,</span></span></span><br><span class="line"><span class="function"><span class="params">  updateState</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox(</span><br><span class="line">    children.map(<span class="function"><span class="params">child</span> =&gt;</span> child.continuation(</span><br><span class="line">      stateMap.get(child.key),</span><br><span class="line">      updateState</span><br><span class="line">    ))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserList</span>(<span class="params">users</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> users.map(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">    continuation: FancyNameBox.bind(<span class="literal">null</span>, user),</span><br><span class="line">    key: user.id</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyUserList</span>(<span class="params">users</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBoxWithState.bind(<span class="literal">null</span>,</span><br><span class="line">    UserList(users)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> continuation = FancyUserList(data.users);</span><br><span class="line">continuation(likesPerUser, updateUserLikes);</span><br></pre></td></tr></table></figure><h2 id="Memoization-Map"><a href="#Memoization-Map" class="headerlink" title="Memoization Map"></a>Memoization Map</h2><p>一旦我们想在一个 memoization 列表中 memoize 多个 item 就会变得很困难。因为你需要制定复杂的缓存算法来平衡调用频率和内存占有率。</p><p>还好 UI 在同一个位置会相对的稳定。相同的位置一般每次都会接受相同的参数。这样以来，使用一个集合来做 memoization 是一个非常好用的策略。</p><p>我们可以用对待 state 同样的方式，在组合的函数中传递一个 memoization 缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg, memoizationCache</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memoizationCache.arg === arg) &#123;</span><br><span class="line">      <span class="keyword">return</span> memoizationCache.result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = fn(arg);</span><br><span class="line">    memoizationCache.arg = arg;</span><br><span class="line">    memoizationCache.result = result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBoxWithState</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  stateMap,</span></span></span><br><span class="line"><span class="function"><span class="params">  updateState,</span></span></span><br><span class="line"><span class="function"><span class="params">  memoizationCache</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox(</span><br><span class="line">    children.map(<span class="function"><span class="params">child</span> =&gt;</span> child.continuation(</span><br><span class="line">      stateMap.get(child.key),</span><br><span class="line">      updateState,</span><br><span class="line">      memoizationCache.get(child.key)</span><br><span class="line">    ))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MemoizedFancyNameBox = memoize(FancyNameBox);</span><br></pre></td></tr></table></figure><h2 id="代数效应（Algebraic-Effects）"><a href="#代数效应（Algebraic-Effects）" class="headerlink" title="代数效应（Algebraic Effects）"></a>代数效应（Algebraic Effects）</h2><p>多层抽象需要共享琐碎数据时，一层层传递数据非常麻烦。如果能有一种方式可以在多层抽象中快捷地传递数据，同时又不需要牵涉到中间层级，那该有多好。React 中我们把它叫做“context”。</p><p>有时候数据依赖并不是严格按照抽象树自上而下进行。举个例子，在布局算法中，你需要在实现他们的位置之前了解子节点的大小。</p><p>现在，这个例子有一点超纲。我会使用 <a href="http://math.andrej.com/eff/" target="_blank" rel="noopener">代数效应</a> 这个由我发起的 <a href="https://esdiscuss.org/topic/one-shot-delimited-continuations-with-effect-handlers" target="_blank" rel="noopener">ECMAScript 新特性提议</a>。如果你对函数式编程很熟悉，它们 在避免由 monad 强制引入的仪式一样的编码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeBorderColorRequest</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBox</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> color = raise <span class="keyword">new</span> ThemeBorderColorRequest();</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    borderWidth: <span class="string">'1px'</span>,</span><br><span class="line">    borderColor: color,</span><br><span class="line">    children: children</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlueTheme</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">    children();</span><br><span class="line">  &#125; <span class="keyword">catch</span> effect ThemeBorderColorRequest -&gt; [, continuation] &#123;</span><br><span class="line">    continuation(<span class="string">'blue'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BlueTheme(</span><br><span class="line">    FancyUserList.bind(<span class="literal">null</span>, data.users)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本文作者</strong>： Andy<br><strong>本文地址</strong>： <a href="https://andyxw.com/archives/7615.html">https://andyxw.com/archives/7615.html</a><br><strong>版权声明</strong>： 转载请注明出处！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      React设计思想
    
    </summary>
    
      <category term="React" scheme="https://andyxw.com/categories/React/"/>
    
    
      <category term="React" scheme="https://andyxw.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React中的state和props</title>
    <link href="https://andyxw.com/archives/992.html"/>
    <id>https://andyxw.com/archives/992.html</id>
    <published>2018-07-26T02:23:10.000Z</published>
    <updated>2018-08-17T07:33:01.006Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 21 2019 19:08:35 GMT+0800 (GMT+08:00) --><p>整理一下React中关于state和props的知识点。</p><hr><p>在任何应用中，数据都是必不可少的。我们需要直接的改变页面上一块的区域来使得视图的刷新，或者间接地改变其他地方的数据。React的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在<code>props</code>和<code>state</code>中，这两个属性有啥子区别呢？</p><a id="more"></a><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>React的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件。</p><p>组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是<code>props</code>，所以可以把<code>props</code>理解为从外部传入组件内部的数据。由于React是单向数据流，所以<code>props</code>基本上也就是从服父级组件向子组件传递的数据。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>假设我们现在需要实现一个列表，根据React组件化思想，我们可以把列表中的行当做一个组件，也就是有这样两个组件：<code>&lt;ItemList/&gt;</code>和<code>&lt;Item/&gt;</code>。</p><p>先看看<code>&lt;ItemList/&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Item from &quot;./item&quot;;</span><br><span class="line">export default class ItemList extends React.Component&#123;</span><br><span class="line">  const itemList = data.map(item =&gt; &lt;Item item=item /&gt;);</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &#123;itemList&#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>列表的数据我们就暂时先假设是放在一个<code>data</code>变量中，然后通过<code>map</code>函数返回一个每一项都是<code>&lt;Item item=&#39;数据&#39;/&gt;</code>的数组，也就是说这里其实包含了<code>data.length</code>个<code>&lt;Item/&gt;</code>组件，数据通过在组件上自定义一个参数传递。当然，这里想传递几个自定义参数都可以。</p><p>在<code>&lt;Item /&gt;</code>中是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default class Item extends React.Component&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;li&gt;&#123;this.props.item&#125;&lt;/li&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>render</code>函数中可以看出，组件内部是使用<code>this.props</code>来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个<code>item</code>属性，所以通过<code>this.props.item</code>来获取即可。</p><h3 id="只读性"><a href="#只读性" class="headerlink" title="只读性"></a>只读性</h3><p><code>props</code>经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的<code>props</code>是只读的，不可改变的。如果<code>props</code>在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的<code>props</code>传入组件中。</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>在组件中，我们最好为<code>props</code>中的参数设置一个<code>defaultProps</code>，并且制定它的类型。比如，这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Item.defaultProps = &#123;</span><br><span class="line">  item: &apos;Hello Props&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Item.propTypes = &#123;</span><br><span class="line">  item: PropTypes.string,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于<code>propTypes</code>，可以声明为以下几种类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">optionalArray: PropTypes.array,</span><br><span class="line">optionalBool: PropTypes.bool,</span><br><span class="line">optionalFunc: PropTypes.func,</span><br><span class="line">optionalNumber: PropTypes.number,</span><br><span class="line">optionalObject: PropTypes.object,</span><br><span class="line">optionalString: PropTypes.string,</span><br><span class="line">optionalSymbol: PropTypes.symbol,</span><br></pre></td></tr></table></figure><p>注意，<code>bool</code>和<code>func</code>是简写。</p><p>这些知识基础数据类型，还有一些复杂的，附上链接：</p><p><a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">https://facebook.github.io/react/docs/typechecking-with-proptypes.html</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>props</code>是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的<code>props</code>来重新渲染子组件，否则子组件的<code>props</code>以及展现形式不会改变。</p><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p><code>state</code>是什么呢？</p><blockquote><p>State is similar to props, but it is private and fully controlled by the component.</p></blockquote><p>一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是<code>props</code>，而数据状态就是<code>state</code>。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default class ItemList extends React.Component&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      itemList:&apos;一些数据&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &#123;this.state.itemList&#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，在组件初始化的时候，通过<code>this.state</code>给组件设定一个初始的<code>state</code>，在第一次<code>render</code>的时候就会用这个数据来渲染组件。</p><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p><code>state</code>不同于<code>props</code>的一点是，<code>state</code>是可以被改变的。不过，不可以直接通过<code>this.state=</code>的方式来修改，而需要通过<code>this.setState()</code>方法来修改<code>state</code>。</p><p>比如，我们经常会通过异步操作来获取数据，我们需要在<code>didMount</code>阶段来执行异步操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">  fetch(&apos;url&apos;)</span><br><span class="line">    .then(response =&gt; response.json())</span><br><span class="line">    .then((data) =&gt; &#123;</span><br><span class="line">      this.setState(&#123;itemList:item&#125;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数据获取完成后，通过<code>this.setState</code>来修改数据状态。</p><p>当我们调用<code>this.setState</code>方法时，React会更新组件的数据状态<code>state</code>，并且重新调用<code>render</code>方法，也就是会对组件进行重新渲染。</p><p><strong>注意：通过<code>this.state=</code>来初始化<code>state</code>，使用<code>this.setState</code>来修改<code>state</code>，<code>constructor</code>是唯一能够初始化的地方。</strong></p><p><code>setState</code>接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default class ItemList extends React.Component&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      name:&apos;axuebin&apos;,</span><br><span class="line">      age:25,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    this.setState(&#123;age:18&#125;)  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行完<code>setState</code>之后的<code>state</code>应该是<code>{name:&#39;axuebin&#39;,age:18}</code>。</p><p><code>setState</code>还可以接受第二个参数，它是一个函数，会在<code>setState</code>调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">  name:&apos;xb&apos;</span><br><span class="line">&#125;,()=&gt;console.log(&apos;setState finished&apos;))</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>state</code>的主要作用是用于组件保存、控制以及修改自己的状态，它只能在<code>constructor</code>中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的<code>this.setState</code>来修改，修改<code>state</code>属性会导致组件的重新渲染。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li><code>state</code>是组件自己管理数据，控制自己的状态，可变；</li><li><code>props</code>是外部传入的数据参数，不可变；</li><li>没有<code>state</code>的叫做无状态组件，有<code>state</code>的叫做有状态组件；</li><li>多用<code>props</code>，少用<code>state</code>。也就是多写无状态组件。</li></ol><p><strong>本文作者</strong>： Andy<br><strong>本文地址</strong>： <a href="https://andyxw.com/archives/992.html">https://andyxw.com/archives/992.html</a><br><strong>版权声明</strong>： 转载请注明出处！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      React中的state和props
    
    </summary>
    
      <category term="React" scheme="https://andyxw.com/categories/React/"/>
    
    
      <category term="React" scheme="https://andyxw.com/tags/React/"/>
    
  </entry>
  
</feed>

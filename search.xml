<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React 技术栈]]></title>
    <url>%2F2018%2F07%2F26%2FReact-%E6%8A%80%E6%9C%AF%E6%A0%88%2F</url>
    <content type="text"><![CDATA[React 技术栈React 是目前最热门的前端框架。 Facebook 公司2013年推出 现在最好的社区支持和生态圈 大量的第三方工具 React 的优点 组件模式：代码复用和团队分工 虚拟 DOM：性能优势 移动端支持：跨终端 React 的缺点 学习曲线较陡峭 全新的一套概念，与其他所有框架截然不同 只有采用它的整个技术栈，才能发挥最大威力 总结：React 非常先进和强大，但是学习和实现成本都不低 JSX 语法React 使用 JSX 语法，JavaScript 代码中可以写 HTML 代码。 1let myTitle = &lt;h1&gt;Hello, world!&lt;/h1&gt;; JSX 语法解释（1）JSX 语法的最外层，只能有一个节点。 12// 错误let myTitle = &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;; （2）JSX 语法中可以插入 JavaScript 代码，使用大括号。 1let myTitle = &lt;p&gt;&#123;'Hello ' + 'World'&#125;&lt;/p&gt; Babel 转码器JavaScript 引擎（包括浏览器和 Node）都不认识 JSX，需要首先使用 Babel 转码，然后才能运行。 123456&lt;script src="react.js"&gt;&lt;/script&gt;&lt;script src="react-dom.js"&gt;&lt;/script&gt;&lt;script src="babel.min.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt; // ** Our code goes here! **&lt;/script&gt; React 需要加载两个库：React 和 React-DOM，前者是 React 的核心库，后者是 React 的 DOM 适配库。 Babel 用来在浏览器转换 JSX 语法，如果服务器已经转好了，浏览器就不需要加载这个库。 课堂练习：JSX 语法浏览器打开demos/jsx-demo/index.html，按照《操作说明》，完成练习。 1234ReactDOM.render( &lt;span&gt;Hello World!&lt;/span&gt;, document.getElementById('example')); 示例：React 组件React 允许用户定义自己的组件，插入网页。 浏览器打开demos/react-component-demo/index1.html，按照《操作说明》，仔细查看源码。 12345678910class MyTitle extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello World&lt;/h1&gt;; &#125;&#125;;ReactDOM.render( &lt;MyTitle/&gt;, document.getElementById('example')); 课堂练习：组件的参数组件可以从外部传入参数，内部使用this.props获取参数。 打开demos/react-component-demo/index2.html，按照《操作说明》，完成练习。 123456789class MyTitle extends React.Component &#123; render() &#123; return &lt;h1 style=&#123;&#123;color: this.props.color&#125;&#125; &gt;Hello World&lt;/h1&gt;; &#125;&#125;;&lt;MyTitle color="red" /&gt;, 示例：组件的状态组件往往会有内部状态，使用this.state表示。 浏览器打开demos/react-component-demo/index3.html，按照《操作说明》，仔细查看源码。 课堂练习：React 组件实战浏览器打开demos/react-component-demo/index4.html，按照《操作说明》，完成练习。 组件的生命周期React 为组件的不同生命阶段，提供了近十个钩子方法。 componentWillMount()：组件加载前调用 componentDidMount()：组件加载后调用 componentWillUpdate(): 组件更新前调用 componentDidUpdate(): 组件更新后调用 componentWillUnmount()：组件卸载前调用 componentWillReceiveProps()：组件接受新的参数时调用 我们可以利用这些钩子，自动完成一些操作。 课堂练习：组件的生命周期组件可以通过 Ajax 请求，从服务器获取数据。Ajax 请求一般在componentDidMount方法里面发出。 123456componentDidMount() &#123; const url = '...'; $.getJSON(url) .done() .fail();&#125; 打开demos/react-lifecycle-demo/index.html，按照《操作说明》，完成练习。 React 组件库React 的一大优势，就是网上有很多已经写好的组件库，可以使用。 React-Bootstrap：https://react-bootstrap.github.io/ 示例：ReChartsReCharts 是一个 React 图表组件库。http://recharts.org/ 浏览器打开demos/recharts-demo/index.html，按照《操作说明》，仔细查看源码，体会 JSX 语法对表达复杂组件的优势。 1234567&lt;LineChart width=&#123;1000&#125; height=&#123;400&#125; data=&#123;data&#125;&gt; &lt;XAxis dataKey="name"/&gt; &lt;YAxis/&gt; &lt;CartesianGrid stroke="#eee" strokeDasharray="5 5"/&gt; &lt;Line type="monotone" dataKey="uv" stroke="#8884d8" /&gt; &lt;Line type="monotone" dataKey="pv" stroke="#82ca9d" /&gt;&lt;/LineChart&gt; React 的核心思想View 是 State 的输出。 1view = f(state) 上式中，f表示函数关系。只要 State 发生变化，View 也要随之变化。 React 的本质是将图形界面（GUI）函数化。 12345678const person = &#123; name: "michel", age: 31&#125;const App = (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body) React 没有解决的问题React 本身只是一个 DOM 的抽象层，使用组件构建虚拟 DOM。 如果开发大应用，还需要解决两个问题。 架构：大型应用程序应该如何组织代码？ 通信：组件之间如何通信？ 架构问题React 只是视图层的解决方案，可以用于任何一种架构。 MVC MVVM Observer Reactive … 到底哪一种架构最合适 React ？ 通信问题组件会发生三种通信。 向子组件发消息 向父组件发消息 向其他组件发消息 React 只提供了一种通信手段：传参。对于大应用，很不方便。 状态的同步通信的本质是状态的同步。 React 同步状态的基本方法：找到通信双方最近的共同父组件，通过它的state，使得子组件的状态保持同步。 Flux 架构Facebook 提出 Flux 架构的概念，被认为是 React 应用的标准架构。 最大特点：数据单向流动。与 MVVM 的数据双向绑定，形成鲜明对比。 Flux 的核心思想 不同组件的state，存放在一个外部的、公共的 Store 上面。 组件订阅 Store 的不同部分。 组件发送（dispatch）动作（action），引发 Store 的更新。 Flux 只是一个概念，有30多种实现。 目前最流行的两个 React 架构React 架构的最重要作用：管理 Store 与 View 之间的关系。 MobX：响应式（Reactive）管理，state 是可变对象，适合中小型项目 Redux：函数式（Functional）管理，state 是不可变对象，适合大型项目 MobX 架构MobX 的核心是观察者模式。 Store 是被观察者（observable） 组件是观察者（observer） 一旦Store有变化，会立刻被组件观察到，从而引发重新渲染。 MobX 的最简单例子1234567891011const &#123;observable&#125; = mobx;const &#123;observer&#125; = mobxReact;const person = observable(&#123;name: "张三", age: 31&#125;);const App = observer( (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;);ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body);person.name = "李四"; 代码：demos/mobx-demo/browser-demo目录 示例：MobX进入demos/mobx-demo目录，按照《操作说明》，理解 MobX 框架。 UI 层是观察者，Store 是被观察者。 Store 所有的属性，分成两大类：直接被观察的属性和自动计算出来的属性。 123456class Store &#123; @observable name = 'Bartek'; @computed get decorated() &#123; return `$&#123;this.name&#125; is awesome!`; &#125;&#125; UI 会观察到 Store 的变化，自动重新渲染。 Redux 架构Redux 的核心概念 所有的状态存放在Store。组件每次重新渲染，都必须由状态变化引起。 用户在 UI 上发出action。 reducer函数接收action，然后根据当前的state，计算出新的state。 Redux 应用的架构 Redux 层保存所有状态，React 组件拿到状态以后，渲染出 HTML 代码。 示例：Redux进入demos/redux-demo目录，按照《操作说明》，理解 Redux 框架。 Redux 将组件分成 UI 组件和容器组件两类。 UI 组件是纯组件，不包含 state 和生命周期方法，不涉及组件的行为，只涉及组件的外观。 1234567&lt;div className="index"&gt; &lt;p&gt;&#123;this.props.text&#125;&lt;/p&gt; &lt;input defaultValue=&#123;this.props.name&#125; onChange=&#123;this.props.onChange&#125; /&gt;&lt;/div&gt; 容器组件正好相反。 不涉及组件的外观，只涉及组件的行为。 负责订阅 Store，将 Store 的数据处理以后，再通过参数传给 UI 组件。 用户给出配置以后，由 Redux 生成。 12345// MyComponent 是纯的 UI 组件const App = connect( mapStateToProps, mapDispatchToProps)(MyComponent); mapStateToProps: 定义 UI 组件参数与 State 之间的映射 mapDispatchToProps：定义 UI 组件与 Action 之间的映射 拆分 UI 组件和容器组件的好处 UI 组件与后台数据无关，可以由设计师负责 容器组件只负责数据和行为，一旦 Store 的数据结构变化，只要调整容器组件即可 表现层和功能层脱钩，有利于代码重用，也有利于看清应用的数据结构和业务逻辑 Reducer 函数reducer是一个纯函数，用来接收action，算出新的state。 123456789101112function reducer(state = &#123; text: '你好，访问者', name: '访问者'&#125;, action) &#123; switch (action.type) &#123; case 'change': return &#123; name: action.payload, text: '你好，' + action.payload &#125;; &#125;&#125; Store由 Redux 提供的createStore方法生成，该方法接受reducer作为参数。 为了把Store传入组件，必须使用 Redux 提供的Provider组件在应用的最外面，包裹一层。 12345678const store = createStore(reducer);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.body.appendChild(document.createElement('div')));]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 设计思想]]></title>
    <url>%2F2018%2F07%2F26%2FReact-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[React 设计思想 译者序：本文是 React 核心开发者、有 React API 终结者之称的 Sebastian Markbåge 撰写，阐述了他设计 React 的初衷。阅读此文，你能站在更高的高度思考 React 的过去、现在和未来。原文地址：https://github.com/reactjs/react-basic 我写此文是想正式地阐述我心中 React 的心智模型。目的是解释为什么我们会这样设计 React，同时你也可以根据这些论点反推出 React。 不可否认，此文中的部分论据或前提尚存争议，而且部分示例的设计可能存在 bug 或疏忽。这只是正式确定它的最初阶段。如果你有更好的完善它的想法可以随时提交 pull request。本文不会介绍框架细节中的奇技淫巧，相信这样能提纲挈领，让你看清 React 由简单到复杂的设计过程。 React.js 的真实实现中充满了具体问题的解决方案，渐进式的解法，算法优化，历史遗留代码，debug 工具以及其他一些可以让它真的具有高可用性的内容。这些代码可能并不稳定，因为未来浏览器的变化和功能权重的变化随时面临改变。所以具体的代码很难彻底解释清楚。 我偏向于选择一种我能完全 hold 住的简洁的心智模型来作介绍。 变换（Transformation）设计 React 的核心前提是认为 UI 只是把数据通过映射关系变换成另一种形式的数据。同样的输入必会有同样的输出。这恰好就是纯函数。 123function NameBox(name) &#123; return &#123; fontWeight: 'bold', labelContent: name &#125;;&#125; 12&apos;Sebastian Markbåge&apos; -&gt;&#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125;; 抽象（Abstraction）你不可能仅用一个函数就能实现复杂的 UI。重要的是，你需要把 UI 抽象成多个隐藏内部细节，又可复用的函数。通过在一个函数中调用另一个函数来实现复杂的 UI，这就是抽象。 123456789function FancyUserBox(user) &#123; return &#123; borderStyle: '1px solid blue', childContent: [ 'Name: ', NameBox(user.firstName + ' ' + user.lastName) ] &#125;;&#125; 12345678&#123; firstName: &apos;Sebastian&apos;, lastName: &apos;Markbåge&apos; &#125; -&gt;&#123; borderStyle: &apos;1px solid blue&apos;, childContent: [ &apos;Name: &apos;, &#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125; ]&#125;; 组合（Composition）为了真正达到重用的特性，只重用叶子然后每次都为他们创建一个新的容器是不够的。你还需要可以包含其他抽象的容器再次进行组合。我理解的“组合”就是将两个或者多个不同的抽象合并为一个。 12345678910111213function FancyBox(children) &#123; return &#123; borderStyle: '1px solid blue', children: children &#125;;&#125;function UserBox(user) &#123; return FancyBox([ 'Name: ', NameBox(user.firstName + ' ' + user.lastName) ]);&#125; 状态（State）UI 不单单是对服务器端或业务逻辑状态的复制。实际上还有很多状态是针对具体的渲染目标。举个例子，在一个 text field 中打字。它不一定要复制到其他页面或者你的手机设备。滚动位置这个状态是一个典型的你几乎不会复制到多个渲染目标的。 我们倾向于使用不可变的数据模型。我们把可以改变 state 的函数串联起来作为原点放置在顶层。 1234567891011121314151617181920212223function FancyNameBox(user, likes, onClick) &#123; return FancyBox([ 'Name: ', NameBox(user.firstName + ' ' + user.lastName), 'Likes: ', LikeBox(likes), LikeButton(onClick) ]);&#125;// 实现细节var likes = 0;function addOneMoreLike() &#123; likes++; rerender();&#125;// 初始化FancyNameBox( &#123; firstName: 'Sebastian', lastName: 'Markbåge' &#125;, likes, addOneMoreLike); 注意：本例更新状态时会带来副作用（addOneMoreLike 函数中）。我实际的想法是当一个“update”传入时我们返回下一个版本的状态，但那样会比较复杂。此示例待更新 Memoization对于纯函数，使用相同的参数一次次调用未免太浪费资源。我们可以创建一个函数的 memorized 版本，用来追踪最后一个参数和结果。这样如果我们继续使用同样的值，就不需要反复执行它了。 1234567891011121314151617181920212223function memoize(fn) &#123; var cachedArg; var cachedResult; return function(arg) &#123; if (cachedArg === arg) &#123; return cachedResult; &#125; cachedArg = arg; cachedResult = fn(arg); return cachedResult; &#125;;&#125;var MemoizedNameBox = memoize(NameBox);function NameAndAgeBox(user, currentTime) &#123; return FancyBox([ 'Name: ', MemoizedNameBox(user.firstName + ' ' + user.lastName), 'Age in milliseconds: ', currentTime - user.dateOfBirth ]);&#125; 列表（Lists）大部分 UI 都是展示列表数据中不同 item 的列表结构。这是一个天然的层级。 为了管理列表中的每一个 item 的 state ，我们可以创造一个 Map 容纳具体 item 的 state。 123456789101112131415function UserList(users, likesPerUser, updateUserLikes) &#123; return users.map(user =&gt; FancyNameBox( user, likesPerUser.get(user.id), () =&gt; updateUserLikes(user.id, likesPerUser.get(user.id) + 1) ));&#125;var likesPerUser = new Map();function updateUserLikes(id, likeCount) &#123; likesPerUser.set(id, likeCount); rerender();&#125;UserList(data.users, likesPerUser, updateUserLikes); 注意：现在我们向 FancyNameBox 传了多个不同的参数。这打破了我们的 memoization 因为我们每次只能存储一个值。更多相关内容在下面。 连续性（Continuations）不幸的是，自从 UI 中有太多的列表，明确的管理就需要大量的重复性样板代码。 我们可以通过推迟一些函数的执行，进而把一些模板移出业务逻辑。比如，使用“柯里化”（JavaScript 中的 bind）。然后我们可以从核心的函数外面传递 state，这样就没有样板代码了。 下面这样并没有减少样板代码，但至少把它从关键业务逻辑中剥离。 123456789101112function FancyUserList(users) &#123; return FancyBox( UserList.bind(null, users) );&#125;const box = FancyUserList(data.users);const resolvedChildren = box.children(likesPerUser, updateUserLikes);const resolvedBox = &#123; ...box, children: resolvedChildren&#125;; State Map之前我们知道可以使用组合避免重复执行相同的东西这样一种重复模式。我们可以把执行和传递 state 逻辑挪动到被复用很多的低层级的函数中去。 12345678910111213141516171819202122232425262728function FancyBoxWithState( children, stateMap, updateState) &#123; return FancyBox( children.map(child =&gt; child.continuation( stateMap.get(child.key), updateState )) );&#125;function UserList(users) &#123; return users.map(user =&gt; &#123; continuation: FancyNameBox.bind(null, user), key: user.id &#125;);&#125;function FancyUserList(users) &#123; return FancyBoxWithState.bind(null, UserList(users) );&#125;const continuation = FancyUserList(data.users);continuation(likesPerUser, updateUserLikes); Memoization Map一旦我们想在一个 memoization 列表中 memoize 多个 item 就会变得很困难。因为你需要制定复杂的缓存算法来平衡调用频率和内存占有率。 还好 UI 在同一个位置会相对的稳定。相同的位置一般每次都会接受相同的参数。这样以来，使用一个集合来做 memoization 是一个非常好用的策略。 我们可以用对待 state 同样的方式，在组合的函数中传递一个 memoization 缓存。 12345678910111213141516171819202122232425262728function memoize(fn) &#123; return function(arg, memoizationCache) &#123; if (memoizationCache.arg === arg) &#123; return memoizationCache.result; &#125; const result = fn(arg); memoizationCache.arg = arg; memoizationCache.result = result; return result; &#125;;&#125;function FancyBoxWithState( children, stateMap, updateState, memoizationCache) &#123; return FancyBox( children.map(child =&gt; child.continuation( stateMap.get(child.key), updateState, memoizationCache.get(child.key) )) );&#125;const MemoizedFancyNameBox = memoize(FancyNameBox); 代数效应（Algebraic Effects）多层抽象需要共享琐碎数据时，一层层传递数据非常麻烦。如果能有一种方式可以在多层抽象中快捷地传递数据，同时又不需要牵涉到中间层级，那该有多好。React 中我们把它叫做“context”。 有时候数据依赖并不是严格按照抽象树自上而下进行。举个例子，在布局算法中，你需要在实现他们的位置之前了解子节点的大小。 现在，这个例子有一点超纲。我会使用 代数效应 这个由我发起的 ECMAScript 新特性提议。如果你对函数式编程很熟悉，它们 在避免由 monad 强制引入的仪式一样的编码。 123456789101112131415161718192021222324function ThemeBorderColorRequest() &#123; &#125;function FancyBox(children) &#123; const color = raise new ThemeBorderColorRequest(); return &#123; borderWidth: '1px', borderColor: color, children: children &#125;;&#125;function BlueTheme(children) &#123; return try &#123; children(); &#125; catch effect ThemeBorderColorRequest -&gt; [, continuation] &#123; continuation('blue'); &#125;&#125;function App(data) &#123; return BlueTheme( FancyUserList.bind(null, data.users) );&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React中的state和props]]></title>
    <url>%2F2018%2F07%2F26%2FReact%E4%B8%AD%E7%9A%84state%E5%92%8Cprops%2F</url>
    <content type="text"><![CDATA[整理一下React中关于state和props的知识点。 在任何应用中，数据都是必不可少的。我们需要直接的改变页面上一块的区域来使得视图的刷新，或者间接地改变其他地方的数据。React的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在props和state中，这两个属性有啥子区别呢？ propsReact的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件。 组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是props，所以可以把props理解为从外部传入组件内部的数据。由于React是单向数据流，所以props基本上也就是从服父级组件向子组件传递的数据。 用法假设我们现在需要实现一个列表，根据React组件化思想，我们可以把列表中的行当做一个组件，也就是有这样两个组件：&lt;ItemList/&gt;和&lt;Item/&gt;。 先看看&lt;ItemList/&gt; 123456789import Item from &quot;./item&quot;;export default class ItemList extends React.Component&#123; const itemList = data.map(item =&gt; &lt;Item item=item /&gt;); render()&#123; return ( &#123;itemList&#125; ) &#125;&#125; 列表的数据我们就暂时先假设是放在一个data变量中，然后通过map函数返回一个每一项都是&lt;Item item=&#39;数据&#39;/&gt;的数组，也就是说这里其实包含了data.length个&lt;Item/&gt;组件，数据通过在组件上自定义一个参数传递。当然，这里想传递几个自定义参数都可以。 在&lt;Item /&gt;中是这样的： 1234567export default class Item extends React.Component&#123; render()&#123; return ( &lt;li&gt;&#123;this.props.item&#125;&lt;/li&gt; ) &#125;&#125; 在render函数中可以看出，组件内部是使用this.props来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个item属性，所以通过this.props.item来获取即可。 只读性props经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的props是只读的，不可改变的。如果props在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的props传入组件中。 默认参数在组件中，我们最好为props中的参数设置一个defaultProps，并且制定它的类型。比如，这样： 1234567Item.defaultProps = &#123; item: &apos;Hello Props&apos;,&#125;;Item.propTypes = &#123; item: PropTypes.string,&#125;; 关于propTypes，可以声明为以下几种类型： 1234567optionalArray: PropTypes.array,optionalBool: PropTypes.bool,optionalFunc: PropTypes.func,optionalNumber: PropTypes.number,optionalObject: PropTypes.object,optionalString: PropTypes.string,optionalSymbol: PropTypes.symbol, 注意，bool和func是简写。 这些知识基础数据类型，还有一些复杂的，附上链接： https://facebook.github.io/react/docs/typechecking-with-proptypes.html 总结props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。 statestate是什么呢？ State is similar to props, but it is private and fully controlled by the component. 一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是props，而数据状态就是state。 用法12345678910111213export default class ItemList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; itemList:&apos;一些数据&apos;, &#125; &#125; render()&#123; return ( &#123;this.state.itemList&#125; ) &#125;&#125; 首先，在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。 setStatestate不同于props的一点是，state是可以被改变的。不过，不可以直接通过this.state=的方式来修改，而需要通过this.setState()方法来修改state。 比如，我们经常会通过异步操作来获取数据，我们需要在didMount阶段来执行异步操作： 1234567componentDidMount()&#123; fetch(&apos;url&apos;) .then(response =&gt; response.json()) .then((data) =&gt; &#123; this.setState(&#123;itemList:item&#125;); &#125;&#125; 当数据获取完成后，通过this.setState来修改数据状态。 当我们调用this.setState方法时，React会更新组件的数据状态state，并且重新调用render方法，也就是会对组件进行重新渲染。 注意：通过this.state=来初始化state，使用this.setState来修改state，constructor是唯一能够初始化的地方。 setState接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如： 123456789101112export default class ItemList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name:&apos;axuebin&apos;, age:25, &#125; &#125; componentDidMount()&#123; this.setState(&#123;age:18&#125;) &#125;&#125; 在执行完setState之后的state应该是{name:&#39;axuebin&#39;,age:18}。 setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成： 123this.setState(&#123; name:&apos;xb&apos;&#125;,()=&gt;console.log(&apos;setState finished&apos;)) 总结state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。 区别 state是组件自己管理数据，控制自己的状态，可变； props是外部传入的数据参数，不可变； 没有state的叫做无状态组件，有state的叫做有状态组件； 多用props，少用state。也就是多写无状态组件。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解密传统组件间通信与React组件间通信]]></title>
    <url>%2Farchives%2Fac71.html</url>
    <content type="text"><![CDATA[在React中最小的逻辑单元是组件，组件之间如果有耦合关系就会进行通信，本文将会介绍React中的组件通信的不同方式通过归纳范，可以将任意组件间的通信归类为四种类型的组件间通信，分别是父子组件，爷孙组件，兄弟组件和任意组件，需要注意的是前三个也可以算作任意组件的范畴，所以最后一个是万能方法父子组件父子组件间的通信分为父组件向子组件通信和子组件向父组件通信两种情况，下面先来介绍父组件向子组件通信，传统做法分为两种情况，分别是初始化时的参数传递和实例阶段的方法调用，例子如下12345678910111213141516171819202122232425262728class Child &#123; constructor(name) &#123; // 获取dom引用 this.$div = document.querySelector('#wp'); // 初始化时传入name this.updateName(name); &#125; updateName(name) &#123; // 对外提供更新的api this.name = name; // 更新dom this.$div.innerHTML = name; &#125;&#125;class Parent &#123; constructor() &#123; // 初始化阶段 this.child = new Child('yan'); setTimeout(() =&gt; &#123; // 实例化阶段 this.child.updateName('hou'); &#125;, 2000); &#125;&#125;在React中将两个情况统一处理，全部通过属性来完成，之所以能够这样是因为React在属性更新时会自动重新渲染子组件，下面的例子中，2秒后子组件会自动重新渲染，并获取新的属性值1234567891011121314151617181920class Child extends Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt; &#125;&#125;class Parent extends Component &#123; constructor() &#123; // 初始化阶段 this.state = &#123;name: 'yan'&#125;; setTimeout(() =&gt; &#123; // 实例化阶段 this.setState(&#123;name: 'hou'&#125;) &#125;, 2000); &#125; render() &#123; return &lt;Child name=&#123;this.state.name&#125; /&gt; &#125;&#125;下面来看一下子组件如何向父组件通信，传统做法有两种，一种是回调函数，另一种是为子组件部署消息接口先来看回调函数的例子，回调函数的优点是非常简单，缺点就是必须在初始化的时候传入，并且不可撤回，并且只能传入一个函数123456789101112131415class Child &#123; constructor(cb) &#123; // 调用父组件传入的回调函数，发送消息 setTimeout(() =&gt; &#123; cb() &#125;, 2000); &#125;&#125;class Parent &#123; constructor() &#123; // 初始化阶段，传入回调函数 this.child = new Child(function () &#123; console.log('child update') &#125;); &#125;&#125;下面来看看消息接口方法，首先需要一个可以发布和订阅消息的基类，比如下面实现了一个简单的EventEimtter，实际生产中可以直接使用别人写好的类库，比如@jsmini/event，子组件继承消息基类，就有了发布消息的能力，然后父组件订阅子组件的消息，即可实现子组件向父组件通信的功能消息接口的优点就是可以随处订阅，并且可以多次订阅，还可以取消订阅，缺点是略显麻烦，需要引入消息基类123456789101112131415161718192021222324252627282930313233// 消息接口，订阅发布模式，类似绑定事件，触发事件class EventEimtter &#123; constructor() &#123; this.eventMap = &#123;&#125;; &#125; sub(name, cb) &#123; const eventList = this.eventMap[name] = this.eventMap[name] || &#123;&#125;; eventList.push(cb); &#125; pub(name, ...data) &#123; (this.eventMap[name] || []).forEach(cb =&gt; cb(...data)); &#125;&#125;class Child extends EventEimtter &#123; constructor() &#123; super(); // 通过消息接口发布消息 setTimeout(() =&gt; &#123; this.pub('update') &#125;, 2000); &#125;&#125;class Parent &#123; constructor() &#123; // 初始化阶段，传入回调函数 this.child = new Child(); // 订阅子组件的消息 this.child.sub('update', function () &#123; console.log('child update') &#125;); &#125;&#125;Backbone.js就同时支持回调函数和消息接口方式，但React中选择了比较简单的回调函数模式，下面来看一下React的例子1234567891011121314class Child extends Component &#123; constructor(props) &#123; setTimeout(() =&gt; &#123; this.props.cb() &#125;, 2000); &#125; render() &#123; return &lt;div&gt;&lt;/div&gt; &#125;&#125;class Parent extends Component &#123; render() &#123; return &lt;Child cb=&#123;() =&gt; &#123;console.log('update')&#125;&#125; /&gt; &#125;&#125;爷孙组件父子组件其实可以算是爷孙组件的一种特例，这里的爷孙组件不光指爷爷和孙子，而是泛指祖先与后代组件通信，可能隔着很多层级，我们已经解决了父子组件通信的问题，根据化归法，很容易得出爷孙组件的答案，那就是层层传递属性么，把爷孙组件通信分解为多个父子组件通信的问题层层传递的优点是非常简单，用已有知识就能解决，问题是会浪费很多代码，非常繁琐，中间作为桥梁的组件会引入很多不属于自己的属性在React中，通过context可以让祖先组件直接把属性传递到后代组件，有点类似星际旅行中的虫洞一样，通过context这个特殊的桥梁，可以跨越任意层次向后代组件传递消息怎么在需要通信的组件之间开启这个虫洞呢？需要双向声明，也就是在祖先组件声明属性，并在后代组件上再次声明属性，然后在祖先组件上放上属性就可以了，就可以在后代组件读取属性了，下面看一个例子123456789101112131415161718192021222324import PropTypes from 'prop-types';class Child extends Component &#123; // 后代组件声明需要读取context上的数据 static contextTypes = &#123; text: PropTypes.string &#125; render() &#123; // 通过this.context 读取context上的数据 return &lt;div&gt;&#123;this.context.text&#125;&lt;/div&gt; &#125;&#125;class Ancestor extends Component &#123; // 祖先组件声明需要放入context上的数据 static childContextTypes = &#123; text: PropTypes.string &#125; // 祖先组件往context放入数据 getChildContext() &#123; return &#123;text: 'yanhaijing'&#125; &#125;&#125;context的优点是可以省去层层传递的麻烦，并且通过双向声明控制了数据的可见性，对于层数很多时，不失为一种方案；但缺点也很明显，就像全局变量一样，如果不加节制很容易造成混乱，而且也容易出现重名覆盖的问题个人的建议是对一些所有组件共享的只读信息可以采用context来传递，比如登录的用户信息等小贴士：React Router路由就是通过context来传递路由属性的兄弟组件如果两个组件是兄弟关系，可以通过父组件作为桥梁，来让两个组件之间通信，这其实就是主模块模式下面的例子中，两个子组件通过父组件来实现显示数字同步的功能123456789101112131415class Parent extends Component &#123; constructor() &#123; this.onChange = function (num) &#123; this.setState(&#123;num&#125;) &#125;.bind(this); &#125; render() &#123; return ( &lt;div&gt; &lt;Child1 num=&#123;this.state.num&#125; onChange=&#123;this.onChange&#125;&gt; &lt;Child2 num=&#123;this.state.num&#125; onChange=&#123;this.onChange&#125;&gt; &lt;/div&gt; ); &#125;&#125;主模块模式的优点就是解耦，把两个子组件之间的耦合关系，解耦成子组件和父组件之间的耦合，把分散的东西收集在一起好处非常明显，能带来更好的可维护性和可扩展性任意组件任意组件包括上面的三种关系组件，上面三种关系应该优先使用上面介绍的方法，对于任意的两个组件间通信，总共有三种办法，分别是共同祖先法，消息中间件和状态管理基于我们上面介绍的爷孙组件和兄弟组件，只要找到两个组件的共同祖先，就可以将任意组件之间的通信，转化为任意组件和共同祖先之间的通信，这个方法的好处就是非常简单，已知知识就能搞定，缺点就是上面两种模式缺点的叠加，除了临时方案，不建议使用这种方法另一种比较常用的方法是消息中间件，就是引入一个全局消息工具，两个组件通过这个全局工具进行通信，这样两个组件间的通信，就通过全局消息媒介完成了还记得上面介绍的消息基类吗？下面的例子中，组件1和组件2通过全局event进行通信12345678910111213141516171819202122232425262728293031class EventEimtter &#123; constructor() &#123; this.eventMap = &#123;&#125;; &#125; sub(name, cb) &#123; const eventList = this.eventMap[name] = this.eventMap[name] || &#123;&#125;; eventList.push(cb); &#125; pub(name, ...data) &#123; (this.eventMap[name] || []).forEach(cb =&gt; cb(...data)); &#125;&#125;// 全局消息工具const event = new EventEimtter;// 一个组件class Element1 extends Component &#123; constructor() &#123; // 订阅消息 event.sub('element2update', () =&gt; &#123;console.log('element2 update')&#125;); &#125;&#125;// 另一个组件。class Element2 extends Component &#123; constructor() &#123; // 发布消息 setTimeout(function () &#123; event.pub('element2update') &#125;, 2000) &#125;&#125;消息中间件的模式非常简单，利用了观察者模式，将两个组件之间的耦合解耦成了组件和消息中心+消息名称的耦合，但为了解耦却引入全局消息中心和消息名称，消息中心对组件的侵入性很强，和第三方组件通信不能使用这种方式小型项目比较适合使用这种方式，但随着项目规模的扩大，达到中等项目以后，消息名字爆炸式增长，消息名字的维护成了棘手的问题，重名概率极大，没有人敢随便删除消息信息，消息的发布者找不到消息订阅者的信息等其实上面的问题也不是没有解决办法，重名的问题可以通过制定规范，消息命名空间等方式来极大降低冲突，其他问题可以通过把消息名字统一维护到一个文件，通过对消息的中心化管理，可以让很多问题都很容易解决如果你的项目非常大，上面两种方案都不合适，那你可能需要一个状态管理工具，通过状态管理工具把组件之间的关系，和关系的处理逻辑从组建中抽象出来，并集中化到统一的地方来处理，Redux就是一个非常不错的状态管理工具除了Redux，还有Mobx，Rematch，reselect等工具，本文不展开介绍，有机会后面单独成文，这些都是用来解决不同问题的，只要根据自己的场景选择合适的工具就好了总结组件间的关系千变万化，都可以用上面介绍的方法解决，对于不同规模的项目，应该选择适合自己的技术方案，上面介绍的不同方式解耦的程度是不一样的，关于不同耦合关系的好坏，可以看我之前的文章《图解7种耦合关系》]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解7种耦合关系]]></title>
    <url>%2Farchives%2F7e29.html</url>
    <content type="text"><![CDATA[深入讲讲模块之间的耦合关系这个事情。本文将用图文详细讲解七种耦合的不同之处。高内聚与低耦合高内聚与低耦合是每个软件开发者追求的目标，那么内聚和耦合分别是什么意思呢？内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。耦合不同模块之间的关系就是耦合，根据耦合程度可以分为7种，耦合度依次变低。内容耦合公共耦合外部耦合控制耦合标记耦合数据耦合非直接耦合下面我们来说说每种耦合是什么，开始之前先来说下要实现的功能。m1和m2是两个独立的模块，其中m2种会显示m1的输入，m1会显示m2的输入。很显然，m1和m2两个模块之间会有一些联系（耦合），你也可以想想如何实现这个功能，下面用7种不同的方式来实现这个功能。注：项目的代码我放到了github，项目的demo，可以在这里查看。内容耦合内容耦合是最紧的耦合程度，一个模块直接访问另一模块的内容，则称这两个模块为内容耦合。为了实现功能，我们将m1的输入放到m2.m1input上，将m2的输入放到m1.m2input上。// m1.js root.m2.m1input = this.value; m2.update(); // m2.js root.m1.m2input = this.value; m1.update(); PS:不知道谁会这么写代码，除了我为了做演示之外。。。查看完整代码和demo。公共耦合一组模块都访问同一个全局数据结构，则称之为公共耦合。在这种case中，m1和m2将自己的输入放到全局的data上。// m1.js root.data.m1input = this.value; m2.update(); // m2.js root.data.m2input = this.value; m1.update(); 查看完整代码和demo。外部耦合一组模块都访问同一全局简单变量，而且不通过参数表传递该全局变量的信息，则称之为外部耦合。外部耦合和公共耦合很像，区别就是一个是简单变量，一个是复杂数据结构。在这种case中，m1和m2都将自己的输入放到全局上。// m1.js root.m1input = this.value; m2.update(); // m2.js root.m2input = this.value; m1.update(); 查看完整代码和demo。控制耦合模块之间传递的不是数据信息，而是控制信息例如标志、开关量等，一个模块控制了另一个模块的功能。从控制耦合开始，模块的数据就放在自己内部了，不同模块之间通过接口互相调用。在这个case中，得增加一个需求，就是当m1的输入为空时，隐藏m2的显示信息。// m1.js root.m1input = this.value; m2.update(); m2.toggle(!!this.value); // 传递flag 上面的代码中m1直接控制了m2的显示和隐藏。查看完整代码和demo。标记耦合调用模块和被调用模块之间传递数据结构而不是简单数据，同时也称作特征耦合。在这个case中，m1传给m2的是一个对象。// m1.js me.m1input = this.value; m2.update(me); // 传递引用 // m2.js me.m2input = this.value; m1.update(me); 查看完整代码和demo。数据耦合调用模块和被调用模块之间只传递简单的数据项参数。相当于高级语言中的值传递。在这个case中，m1传给m2的是一个简单数据结构。// m1.js me.m1input = this.value; m2.update(me.m1input); // 传递值 // m2.js me.m2input = this.value; m1.update(me.m2input); 查看完整代码和demo。非直接耦合两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。耦合度最弱，模块独立性最强。子模块无需知道对方的存在，子模块之间的联系，全部变成子模块和主模块之间的联系。在这个case种，增加一个index.js作为主模块。// index.js var m1 = root.m1; var m2 = root.m2; m1.init(function (str) { m2.update(str); }); m2.init(function (str) { m1.update(str); }); // m1.js me.m1input = this.value; inputcb(me.m1input); // inputcb是回调函数 // m2.js me.m2input = this.value; inputcb(me.m2input); 查看完整代码和demo。内聚其实关于内聚也分为很多种，如下所示，如果你感兴趣可以自己研究研究，我们下次再来分享内聚的问题。偶然内聚逻辑内聚时间内聚通信内聚顺序内聚功能内聚总结希望你看完上面的文章，搞懂了耦合的种类，也希望你以后能使用非直接耦合这种方式来写代码，祝好。]]></content>
      <categories>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鸡汤]]></title>
    <url>%2Farchives%2F201.html</url>
    <content type="text"><![CDATA[这是篇有密码的博客 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 技术栈]]></title>
    <url>%2Farchives%2F4a9b.html</url>
    <content type="text"><![CDATA[React 技术栈React 是目前最热门的前端框架。Facebook 公司2013年推出现在最好的社区支持和生态圈大量的第三方工具React 的优点组件模式：代码复用和团队分工虚拟 DOM：性能优势移动端支持：跨终端React 的缺点学习曲线较陡峭全新的一套概念，与其他所有框架截然不同只有采用它的整个技术栈，才能发挥最大威力总结：React 非常先进和强大，但是学习和实现成本都不低JSX 语法React 使用 JSX 语法，JavaScript 代码中可以写 HTML 代码。1let myTitle = &lt;h1&gt;Hello, world!&lt;/h1&gt;;JSX 语法解释（1）JSX 语法的最外层，只能有一个节点。12// 错误let myTitle = &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;;（2）JSX 语法中可以插入 JavaScript 代码，使用大括号。1let myTitle = &lt;p&gt;&#123;'Hello ' + 'World'&#125;&lt;/p&gt;Babel 转码器JavaScript 引擎（包括浏览器和 Node）都不认识 JSX，需要首先使用 Babel 转码，然后才能运行。123456&lt;script src="react.js"&gt;&lt;/script&gt;&lt;script src="react-dom.js"&gt;&lt;/script&gt;&lt;script src="babel.min.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt; // ** Our code goes here! **&lt;/script&gt;React 需要加载两个库：React 和 React-DOM，前者是 React 的核心库，后者是 React 的 DOM 适配库。Babel 用来在浏览器转换 JSX 语法，如果服务器已经转好了，浏览器就不需要加载这个库。课堂练习：JSX 语法浏览器打开demos/jsx-demo/index.html，按照《操作说明》，完成练习。1234ReactDOM.render( &lt;span&gt;Hello World!&lt;/span&gt;, document.getElementById('example'));示例：React 组件React 允许用户定义自己的组件，插入网页。浏览器打开demos/react-component-demo/index1.html，按照《操作说明》，仔细查看源码。12345678910class MyTitle extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello World&lt;/h1&gt;; &#125;&#125;;ReactDOM.render( &lt;MyTitle/&gt;, document.getElementById('example'));课堂练习：组件的参数组件可以从外部传入参数，内部使用this.props获取参数。打开demos/react-component-demo/index2.html，按照《操作说明》，完成练习。123456789class MyTitle extends React.Component &#123; render() &#123; return &lt;h1 style=&#123;&#123;color: this.props.color&#125;&#125; &gt;Hello World&lt;/h1&gt;; &#125;&#125;;&lt;MyTitle color="red" /&gt;,示例：组件的状态组件往往会有内部状态，使用this.state表示。浏览器打开demos/react-component-demo/index3.html，按照《操作说明》，仔细查看源码。课堂练习：React 组件实战浏览器打开demos/react-component-demo/index4.html，按照《操作说明》，完成练习。组件的生命周期React 为组件的不同生命阶段，提供了近十个钩子方法。componentWillMount()：组件加载前调用componentDidMount()：组件加载后调用componentWillUpdate(): 组件更新前调用componentDidUpdate(): 组件更新后调用componentWillUnmount()：组件卸载前调用componentWillReceiveProps()：组件接受新的参数时调用我们可以利用这些钩子，自动完成一些操作。课堂练习：组件的生命周期组件可以通过 Ajax 请求，从服务器获取数据。Ajax 请求一般在componentDidMount方法里面发出。123456componentDidMount() &#123; const url = '...'; $.getJSON(url) .done() .fail();&#125;打开demos/react-lifecycle-demo/index.html，按照《操作说明》，完成练习。React 组件库React 的一大优势，就是网上有很多已经写好的组件库，可以使用。React-Bootstrap：https://react-bootstrap.github.io/示例：ReChartsReCharts 是一个 React 图表组件库。http://recharts.org/浏览器打开demos/recharts-demo/index.html，按照《操作说明》，仔细查看源码，体会 JSX 语法对表达复杂组件的优势。1234567&lt;LineChart width=&#123;1000&#125; height=&#123;400&#125; data=&#123;data&#125;&gt; &lt;XAxis dataKey="name"/&gt; &lt;YAxis/&gt; &lt;CartesianGrid stroke="#eee" strokeDasharray="5 5"/&gt; &lt;Line type="monotone" dataKey="uv" stroke="#8884d8" /&gt; &lt;Line type="monotone" dataKey="pv" stroke="#82ca9d" /&gt;&lt;/LineChart&gt;React 的核心思想View 是 State 的输出。1view = f(state)上式中，f表示函数关系。只要 State 发生变化，View 也要随之变化。React 的本质是将图形界面（GUI）函数化。12345678const person = &#123; name: "michel", age: 31&#125;const App = (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body)React 没有解决的问题React 本身只是一个 DOM 的抽象层，使用组件构建虚拟 DOM。如果开发大应用，还需要解决两个问题。架构：大型应用程序应该如何组织代码？通信：组件之间如何通信？架构问题React 只是视图层的解决方案，可以用于任何一种架构。MVCMVVMObserverReactive…到底哪一种架构最合适 React ？通信问题组件会发生三种通信。向子组件发消息向父组件发消息向其他组件发消息React 只提供了一种通信手段：传参。对于大应用，很不方便。状态的同步通信的本质是状态的同步。React 同步状态的基本方法：找到通信双方最近的共同父组件，通过它的state，使得子组件的状态保持同步。Flux 架构Facebook 提出 Flux 架构的概念，被认为是 React 应用的标准架构。最大特点：数据单向流动。与 MVVM 的数据双向绑定，形成鲜明对比。Flux 的核心思想不同组件的state，存放在一个外部的、公共的 Store 上面。组件订阅 Store 的不同部分。组件发送（dispatch）动作（action），引发 Store 的更新。Flux 只是一个概念，有30多种实现。目前最流行的两个 React 架构React 架构的最重要作用：管理 Store 与 View 之间的关系。MobX：响应式（Reactive）管理，state 是可变对象，适合中小型项目Redux：函数式（Functional）管理，state 是不可变对象，适合大型项目MobX 架构MobX 的核心是观察者模式。Store 是被观察者（observable）组件是观察者（observer）一旦Store有变化，会立刻被组件观察到，从而引发重新渲染。MobX 的最简单例子1234567891011const &#123;observable&#125; = mobx;const &#123;observer&#125; = mobxReact;const person = observable(&#123;name: "张三", age: 31&#125;);const App = observer( (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;);ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body);person.name = "李四";代码：demos/mobx-demo/browser-demo目录示例：MobX进入demos/mobx-demo目录，按照《操作说明》，理解 MobX 框架。UI 层是观察者，Store 是被观察者。Store 所有的属性，分成两大类：直接被观察的属性和自动计算出来的属性。123456class Store &#123; @observable name = 'Bartek'; @computed get decorated() &#123; return `$&#123;this.name&#125; is awesome!`; &#125;&#125;UI 会观察到 Store 的变化，自动重新渲染。Redux 架构Redux 的核心概念所有的状态存放在Store。组件每次重新渲染，都必须由状态变化引起。用户在 UI 上发出action。reducer函数接收action，然后根据当前的state，计算出新的state。Redux 应用的架构Redux 层保存所有状态，React 组件拿到状态以后，渲染出 HTML 代码。示例：Redux进入demos/redux-demo目录，按照《操作说明》，理解 Redux 框架。Redux 将组件分成 UI 组件和容器组件两类。UI 组件是纯组件，不包含 state 和生命周期方法，不涉及组件的行为，只涉及组件的外观。1234567&lt;div className="index"&gt; &lt;p&gt;&#123;this.props.text&#125;&lt;/p&gt; &lt;input defaultValue=&#123;this.props.name&#125; onChange=&#123;this.props.onChange&#125; /&gt;&lt;/div&gt;容器组件正好相反。不涉及组件的外观，只涉及组件的行为。负责订阅 Store，将 Store 的数据处理以后，再通过参数传给 UI 组件。用户给出配置以后，由 Redux 生成。12345// MyComponent 是纯的 UI 组件const App = connect( mapStateToProps, mapDispatchToProps)(MyComponent);mapStateToProps: 定义 UI 组件参数与 State 之间的映射mapDispatchToProps：定义 UI 组件与 Action 之间的映射拆分 UI 组件和容器组件的好处UI 组件与后台数据无关，可以由设计师负责容器组件只负责数据和行为，一旦 Store 的数据结构变化，只要调整容器组件即可表现层和功能层脱钩，有利于代码重用，也有利于看清应用的数据结构和业务逻辑Reducer 函数reducer是一个纯函数，用来接收action，算出新的state。123456789101112function reducer(state = &#123; text: '你好，访问者', name: '访问者'&#125;, action) &#123; switch (action.type) &#123; case 'change': return &#123; name: action.payload, text: '你好，' + action.payload &#125;; &#125;&#125;Store由 Redux 提供的createStore方法生成，该方法接受reducer作为参数。为了把Store传入组件，必须使用 Redux 提供的Provider组件在应用的最外面，包裹一层。12345678const store = createStore(reducer);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.body.appendChild(document.createElement('div')));]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 设计思想]]></title>
    <url>%2Farchives%2F7615.html</url>
    <content type="text"><![CDATA[React 设计思想译者序：本文是 React 核心开发者、有 React API 终结者之称的 Sebastian Markbåge 撰写，阐述了他设计 React 的初衷。阅读此文，你能站在更高的高度思考 React 的过去、现在和未来。原文地址：https://github.com/reactjs/react-basic我写此文是想正式地阐述我心中 React 的心智模型。目的是解释为什么我们会这样设计 React，同时你也可以根据这些论点反推出 React。不可否认，此文中的部分论据或前提尚存争议，而且部分示例的设计可能存在 bug 或疏忽。这只是正式确定它的最初阶段。如果你有更好的完善它的想法可以随时提交 pull request。本文不会介绍框架细节中的奇技淫巧，相信这样能提纲挈领，让你看清 React 由简单到复杂的设计过程。React.js 的真实实现中充满了具体问题的解决方案，渐进式的解法，算法优化，历史遗留代码，debug 工具以及其他一些可以让它真的具有高可用性的内容。这些代码可能并不稳定，因为未来浏览器的变化和功能权重的变化随时面临改变。所以具体的代码很难彻底解释清楚。我偏向于选择一种我能完全 hold 住的简洁的心智模型来作介绍。变换（Transformation）设计 React 的核心前提是认为 UI 只是把数据通过映射关系变换成另一种形式的数据。同样的输入必会有同样的输出。这恰好就是纯函数。123function NameBox(name) &#123; return &#123; fontWeight: 'bold', labelContent: name &#125;;&#125;12&apos;Sebastian Markbåge&apos; -&gt;&#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125;;抽象（Abstraction）你不可能仅用一个函数就能实现复杂的 UI。重要的是，你需要把 UI 抽象成多个隐藏内部细节，又可复用的函数。通过在一个函数中调用另一个函数来实现复杂的 UI，这就是抽象。123456789function FancyUserBox(user) &#123; return &#123; borderStyle: '1px solid blue', childContent: [ 'Name: ', NameBox(user.firstName + ' ' + user.lastName) ] &#125;;&#125;12345678&#123; firstName: &apos;Sebastian&apos;, lastName: &apos;Markbåge&apos; &#125; -&gt;&#123; borderStyle: &apos;1px solid blue&apos;, childContent: [ &apos;Name: &apos;, &#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125; ]&#125;;组合（Composition）为了真正达到重用的特性，只重用叶子然后每次都为他们创建一个新的容器是不够的。你还需要可以包含其他抽象的容器再次进行组合。我理解的“组合”就是将两个或者多个不同的抽象合并为一个。12345678910111213function FancyBox(children) &#123; return &#123; borderStyle: '1px solid blue', children: children &#125;;&#125;function UserBox(user) &#123; return FancyBox([ 'Name: ', NameBox(user.firstName + ' ' + user.lastName) ]);&#125;状态（State）UI 不单单是对服务器端或业务逻辑状态的复制。实际上还有很多状态是针对具体的渲染目标。举个例子，在一个 text field 中打字。它不一定要复制到其他页面或者你的手机设备。滚动位置这个状态是一个典型的你几乎不会复制到多个渲染目标的。我们倾向于使用不可变的数据模型。我们把可以改变 state 的函数串联起来作为原点放置在顶层。1234567891011121314151617181920212223function FancyNameBox(user, likes, onClick) &#123; return FancyBox([ 'Name: ', NameBox(user.firstName + ' ' + user.lastName), 'Likes: ', LikeBox(likes), LikeButton(onClick) ]);&#125;// 实现细节var likes = 0;function addOneMoreLike() &#123; likes++; rerender();&#125;// 初始化FancyNameBox( &#123; firstName: 'Sebastian', lastName: 'Markbåge' &#125;, likes, addOneMoreLike);注意：本例更新状态时会带来副作用（addOneMoreLike 函数中）。我实际的想法是当一个“update”传入时我们返回下一个版本的状态，但那样会比较复杂。此示例待更新Memoization对于纯函数，使用相同的参数一次次调用未免太浪费资源。我们可以创建一个函数的 memorized 版本，用来追踪最后一个参数和结果。这样如果我们继续使用同样的值，就不需要反复执行它了。1234567891011121314151617181920212223function memoize(fn) &#123; var cachedArg; var cachedResult; return function(arg) &#123; if (cachedArg === arg) &#123; return cachedResult; &#125; cachedArg = arg; cachedResult = fn(arg); return cachedResult; &#125;;&#125;var MemoizedNameBox = memoize(NameBox);function NameAndAgeBox(user, currentTime) &#123; return FancyBox([ 'Name: ', MemoizedNameBox(user.firstName + ' ' + user.lastName), 'Age in milliseconds: ', currentTime - user.dateOfBirth ]);&#125;列表（Lists）大部分 UI 都是展示列表数据中不同 item 的列表结构。这是一个天然的层级。为了管理列表中的每一个 item 的 state ，我们可以创造一个 Map 容纳具体 item 的 state。123456789101112131415function UserList(users, likesPerUser, updateUserLikes) &#123; return users.map(user =&gt; FancyNameBox( user, likesPerUser.get(user.id), () =&gt; updateUserLikes(user.id, likesPerUser.get(user.id) + 1) ));&#125;var likesPerUser = new Map();function updateUserLikes(id, likeCount) &#123; likesPerUser.set(id, likeCount); rerender();&#125;UserList(data.users, likesPerUser, updateUserLikes);注意：现在我们向 FancyNameBox 传了多个不同的参数。这打破了我们的 memoization 因为我们每次只能存储一个值。更多相关内容在下面。连续性（Continuations）不幸的是，自从 UI 中有太多的列表，明确的管理就需要大量的重复性样板代码。我们可以通过推迟一些函数的执行，进而把一些模板移出业务逻辑。比如，使用“柯里化”（JavaScript 中的 bind）。然后我们可以从核心的函数外面传递 state，这样就没有样板代码了。下面这样并没有减少样板代码，但至少把它从关键业务逻辑中剥离。123456789101112function FancyUserList(users) &#123; return FancyBox( UserList.bind(null, users) );&#125;const box = FancyUserList(data.users);const resolvedChildren = box.children(likesPerUser, updateUserLikes);const resolvedBox = &#123; ...box, children: resolvedChildren&#125;;State Map之前我们知道可以使用组合避免重复执行相同的东西这样一种重复模式。我们可以把执行和传递 state 逻辑挪动到被复用很多的低层级的函数中去。12345678910111213141516171819202122232425262728function FancyBoxWithState( children, stateMap, updateState) &#123; return FancyBox( children.map(child =&gt; child.continuation( stateMap.get(child.key), updateState )) );&#125;function UserList(users) &#123; return users.map(user =&gt; &#123; continuation: FancyNameBox.bind(null, user), key: user.id &#125;);&#125;function FancyUserList(users) &#123; return FancyBoxWithState.bind(null, UserList(users) );&#125;const continuation = FancyUserList(data.users);continuation(likesPerUser, updateUserLikes);Memoization Map一旦我们想在一个 memoization 列表中 memoize 多个 item 就会变得很困难。因为你需要制定复杂的缓存算法来平衡调用频率和内存占有率。还好 UI 在同一个位置会相对的稳定。相同的位置一般每次都会接受相同的参数。这样以来，使用一个集合来做 memoization 是一个非常好用的策略。我们可以用对待 state 同样的方式，在组合的函数中传递一个 memoization 缓存。12345678910111213141516171819202122232425262728function memoize(fn) &#123; return function(arg, memoizationCache) &#123; if (memoizationCache.arg === arg) &#123; return memoizationCache.result; &#125; const result = fn(arg); memoizationCache.arg = arg; memoizationCache.result = result; return result; &#125;;&#125;function FancyBoxWithState( children, stateMap, updateState, memoizationCache) &#123; return FancyBox( children.map(child =&gt; child.continuation( stateMap.get(child.key), updateState, memoizationCache.get(child.key) )) );&#125;const MemoizedFancyNameBox = memoize(FancyNameBox);代数效应（Algebraic Effects）多层抽象需要共享琐碎数据时，一层层传递数据非常麻烦。如果能有一种方式可以在多层抽象中快捷地传递数据，同时又不需要牵涉到中间层级，那该有多好。React 中我们把它叫做“context”。有时候数据依赖并不是严格按照抽象树自上而下进行。举个例子，在布局算法中，你需要在实现他们的位置之前了解子节点的大小。现在，这个例子有一点超纲。我会使用 代数效应 这个由我发起的 ECMAScript 新特性提议。如果你对函数式编程很熟悉，它们 在避免由 monad 强制引入的仪式一样的编码。123456789101112131415161718192021222324function ThemeBorderColorRequest() &#123; &#125;function FancyBox(children) &#123; const color = raise new ThemeBorderColorRequest(); return &#123; borderWidth: '1px', borderColor: color, children: children &#125;;&#125;function BlueTheme(children) &#123; return try &#123; children(); &#125; catch effect ThemeBorderColorRequest -&gt; [, continuation] &#123; continuation('blue'); &#125;&#125;function App(data) &#123; return BlueTheme( FancyUserList.bind(null, data.users) );&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React中的state和props]]></title>
    <url>%2Farchives%2F992.html</url>
    <content type="text"><![CDATA[整理一下React中关于state和props的知识点。在任何应用中，数据都是必不可少的。我们需要直接的改变页面上一块的区域来使得视图的刷新，或者间接地改变其他地方的数据。React的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在props和state中，这两个属性有啥子区别呢？propsReact的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件。组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是props，所以可以把props理解为从外部传入组件内部的数据。由于React是单向数据流，所以props基本上也就是从服父级组件向子组件传递的数据。用法假设我们现在需要实现一个列表，根据React组件化思想，我们可以把列表中的行当做一个组件，也就是有这样两个组件：&lt;ItemList/&gt;和&lt;Item/&gt;。先看看&lt;ItemList/&gt;123456789import Item from &quot;./item&quot;;export default class ItemList extends React.Component&#123; const itemList = data.map(item =&gt; &lt;Item item=item /&gt;); render()&#123; return ( &#123;itemList&#125; ) &#125;&#125;列表的数据我们就暂时先假设是放在一个data变量中，然后通过map函数返回一个每一项都是&lt;Item item=&#39;数据&#39;/&gt;的数组，也就是说这里其实包含了data.length个&lt;Item/&gt;组件，数据通过在组件上自定义一个参数传递。当然，这里想传递几个自定义参数都可以。在&lt;Item /&gt;中是这样的：1234567export default class Item extends React.Component&#123; render()&#123; return ( &lt;li&gt;&#123;this.props.item&#125;&lt;/li&gt; ) &#125;&#125;在render函数中可以看出，组件内部是使用this.props来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个item属性，所以通过this.props.item来获取即可。只读性props经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的props是只读的，不可改变的。如果props在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的props传入组件中。默认参数在组件中，我们最好为props中的参数设置一个defaultProps，并且制定它的类型。比如，这样：1234567Item.defaultProps = &#123; item: &apos;Hello Props&apos;,&#125;;Item.propTypes = &#123; item: PropTypes.string,&#125;;关于propTypes，可以声明为以下几种类型：1234567optionalArray: PropTypes.array,optionalBool: PropTypes.bool,optionalFunc: PropTypes.func,optionalNumber: PropTypes.number,optionalObject: PropTypes.object,optionalString: PropTypes.string,optionalSymbol: PropTypes.symbol,注意，bool和func是简写。这些知识基础数据类型，还有一些复杂的，附上链接：https://facebook.github.io/react/docs/typechecking-with-proptypes.html总结props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。statestate是什么呢？State is similar to props, but it is private and fully controlled by the component.一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是props，而数据状态就是state。用法12345678910111213export default class ItemList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; itemList:&apos;一些数据&apos;, &#125; &#125; render()&#123; return ( &#123;this.state.itemList&#125; ) &#125;&#125;首先，在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。setStatestate不同于props的一点是，state是可以被改变的。不过，不可以直接通过this.state=的方式来修改，而需要通过this.setState()方法来修改state。比如，我们经常会通过异步操作来获取数据，我们需要在didMount阶段来执行异步操作：1234567componentDidMount()&#123; fetch(&apos;url&apos;) .then(response =&gt; response.json()) .then((data) =&gt; &#123; this.setState(&#123;itemList:item&#125;); &#125;&#125;当数据获取完成后，通过this.setState来修改数据状态。当我们调用this.setState方法时，React会更新组件的数据状态state，并且重新调用render方法，也就是会对组件进行重新渲染。注意：通过this.state=来初始化state，使用this.setState来修改state，constructor是唯一能够初始化的地方。setState接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：123456789101112export default class ItemList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name:&apos;axuebin&apos;, age:25, &#125; &#125; componentDidMount()&#123; this.setState(&#123;age:18&#125;) &#125;&#125;在执行完setState之后的state应该是{name:&#39;axuebin&#39;,age:18}。setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：123this.setState(&#123; name:&apos;xb&apos;&#125;,()=&gt;console.log(&apos;setState finished&apos;))总结state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。区别state是组件自己管理数据，控制自己的状态，可变；props是外部传入的数据参数，不可变；没有state的叫做无状态组件，有state的叫做有状态组件；多用props，少用state。也就是多写无状态组件。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
</search>

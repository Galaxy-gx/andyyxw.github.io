<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>服务器重置密码</title>
      <link href="/archives/fe92.html"/>
      <url>/archives/fe92.html</url>
      <content type="html"><![CDATA[<!-- build time:Mon Oct 15 2018 19:12:00 GMT+0800 (中国标准时间) --><p>有时候会忘记服务器密码，但是可以通过官网面板等方式连上时，可使用下面的命令修改root密码：<br>整段赋值下面的命令（”新密码”处 替换为要修改的密码）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo root:新密码 |sudo chpasswd root</span><br><span class="line">sudo sed -i &apos;s/^.*PermitRootLogin.*/PermitRootLogin yes/g&apos; /etc/ssh/sshd_config;</span><br><span class="line">sudo sed -i &apos;s/^.*PasswordAuthentication.*/PasswordAuthentication yes/g&apos; /etc/ssh/sshd_config;</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>重启后用root账户登录即可。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> Linux </tag>
            
            <tag> 重置密码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解密传统组件间通信与React组件间通信</title>
      <link href="/archives/ac71.html"/>
      <url>/archives/ac71.html</url>
      <content type="html"><![CDATA[<!-- build time:Mon Oct 15 2018 19:12:00 GMT+0800 (中国标准时间) --><p>在React中最小的逻辑单元是组件，组件之间如果有耦合关系就会进行通信，本文将会介绍React中的组件通信的不同方式</p><p>通过归纳范，可以将任意组件间的通信归类为四种类型的组件间通信，分别是父子组件，爷孙组件，兄弟组件和任意组件，<br>需要注意的是前三个也可以算作任意组件的范畴，所以最后一个是万能方法</p><h3 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h3><p>父子组件间的通信分为父组件向子组件通信和子组件向父组件通信两种情况，下面先来介绍父组件向子组件通信，<br>传统做法分为两种情况，分别是初始化时的参数传递和实例阶段的方法调用，例子如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="comment">// 获取dom引用</span></span><br><span class="line">        <span class="keyword">this</span>.$div = <span class="built_in">document</span>.querySelector(<span class="string">'#wp'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化时传入name</span></span><br><span class="line">        <span class="keyword">this</span>.updateName(name);</span><br><span class="line">    &#125;</span><br><span class="line">    updateName(name) &#123;</span><br><span class="line">        <span class="comment">// 对外提供更新的api</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 更新dom</span></span><br><span class="line">        <span class="keyword">this</span>.$div.innerHTML = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化阶段</span></span><br><span class="line">        <span class="keyword">this</span>.child = <span class="keyword">new</span> Child(<span class="string">'yan'</span>);</span><br><span class="line">        </span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化阶段</span></span><br><span class="line">            <span class="keyword">this</span>.child.updateName(<span class="string">'hou'</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在React中将两个情况统一处理，全部通过属性来完成，之所以能够这样是因为React在属性更新时会自动重新渲染子组件，<br>下面的例子中，2秒后子组件会自动重新渲染，并获取新的属性值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化阶段</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">name</span>: <span class="string">'yan'</span>&#125;;</span><br><span class="line"></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化阶段</span></span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>: <span class="string">'hou'</span>&#125;)</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&#123;this.state.name&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>下面来看一下子组件如何向父组件通信，传统做法有两种，一种是回调函数，另一种是为子组件部署消息接口</p><p>先来看回调函数的例子，回调函数的优点是非常简单，缺点就是必须在初始化的时候传入，并且不可撤回，并且只能传入一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(cb) &#123;</span><br><span class="line">        <span class="comment">// 调用父组件传入的回调函数，发送消息</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; cb() &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化阶段，传入回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.child = <span class="keyword">new</span> Child(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'child update'</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看看消息接口方法，首先需要一个可以发布和订阅消息的基类，比如下面实现了一个简单的<code>EventEimtter</code>，实际生产中可以直接使用别人写好的类库，比如<a href="https://github.com/jsmini/event" target="_blank" rel="noopener">@jsmini/event</a>，子组件继承消息基类，就有了发布消息的能力，然后父组件订阅子组件的消息，即可实现子组件向父组件通信的功能</p><p>消息接口的优点就是可以随处订阅，并且可以多次订阅，还可以取消订阅，缺点是略显麻烦，需要引入消息基类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息接口，订阅发布模式，类似绑定事件，触发事件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEimtter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventMap = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sub(name, cb) &#123;</span><br><span class="line">        <span class="keyword">const</span> eventList = <span class="keyword">this</span>.eventMap[name] = <span class="keyword">this</span>.eventMap[name] || &#123;&#125;;</span><br><span class="line">        eventList.push(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    pub(name, ...data) &#123;</span><br><span class="line">        (<span class="keyword">this</span>.eventMap[name] || []).forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(...data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">EventEimtter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// 通过消息接口发布消息</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">this</span>.pub(<span class="string">'update'</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化阶段，传入回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.child = <span class="keyword">new</span> Child();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 订阅子组件的消息</span></span><br><span class="line">        <span class="keyword">this</span>.child.sub(<span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'child update'</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Backbone.js就同时支持回调函数和消息接口方式，但React中选择了比较简单的回调函数模式，下面来看一下React的例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">this</span>.props.cb() &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">cb</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;console.log('update')&#125;&#125; /&gt;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="爷孙组件"><a href="#爷孙组件" class="headerlink" title="爷孙组件"></a>爷孙组件</h3><p>父子组件其实可以算是爷孙组件的一种特例，这里的爷孙组件不光指爷爷和孙子，而是泛指祖先与后代组件通信，可能隔着很多层级，我们已经解决了父子组件通信的问题，根据化归法，很容易得出爷孙组件的答案，那就是层层传递属性么，把爷孙组件通信分解为多个父子组件通信的问题</p><p>层层传递的优点是非常简单，用已有知识就能解决，问题是会浪费很多代码，非常繁琐，中间作为桥梁的组件会引入很多不属于自己的属性</p><p>在React中，通过context可以让祖先组件直接把属性传递到后代组件，有点类似星际旅行中的虫洞一样，通过context这个特殊的桥梁，可以跨越任意层次向后代组件传递消息</p><p>怎么在需要通信的组件之间开启这个虫洞呢？需要双向声明，也就是在祖先组件声明属性，并在后代组件上再次声明属性，然后在祖先组件上放上属性就可以了，就可以在后代组件读取属性了，下面看一个例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 后代组件声明需要读取context上的数据</span></span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">        text: PropTypes.string</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">// 通过this.context 读取context上的数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.context.text&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ancestor</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 祖先组件声明需要放入context上的数据</span></span><br><span class="line">    <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">        text: PropTypes.string</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 祖先组件往context放入数据</span></span><br><span class="line">    getChildContext() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">text</span>: <span class="string">'yanhaijing'</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>context的优点是可以省去层层传递的麻烦，并且通过双向声明控制了数据的可见性，对于层数很多时，不失为一种方案；但缺点也很明显，就像全局变量一样，如果不加节制很容易造成混乱，而且也容易出现重名覆盖的问题</p><p>个人的建议是对一些所有组件共享的只读信息可以采用context来传递，比如登录的用户信息等</p><p><em>小贴士：React Router路由就是通过context来传递路由属性的</em></p><h3 id="兄弟组件"><a href="#兄弟组件" class="headerlink" title="兄弟组件"></a>兄弟组件</h3><p>如果两个组件是兄弟关系，可以通过父组件作为桥梁，来让两个组件之间通信，这其实就是主模块模式</p><p>下面的例子中，两个子组件通过父组件来实现显示数字同步的功能</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.onChange = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;num&#125;)</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Child1 num=&#123;<span class="keyword">this</span>.state.num&#125; onChange=&#123;<span class="keyword">this</span>.onChange&#125;&gt;</span><br><span class="line">                &lt;Child2 num=&#123;<span class="keyword">this</span>.state.num&#125; onChange=&#123;<span class="keyword">this</span>.onChange&#125;&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>主模块模式的优点就是解耦，把两个子组件之间的耦合关系，解耦成子组件和父组件之间的耦合，把分散的东西收集在一起好处非常明显，能带来更好的可维护性和可扩展性</p><h3 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h3><p>任意组件包括上面的三种关系组件，上面三种关系应该优先使用上面介绍的方法，对于任意的两个组件间通信，总共有三种办法，分别是共同祖先法，消息中间件和状态管理</p><p>基于我们上面介绍的爷孙组件和兄弟组件，只要找到两个组件的共同祖先，就可以将任意组件之间的通信，转化为任意组件和共同祖先之间的通信，这个方法的好处就是非常简单，已知知识就能搞定，缺点就是上面两种模式缺点的叠加，除了临时方案，不建议使用这种方法</p><p>另一种比较常用的方法是消息中间件，就是引入一个全局消息工具，两个组件通过这个全局工具进行通信，这样两个组件间的通信，就通过全局消息媒介完成了</p><p>还记得上面介绍的消息基类吗？下面的例子中，组件1和组件2通过全局event进行通信</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEimtter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventMap = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sub(name, cb) &#123;</span><br><span class="line">        <span class="keyword">const</span> eventList = <span class="keyword">this</span>.eventMap[name] = <span class="keyword">this</span>.eventMap[name] || &#123;&#125;;</span><br><span class="line">        eventList.push(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    pub(name, ...data) &#123;</span><br><span class="line">        (<span class="keyword">this</span>.eventMap[name] || []).forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(...data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局消息工具</span></span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> EventEimtter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element1</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 订阅消息</span></span><br><span class="line">        event.sub(<span class="string">'element2update'</span>, () =&gt; &#123;<span class="built_in">console</span>.log(<span class="string">'element2 update'</span>)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个组件。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element2</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; event.pub(<span class="string">'element2update'</span>) &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息中间件的模式非常简单，利用了观察者模式，将两个组件之间的耦合解耦成了组件和消息中心+消息名称的耦合，但为了解耦却引入全局消息中心和消息名称，消息中心对组件的侵入性很强，和第三方组件通信不能使用这种方式</p><p>小型项目比较适合使用这种方式，但随着项目规模的扩大，达到中等项目以后，消息名字爆炸式增长，消息名字的维护成了棘手的问题，重名概率极大，没有人敢随便删除消息信息，消息的发布者找不到消息订阅者的信息等</p><p>其实上面的问题也不是没有解决办法，重名的问题可以通过制定规范，消息命名空间等方式来极大降低冲突，其他问题可以通过把消息名字统一维护到一个文件，通过对消息的中心化管理，可以让很多问题都很容易解决</p><p>如果你的项目非常大，上面两种方案都不合适，那你可能需要一个状态管理工具，通过状态管理工具把组件之间的关系，和关系的处理逻辑从组建中抽象出来，并集中化到统一的地方来处理，Redux就是一个非常不错的状态管理工具</p><p>除了Redux，还有Mobx，Rematch，reselect等工具，本文不展开介绍，有机会后面单独成文，这些都是用来解决不同问题的，只要根据自己的场景选择合适的工具就好了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>组件间的关系千变万化，都可以用上面介绍的方法解决，对于不同规模的项目，应该选择适合自己的技术方案，上面介绍的不同方式解耦的程度是不一样的，关于不同耦合关系的好坏，可以看我之前的文章《<a href="https://andyxw.com/archives/7e29.html" target="_blank" rel="noopener">图解7种耦合关系</a>》</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图解7种耦合关系</title>
      <link href="/archives/7e29.html"/>
      <url>/archives/7e29.html</url>
      <content type="html"><![CDATA[<!-- build time:Mon Oct 15 2018 19:12:00 GMT+0800 (中国标准时间) --><p>深入讲讲模块之间的耦合关系这个事情。</p><p>本文将用图文详细讲解七种耦合的不同之处。</p><h2 id="高内聚与低耦合"><a href="#高内聚与低耦合" class="headerlink" title="高内聚与低耦合"></a>高内聚与低耦合</h2><p>高内聚与低耦合是每个软件开发者追求的目标，那么内聚和耦合分别是什么意思呢？</p><p><img src="!--￼0--&gt;416.png" alt=""></p><blockquote><p>内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</p></blockquote><blockquote><p>耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</p></blockquote><h2 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h2><p>不同模块之间的关系就是耦合，根据耦合程度可以分为7种，耦合度依次变低。</p><ul><li>内容耦合</li><li>公共耦合</li><li>外部耦合</li><li>控制耦合</li><li>标记耦合</li><li>数据耦合</li><li>非直接耦合</li></ul><p>下面我们来说说每种耦合是什么，开始之前先来说下要实现的功能。m1和m2是两个独立的模块，其中m2种会显示m1的输入，m1会显示m2的输入。</p><p><img src="!--￼1--&gt;417.png" alt=""></p><p>很显然，m1和m2两个模块之间会有一些联系（耦合），你也可以想想如何实现这个功能，下面用7种不同的方式来实现这个功能。</p><p><strong>注：</strong>项目的代码我放到了<a href="https://github.com/yanhaijing/coupling" target="_blank" rel="noopener">github</a>，项目的demo，可以在<a href="http://yanhaijing.com/coupling/" target="_blank" rel="noopener">这里查看</a>。</p><h3 id="内容耦合"><a href="#内容耦合" class="headerlink" title="内容耦合"></a>内容耦合</h3><p>内容耦合是最紧的耦合程度，一个模块直接访问另一模块的内容，则称这两个模块为内容耦合。</p><p><img src="!--￼2--&gt;418.png" alt=""></p><p>为了实现功能，我们将m1的输入放到m2.m1input上，将m2的输入放到m1.m2input上。</p><pre><code>// m1.jsroot.m2.m1input = this.value;m2.update();// m2.jsroot.m1.m2input = this.value;m1.update();</code></pre><p><strong>PS:</strong>不知道谁会这么写代码，除了我为了做演示之外。。。</p><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo1" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo1/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="公共耦合"><a href="#公共耦合" class="headerlink" title="公共耦合"></a>公共耦合</h3><p>一组模块都访问同一个全局数据结构，则称之为公共耦合。</p><p><img src="!--￼3--&gt;419.png" alt=""></p><p>在这种case中，m1和m2将自己的输入放到全局的data上。</p><pre><code>// m1.jsroot.data.m1input = this.value;m2.update();// m2.jsroot.data.m2input = this.value;m1.update();</code></pre><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo2" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo2/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="外部耦合"><a href="#外部耦合" class="headerlink" title="外部耦合"></a>外部耦合</h3><p>一组模块都访问同一全局简单变量，而且不通过参数表传递该全局变量的信息，则称之为外部耦合。外部耦合和公共耦合很像，区别就是一个是简单变量，一个是复杂数据结构。</p><p><img src="!--￼4--&gt;420.png" alt=""></p><p>在这种case中，m1和m2都将自己的输入放到全局上。</p><pre><code>// m1.jsroot.m1input = this.value;m2.update();// m2.jsroot.m2input = this.value;m1.update();</code></pre><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo3" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo3/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="控制耦合"><a href="#控制耦合" class="headerlink" title="控制耦合"></a>控制耦合</h3><p>模块之间传递的不是数据信息，而是控制信息例如标志、开关量等，一个模块控制了另一个模块的功能。</p><p>从控制耦合开始，模块的数据就放在自己内部了，不同模块之间通过接口互相调用。</p><p><img src="!--￼5--&gt;421.png" alt=""></p><p>在这个case中，得增加一个需求，就是当m1的输入为空时，隐藏m2的显示信息。</p><pre><code>// m1.jsroot.m1input = this.value;m2.update();m2.toggle(!!this.value); // 传递flag</code></pre><p>上面的代码中m1直接控制了m2的显示和隐藏。</p><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo4" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo4/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="标记耦合"><a href="#标记耦合" class="headerlink" title="标记耦合"></a>标记耦合</h3><p>调用模块和被调用模块之间传递数据结构而不是简单数据，同时也称作特征耦合。</p><p><img src="!--￼6--&gt;422.png" alt=""></p><p>在这个case中，m1传给m2的是一个对象。</p><pre><code>// m1.jsme.m1input = this.value;m2.update(me); // 传递引用// m2.jsme.m2input = this.value;m1.update(me);</code></pre><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo5" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo5/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="数据耦合"><a href="#数据耦合" class="headerlink" title="数据耦合"></a>数据耦合</h3><p>调用模块和被调用模块之间只传递简单的数据项参数。相当于高级语言中的值传递。</p><p><img src="!--￼7--&gt;423.png" alt=""></p><p>在这个case中，m1传给m2的是一个简单数据结构。</p><pre><code>// m1.jsme.m1input = this.value;m2.update(me.m1input); // 传递值// m2.jsme.m2input = this.value;m1.update(me.m2input);</code></pre><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo6" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo6/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="非直接耦合"><a href="#非直接耦合" class="headerlink" title="非直接耦合"></a>非直接耦合</h3><p>两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。耦合度最弱，模块独立性最强。</p><p>子模块无需知道对方的存在，子模块之间的联系，全部变成子模块和主模块之间的联系。</p><p><img src="!--￼8--&gt;424.png" alt=""></p><p>在这个case种，增加一个index.js作为主模块。</p><pre><code>// index.jsvar m1 = root.m1;var m2 = root.m2;m1.init(function (str) {    m2.update(str);});m2.init(function (str) {    m1.update(str);});// m1.jsme.m1input = this.value;inputcb(me.m1input); // inputcb是回调函数// m2.jsme.m2input = this.value;inputcb(me.m2input);</code></pre><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo7" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo7/demo.html" target="_blank" rel="noopener">demo</a>。</p><h2 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h2><p>其实关于内聚也分为很多种，如下所示，如果你感兴趣可以自己研究研究，我们下次再来分享内聚的问题。</p><ul><li>偶然内聚</li><li>逻辑内聚</li><li>时间内聚</li><li>通信内聚</li><li>顺序内聚</li><li>功能内聚</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望你看完上面的文章，搞懂了耦合的种类，也希望你以后能使用非直接耦合这种方式来写代码，祝好。</p><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> 模块化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>鸡汤</title>
      <link href="/archives/201.html"/>
      <url>/archives/201.html</url>
      <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="这是篇有密码的博客" />    <label for="pass">这是篇有密码的博客</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19LiTINpHEJBD61lvQgUwMTtOu5S2QQNwn/gYknK448rhoAVzD/ZWTcdWmFiVLhZLd583jXwlSvclUYH46CYsVmzWjZUT4QrUWDJh9WPfhn5qWvqnGQTQKTWCjoYArtYM5FNh8S7cdRNSD9wCZkSCxjn81GFirfynWsJQ9Hxx9vjArzAa9fTOH0pXZ6WLRUzzeEMNMDOOnsNrn/d09JISwUCsMSkIysJCzzmjgWdsqkkp2nMHEd9GclVU86mT4FTnbexmsKokjp7FQkNmcqoA7tlZb1Fa8PiP90X+kRFcodlWSD78Q1ZmpFIRwibgwglMgZojm0fCLjcL3bw3wVoyRuCm8n7xCHb4TpzLcyh3EDhvQx6Ob+GUvp20WuImNwp/kiPR1zBYI3rmW0teyTWJH7qRPbWxOzIYu0Ihk2qpkvz7woyyVCKDd8Lznx6gMBFu3XGTiTqwuBLYe7TQ4HMvLXGlqSMBeQyvMXkhQxGm6p1bt2VKm6KQB3SdUJNjKSLq1GL4C5GnnxLz9tTfYLcOUY7NdSksanTjpazJBay6VBn3P/Jmy3i5wxN4ZCCIAX/YJpxISorDAGojFae44sxiEuWkbZgH4lOgEzG6BbA7//Nv/WdtlFeowmKz74Qmi2oP4ilVvGU0XvDO2VuoFQF/AIW3x+lA+a5l4bXasQ6Y0piXf37eAR6LSD41X8caJ3Aiy3/Kkq2VkfnMFGJSNVl8zBaIQ4MHd8bqeB2P9h9sJnSnmatwbmaOq+PhImKz/sYm9kJ4V/bts6fO+mscBwmFJDwUofICMlTou6dUFeD612hfeBs/ltZqX+ZVF0lurjnIgXJrNboELEulqEdvgsu5i3VxTcw0Y1+v2HGq+obDQEPrRjLuzI16ZuHmhId5sg69qgoW9jpprn9q4xzt+DBOhTEueLBKZGLKXvWNsnJR1xHXmgaIBGL6TjBFsEGsiqvzwkA1mbm+xUlRhCnTEcE5FYIsLblO0UfBKLkPuiAbaDBZqDaPmyGtxw8BzofnuqvfMo0QxZSviMK1qdLHVc7AWGHVNXBZFb7htsy+umAdJImlUTZV3+3q59Tjtru7ap185rhSTI2/TELkxDBf0AgsWEpVB2P7IefaBldWkHKZFGTCdDXlnKEGhnwtvUQp0haG7GH1afpntObFTQES7zA2udYZbRTOQxo4cBKzKmkT2mDAYGp2XJBMyTXtmES6nOL01D8Lj20YPdqZMRvr6zxwNf1xGOmtb3SYLeHfhezoiFFIfWzvrEcwJcs+xp83lz3PPjYUNYi4bF9tY6REBr75FJwHa8c5d7aQ+jTMkl/UWOpnXWsraGgPaAa8s8O3tqWu8wD/W+WPRm7QgMrDrRhF4UP/4v1P+GhVBESN5SPe4uGvF2PftDGvmBRronbA22/G5l3l9idA6MxUoqS1XXsPrCuFFWa1eAOe7RjrwYRLz6e2fokLZIH/rgC/LJwtJCVzVlwFGKk1EONnnlmRtE0b7vjPeWm6UWBvEOQP1VmtX18J+/iOGjebYmqUZYYM128WSVp8pujkjHGXggaOsFMQbTUAGMWMLccnfMdq/rOZ/3YSCV0Q2t73NxBNZFrZpkgvTqz6LjkRoRfUDkYm2p13SCJnX5rQa64TJ65dskpCZOWxfclS5WfzznGIj21X1qIjMobEAjNYODFQmxCd/WdsPQkZJaMOo3nxiUXPC/GDo8fklAOiaN2eVNvv11WLgSjcWfar6QiCK1w2lzMX8tQk/ilrmVwr4s9zmmLz9rNuCz8k/ajgDK9Xlq7OgQDnXqiZWy6SSsV9YJJIIpr/kb4La80Ch+RoI3rt3blchacBEZ2KxZUpacacp4MHJvp6o8NUM68sNH7D0jPEpiesI7CYHWfFdaYyKJywkdNJ6Ub8dF9drGnDJtYlfi4kOcRarFx/gr6fp17jy8n6VynL0z+v0BCMuIVzDSKjhifUDO9DfaEmZYwix+abu5r0cZHCNKjLjDF8VmxisTrfvfHT0PduEadHArslmJN+FNf+Z/6WFc5izDc7L0Xvl0/9L3XmZ/9QN+iX886MzfMtxOXtoStLMBkQ37tOe/eUKcpfPrnLttAvrKvOehte4hXC3YLjvNETBM6pvaqx7/+Qi/oa9zmdDFB6Mb7LT0otDukXNc+F2RVTc8uIrRB9VpHFZyyAEcA4vCKTLX+gyigggCw6PRXGfiSYr7UYNVPc3OuDpfYOs3S9HvA8rfLVYFVAF10x7Net1gM3i0HXezoXs1Bn9+KPv3Wv06MDR7oO1kLpHmM9h7aPqWqMoQvAK96bnSXcecIJPJL3jGMUO2f65RNYZ0mIvT4U1OniSrHOmXH2Zprb70ZfXsNf6UwjPcmWIZTQEVJr82DVFoWZD1Qjz6NZASeaviJPKU9aNZ/fb4MF8IdmHzDp69fYLt0QNaZssumoygI0nyr8wAOd0xzoCHgqU0o1DWMjfuzVNEPRj+UGiVPMeluyJPSJxa9FLT8gax3QGO0eVQ8L93tUcYhSXpUCuQKwly6feWh8PCjekbmXdVhD96dwqP6FD2E46m5fStlAgPeouufRUNEbrxM54forOfBkgL8cWWF9dBcW/98vOQrNrwRdgzUeWgEoed9QlCGrwVSuJUcNHEeJ80sSroXNCWleWgEYJ3wkwRh6Xmmz4P35dkuedFV3HMZN9WCMsr2zgxy8P7x4c4sUNdMevCI3/ykZx9/n4XBohI3HpPxlkfS8HgOzOS/R+riaHYmMpmcweCldBLxX0Ek1AQ9vNO9J1lQz4ziGdfebDRAsf8Gzn84pqzliPLEDrrIV38G1JHErvcwwkX5SG8CJ69muA+IAqU9zhpQoALrZ21Y5d1tFPdvx1NJKctrb4jwc6Jq8FGyI9BAd6GrGHvIptPqgazf/LeqzvRLN2qnR9bXUiHY4uuWkhrIvdJsIG6u/eI7TAzraGV/2/0zq/CanwxrXmvll63j1jYPBYNxHo+5woqXmZcpSurTqGgLrfrH4ZNYjGv/dnVMTDPWmvup9908vEesRAXLvwEHLtYkLxGX8GXpCp4QBx+GAxoIBHUr4BsmN264rVkcp+xZqjfx0LELxF9VnfKStLPNuidHNJVZAwHnb1Wv171xViUUbNbcwGFf1JZNkJoDT8OzvfsgiZKW91383QPDlImVilCZ5QRxkbU+KutbqHSqbst6EUlZJgxiRYA6CT+wcrVkunrY7QSuVtt+yf4qvz2x9eqZexXIsoScGd7fX9d9SrzD8t4daBqW0DKvkMQR4AbuG3Qs0Y1Q9LqajEbDptX/XEqbGgkT8YN+lnXZTwDvOH5It1cmVJufsy7ad8kdy56uScAPi6Ji0f8jKzfb2elbILVt8KMaOMHwB+W5WSQHNJhBFL9jy2RvWWut3c0t35L4CIFGSOC4oTl2DVVxV7nNBKyPPT5lT6IB80gkakpnmSCsi5jBWKpWZaEId5gRduXCsxvfWqBsmHUpMb0QNmfrmPShUeJ3cqrAA2O+Xd/mSFoDHf4emL0AXjEh5JOYOz5MxGjUeQOOwv51/CDguTPwMCOCwH24WKU23L00EZx2kW/IhqVanzXLKg4e5WujwaqASpxA7sLkoxtxoyhh+Hr1LrQlHJs07+Ugrfo1tIOoOZTgWagn5peJxk81uCcZg6+w1uCZS223TiwG2vq/n5D5LjiFLXKwmxxf2mKpV1pQqFvM6XZvIiyTNkkJhMLWqwgwwD3XeFjWcWinWcoF3s1OquCBER7fMLByJe2RuZ7sNX89lxKfgi90TO4JmSSX58/x/obDWmIbr8dGCUDOSgY7FvC6lovp9mSzwJuOQqP8zeZs1mqOF00Hc/FtHmKDhlvyG/o7siCbFSL6hXPXtkCyHYtC4rMG0v9oYwXkg8JrwMv+V066kgoqP9oIJPNjFR128f3jw/EjrsMkVN6Q3Yw/Jp/Umvc/mnz/oPqqKJs1E+gMAM6RkMZlRxYZStmsSFzblJLv9xXmNvNQSxwGzZLqC7IGvMtpHy0ki1u77vnXcbrrhgueca822fXj49rwe42dX/W6ixb1sXD4q84Z4syR4x9BcUJocmtA6gIqss8Mg0ElCTw8nUey4y0c2SDbT/mvL7tcst4Z0ZW2L23X310gMb1cdJwQvmjNNi34R3ezb9Lk/vuZ4YBAvjFnm3JBEZ6qXXQvUeFG3OM/kAEpBr0I/w6mPw7T+nSxth+kTtrhALOWj6X16Z6o4K/tzpQ0DBM552z0A/fdumKhve0bUL+8hR5st0mUZDZ9e83/2x//nxBU93y0ZXJOi4FkryLXvn92p9N7pXp6tNMu2iM/xzXj1GyHXn4lDUKaWRle1rABLa5FjtXqUXiXjJcIrl1Csvg6Gh5rYgxDRJ63sviVVY28bx9ul6LZYO5yniixQcT/SxJoTcebrXkOmEpDiNJ0MDMMoaxho1+OBR0GTxVnGa2+kiXS2KgCRsPSuHqFY9GpiPDvoONtQJ9</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React 技术栈</title>
      <link href="/archives/4a9b.html"/>
      <url>/archives/4a9b.html</url>
      <content type="html"><![CDATA[<!-- build time:Mon Oct 15 2018 19:12:00 GMT+0800 (中国标准时间) --><h1 id="React-技术栈"><a href="#React-技术栈" class="headerlink" title="React 技术栈"></a>React 技术栈</h1><p>React 是目前最热门的前端框架。</p><ul><li>Facebook 公司2013年推出</li><li>现在最好的社区支持和生态圈</li><li>大量的第三方工具</li></ul><p><img src="./images/react-logo.png" alt=""></p><hr><h2 id="React-的优点"><a href="#React-的优点" class="headerlink" title="React 的优点"></a>React 的优点</h2><ul><li>组件模式：代码复用和团队分工</li><li>虚拟 DOM：性能优势</li><li>移动端支持：跨终端</li></ul><hr><h2 id="React-的缺点"><a href="#React-的缺点" class="headerlink" title="React 的缺点"></a>React 的缺点</h2><ul><li>学习曲线较陡峭</li><li>全新的一套概念，与其他所有框架截然不同</li><li>只有采用它的整个技术栈，才能发挥最大威力</li></ul><p>总结：React 非常先进和强大，但是学习和实现成本都不低</p><hr><h2 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h2><p>React 使用 JSX 语法，JavaScript 代码中可以写 HTML 代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTitle = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><hr><h2 id="JSX-语法解释"><a href="#JSX-语法解释" class="headerlink" title="JSX 语法解释"></a>JSX 语法解释</h2><p>（1）JSX 语法的最外层，只能有一个节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">let</span> myTitle = &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;;</span><br></pre></td></tr></table></figure><p>（2）JSX 语法中可以插入 JavaScript 代码，使用大括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTitle = &lt;p&gt;&#123;'Hello ' + 'World'&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="Babel-转码器"><a href="#Babel-转码器" class="headerlink" title="Babel 转码器"></a>Babel 转码器</h2><p>JavaScript 引擎（包括浏览器和 Node）都不认识 JSX，需要首先使用 Babel 转码，然后才能运行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"react.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"babel.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// ** Our code goes here! **</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React 需要加载两个库：React 和 React-DOM，前者是 React 的核心库，后者是 React 的 DOM 适配库。</p><p>Babel 用来在浏览器转换 JSX 语法，如果服务器已经转好了，浏览器就不需要加载这个库。</p><hr><h2 id="课堂练习：JSX-语法"><a href="#课堂练习：JSX-语法" class="headerlink" title="课堂练习：JSX 语法"></a>课堂练习：JSX 语法</h2><p>浏览器打开<code>demos/jsx-demo/index.html</code>，按照<a href="../demos/README.md#jsx">《操作说明》</a>，完成练习。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;span&gt;Hello World!<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h2 id="示例：React-组件"><a href="#示例：React-组件" class="headerlink" title="示例：React 组件"></a>示例：React 组件</h2><p>React 允许用户定义自己的组件，插入网页。</p><p>浏览器打开<code>demos/react-component-demo/index1.html</code>，按照<a href="../demos/README.md#react-组件语法">《操作说明》</a>，仔细查看源码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTitle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;MyTitle/&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h2 id="课堂练习：组件的参数"><a href="#课堂练习：组件的参数" class="headerlink" title="课堂练习：组件的参数"></a>课堂练习：组件的参数</h2><p>组件可以从外部传入参数，内部使用<code>this.props</code>获取参数。</p><p>打开<code>demos/react-component-demo/index2.html</code>，按照<a href="../demos/README.md#react-组件的参数">《操作说明》</a>，完成练习。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTitle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span></span></span></span><br><span class="line"><span class="xml">      style=&#123;&#123;color: this.props.color&#125;&#125;</span></span><br><span class="line"><span class="xml">    &gt;Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;MyTitle color=<span class="string">"red"</span> /&gt;,</span><br></pre></td></tr></table></figure><hr><h2 id="示例：组件的状态"><a href="#示例：组件的状态" class="headerlink" title="示例：组件的状态"></a>示例：组件的状态</h2><p>组件往往会有内部状态，使用<code>this.state</code>表示。</p><p>浏览器打开<code>demos/react-component-demo/index3.html</code>，按照<a href="../demos/README.md#react-组件的状态">《操作说明》</a>，仔细查看源码。</p><p><img src="./images/react-component-state.png" alt=""></p><hr><h2 id="课堂练习：React-组件实战"><a href="#课堂练习：React-组件实战" class="headerlink" title="课堂练习：React 组件实战"></a>课堂练习：React 组件实战</h2><p>浏览器打开<code>demos/react-component-demo/index4.html</code>，按照<a href="../demos/README.md#react-组件实战">《操作说明》</a>，完成练习。</p><hr><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>React 为组件的不同生命阶段，提供了近十个钩子方法。</p><ul><li><code>componentWillMount()</code>：组件加载前调用</li><li><code>componentDidMount()</code>：组件加载后调用</li><li><code>componentWillUpdate()</code>: 组件更新前调用</li><li><code>componentDidUpdate()</code>: 组件更新后调用</li><li><code>componentWillUnmount()</code>：组件卸载前调用</li><li><code>componentWillReceiveProps()</code>：组件接受新的参数时调用</li></ul><p>我们可以利用这些钩子，自动完成一些操作。</p><hr><h2 id="课堂练习：组件的生命周期"><a href="#课堂练习：组件的生命周期" class="headerlink" title="课堂练习：组件的生命周期"></a>课堂练习：组件的生命周期</h2><p>组件可以通过 Ajax 请求，从服务器获取数据。Ajax 请求一般在<code>componentDidMount</code>方法里面发出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">'...'</span>;</span><br><span class="line">  $.getJSON(url)</span><br><span class="line">    .done()</span><br><span class="line">    .fail();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开<code>demos/react-lifecycle-demo/index.html</code>，按照<a href="../demos/README.md#react-组件的生命周期">《操作说明》</a>，完成练习。</p><hr><h2 id="React-组件库"><a href="#React-组件库" class="headerlink" title="React 组件库"></a>React 组件库</h2><p>React 的一大优势，就是网上有很多已经写好的组件库，可以使用。</p><p>React-Bootstrap：<a href="https://react-bootstrap.github.io/" target="_blank" rel="noopener">https://react-bootstrap.github.io/</a></p><p><img src="./images/react-bootstrap.png" alt=""></p><hr><h2 id="示例：ReCharts"><a href="#示例：ReCharts" class="headerlink" title="示例：ReCharts"></a>示例：ReCharts</h2><p>ReCharts 是一个 React 图表组件库。<a href="http://recharts.org/" target="_blank" rel="noopener">http://recharts.org/</a></p><p>浏览器打开<code>demos/recharts-demo/index.html</code>，按照<a href="../demos/README.md#recharts">《操作说明》</a>，仔细查看源码，体会 JSX 语法对表达复杂组件的优势。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LineChart</span> <span class="attr">width</span>=<span class="string">&#123;1000&#125;</span> <span class="attr">height</span>=<span class="string">&#123;400&#125;</span> <span class="attr">data</span>=<span class="string">&#123;data&#125;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">XAxis</span> <span class="attr">dataKey</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">YAxis</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CartesianGrid</span> <span class="attr">stroke</span>=<span class="string">"#eee"</span> <span class="attr">strokeDasharray</span>=<span class="string">"5 5"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Line</span> <span class="attr">type</span>=<span class="string">"monotone"</span> <span class="attr">dataKey</span>=<span class="string">"uv"</span> <span class="attr">stroke</span>=<span class="string">"#8884d8"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Line</span> <span class="attr">type</span>=<span class="string">"monotone"</span> <span class="attr">dataKey</span>=<span class="string">"pv"</span> <span class="attr">stroke</span>=<span class="string">"#82ca9d"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LineChart</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="React-的核心思想"><a href="#React-的核心思想" class="headerlink" title="React 的核心思想"></a>React 的核心思想</h2><p>View 是 State 的输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view = f(state)</span><br></pre></td></tr></table></figure><p>上式中，<code>f</code>表示函数关系。只要 State 发生变化，View 也要随之变化。</p><hr><p>React 的本质是将图形界面（GUI）函数化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"michel"</span>,</span><br><span class="line">  age: <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">&#123; person &#125;</span>) =&gt;</span> &lt;h1&gt;&#123; person.name &#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App person=&#123;person&#125; /</span>&gt;, <span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure><hr><h2 id="React-没有解决的问题"><a href="#React-没有解决的问题" class="headerlink" title="React 没有解决的问题"></a>React 没有解决的问题</h2><p>React 本身只是一个 DOM 的抽象层，使用组件构建虚拟 DOM。</p><p>如果开发大应用，还需要解决两个问题。</p><ul><li>架构：大型应用程序应该如何组织代码？</li><li>通信：组件之间如何通信？</li></ul><hr><h2 id="架构问题"><a href="#架构问题" class="headerlink" title="架构问题"></a>架构问题</h2><p>React 只是视图层的解决方案，可以用于任何一种架构。</p><ul><li>MVC</li><li>MVVM</li><li>Observer</li><li>Reactive</li><li>…</li></ul><p>到底哪一种架构最合适 React ？</p><hr><h2 id="通信问题"><a href="#通信问题" class="headerlink" title="通信问题"></a>通信问题</h2><p>组件会发生三种通信。</p><ul><li>向子组件发消息</li><li>向父组件发消息</li><li>向其他组件发消息</li></ul><p>React 只提供了一种通信手段：传参。对于大应用，很不方便。</p><hr><h2 id="状态的同步"><a href="#状态的同步" class="headerlink" title="状态的同步"></a>状态的同步</h2><p>通信的本质是状态的同步。</p><p>React 同步状态的基本方法：找到通信双方最近的共同父组件，通过它的<code>state</code>，使得子组件的状态保持同步。</p><hr><h2 id="Flux-架构"><a href="#Flux-架构" class="headerlink" title="Flux 架构"></a>Flux 架构</h2><p>Facebook 提出 Flux 架构的概念，被认为是 React 应用的标准架构。</p><p><img src="./images/flow.png" alt=""></p><p>最大特点：数据单向流动。与 MVVM 的数据双向绑定，形成鲜明对比。</p><hr><h2 id="Flux-的核心思想"><a href="#Flux-的核心思想" class="headerlink" title="Flux 的核心思想"></a>Flux 的核心思想</h2><ul><li>不同组件的<code>state</code>，存放在一个外部的、公共的 Store 上面。</li><li>组件订阅 Store 的不同部分。</li><li>组件发送（dispatch）动作（action），引发 Store 的更新。</li></ul><p>Flux 只是一个概念，有30多种实现。</p><hr><h2 id="目前最流行的两个-React-架构"><a href="#目前最流行的两个-React-架构" class="headerlink" title="目前最流行的两个 React 架构"></a>目前最流行的两个 React 架构</h2><p>React 架构的最重要作用：管理 Store 与 View 之间的关系。</p><ul><li>MobX：响应式（Reactive）管理，state 是可变对象，适合中小型项目</li><li>Redux：函数式（Functional）管理，state 是不可变对象，适合大型项目</li></ul><hr><h2 id="MobX-架构"><a href="#MobX-架构" class="headerlink" title="MobX 架构"></a>MobX 架构</h2><p>MobX 的核心是观察者模式。</p><ul><li>Store 是被观察者（observable）</li><li>组件是观察者（observer）</li></ul><p>一旦<code>Store</code>有变化，会立刻被组件观察到，从而引发重新渲染。</p><hr><h2 id="MobX-的最简单例子"><a href="#MobX-的最简单例子" class="headerlink" title="MobX 的最简单例子"></a>MobX 的最简单例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;observable&#125; = mobx;</span><br><span class="line"><span class="keyword">const</span> &#123;observer&#125; = mobxReact;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = observable(&#123;<span class="attr">name</span>: <span class="string">"张三"</span>, <span class="attr">age</span>: <span class="number">31</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = observer(</span><br><span class="line">  (&#123; person &#125;) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123; person.name &#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">person</span>=<span class="string">&#123;person&#125;</span> /&gt;</span>, document.body);</span></span><br><span class="line"><span class="xml">person.name = "李四";</span></span><br></pre></td></tr></table></figure><p>代码：<code>demos/mobx-demo/browser-demo</code>目录</p><hr><h2 id="示例：MobX"><a href="#示例：MobX" class="headerlink" title="示例：MobX"></a>示例：MobX</h2><p>进入<code>demos/mobx-demo</code>目录，按照<a href="../demos/README.md#mobx">《操作说明》</a>，理解 MobX 框架。</p><hr><p>UI 层是观察者，Store 是被观察者。</p><p>Store 所有的属性，分成两大类：直接被观察的属性和自动计算出来的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  @observable name = <span class="string">'Bartek'</span>;</span><br><span class="line">  @computed get decorated() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is awesome!`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UI 会观察到 Store 的变化，自动重新渲染。</p><hr><h2 id="Redux-架构"><a href="#Redux-架构" class="headerlink" title="Redux 架构"></a>Redux 架构</h2><p>Redux 的核心概念</p><ul><li>所有的状态存放在<code>Store</code>。组件每次重新渲染，都必须由状态变化引起。</li><li>用户在 UI 上发出<code>action</code>。</li><li><code>reducer</code>函数接收<code>action</code>，然后根据当前的<code>state</code>，计算出新的<code>state</code>。</li></ul><p><img src="./images/redux-architecture.png" alt=""></p><hr><h2 id="Redux-应用的架构"><a href="#Redux-应用的架构" class="headerlink" title="Redux 应用的架构"></a>Redux 应用的架构</h2><p><img src="./images/architecture-redux.png" alt=""></p><p>Redux 层保存所有状态，React 组件拿到状态以后，渲染出 HTML 代码。</p><hr><h2 id="示例：Redux"><a href="#示例：Redux" class="headerlink" title="示例：Redux"></a>示例：Redux</h2><p>进入<code>demos/redux-demo</code>目录，按照<a href="../demos/README.md#redux">《操作说明》</a>，理解 Redux 框架。</p><hr><ul><li>Redux 将组件分成 UI 组件和容器组件两类。</li><li>UI 组件是纯组件，不包含 state 和生命周期方法，不涉及组件的行为，只涉及组件的外观。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">"index"</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;<span class="keyword">this</span>.props.text&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input</span></span><br><span class="line"><span class="regexp">    defaultValue=&#123;this.props.name&#125;</span></span><br><span class="line"><span class="regexp">    onChange=&#123;this.props.onChange&#125;</span></span><br><span class="line"><span class="regexp">  /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><hr><p>容器组件正好相反。</p><ul><li>不涉及组件的外观，只涉及组件的行为。</li><li>负责订阅 Store，将 Store 的数据处理以后，再通过参数传给 UI 组件。</li><li>用户给出配置以后，由 Redux 生成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// MyComponent 是纯的 UI 组件</span><br><span class="line">const App = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(MyComponent);</span><br></pre></td></tr></table></figure><ul><li>mapStateToProps: 定义 UI 组件参数与 State 之间的映射</li><li>mapDispatchToProps：定义 UI 组件与 Action 之间的映射</li></ul><hr><h2 id="拆分-UI-组件和容器组件的好处"><a href="#拆分-UI-组件和容器组件的好处" class="headerlink" title="拆分 UI 组件和容器组件的好处"></a>拆分 UI 组件和容器组件的好处</h2><ul><li>UI 组件与后台数据无关，可以由设计师负责</li><li>容器组件只负责数据和行为，一旦 Store 的数据结构变化，只要调整容器组件即可</li><li>表现层和功能层脱钩，有利于代码重用，也有利于看清应用的数据结构和业务逻辑</li></ul><hr><h2 id="Reducer-函数"><a href="#Reducer-函数" class="headerlink" title="Reducer 函数"></a>Reducer 函数</h2><p><code>reducer</code>是一个纯函数，用来接收<code>action</code>，算出新的<code>state</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  text: <span class="string">'你好，访问者'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  name: <span class="string">'访问者'</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'change'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        name: action.payload,</span><br><span class="line">        text: <span class="string">'你好，'</span> + action.payload</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><code>Store</code>由 Redux 提供的<code>createStore</code>方法生成，该方法接受<code>reducer</code>作为参数。</li><li>为了把<code>Store</code>传入组件，必须使用 Redux 提供的<code>Provider</code>组件在应用的最外面，包裹一层。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.body.appendChild(document.createElement('div'))</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React 设计思想</title>
      <link href="/archives/7615.html"/>
      <url>/archives/7615.html</url>
      <content type="html"><![CDATA[<!-- build time:Mon Oct 15 2018 19:12:00 GMT+0800 (中国标准时间) --><h1 id="React-设计思想"><a href="#React-设计思想" class="headerlink" title="React 设计思想"></a>React 设计思想</h1><blockquote><p>译者序：本文是 React 核心开发者、有 React API 终结者之称的 Sebastian Markbåge 撰写，阐述了他设计 React 的初衷。阅读此文，你能站在更高的高度思考 React 的过去、现在和未来。原文地址：<a href="https://github.com/reactjs/react-basic" target="_blank" rel="noopener">https://github.com/reactjs/react-basic</a></p></blockquote><a id="more"></a><p>我写此文是想正式地阐述我心中 React 的<a href="http://baike.baidu.com/view/2333986.htm" target="_blank" rel="noopener">心智模型</a>。目的是解释为什么我们会这样设计 React，同时你也可以根据这些论点反推出 React。</p><p>不可否认，此文中的部分论据或前提尚存争议，而且部分示例的设计可能存在 bug 或疏忽。这只是正式确定它的最初阶段。如果你有更好的完善它的想法可以随时提交 pull request。本文不会介绍框架细节中的奇技淫巧，相信这样能提纲挈领，让你看清 React 由简单到复杂的设计过程。</p><p>React.js 的真实实现中充满了具体问题的解决方案，渐进式的解法，算法优化，历史遗留代码，debug 工具以及其他一些可以让它真的具有高可用性的内容。这些代码可能并不稳定，因为未来浏览器的变化和功能权重的变化随时面临改变。所以具体的代码很难彻底解释清楚。</p><p>我偏向于选择一种我能完全 hold 住的简洁的心智模型来作介绍。</p><h2 id="变换（Transformation）"><a href="#变换（Transformation）" class="headerlink" title="变换（Transformation）"></a>变换（Transformation）</h2><p>设计 React 的核心前提是认为 UI 只是把数据通过映射关系变换成另一种形式的数据。同样的输入必会有同样的输出。这恰好就是纯函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NameBox</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">fontWeight</span>: <span class="string">'bold'</span>, <span class="attr">labelContent</span>: name &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;Sebastian Markbåge&apos; -&gt;</span><br><span class="line">&#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125;;</span><br></pre></td></tr></table></figure><h2 id="抽象（Abstraction）"><a href="#抽象（Abstraction）" class="headerlink" title="抽象（Abstraction）"></a>抽象（Abstraction）</h2><p>你不可能仅用一个函数就能实现复杂的 UI。重要的是，你需要把 UI 抽象成多个隐藏内部细节，又可复用的函数。通过在一个函数中调用另一个函数来实现复杂的 UI，这就是抽象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyUserBox</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    borderStyle: <span class="string">'1px solid blue'</span>,</span><br><span class="line">    childContent: [</span><br><span class="line">      <span class="string">'Name: '</span>,</span><br><span class="line">      NameBox(user.firstName + <span class="string">' '</span> + user.lastName)</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; firstName: &apos;Sebastian&apos;, lastName: &apos;Markbåge&apos; &#125; -&gt;</span><br><span class="line">&#123;</span><br><span class="line">  borderStyle: &apos;1px solid blue&apos;,</span><br><span class="line">  childContent: [</span><br><span class="line">    &apos;Name: &apos;,</span><br><span class="line">    &#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h2><p>为了真正达到重用的特性，只重用叶子然后每次都为他们创建一个新的容器是不够的。你还需要可以包含其他抽象的容器再次进行组合。我理解的“组合”就是将两个或者多个不同的抽象合并为一个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBox</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    borderStyle: <span class="string">'1px solid blue'</span>,</span><br><span class="line">    children: children</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserBox</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox([</span><br><span class="line">    <span class="string">'Name: '</span>,</span><br><span class="line">    NameBox(user.firstName + <span class="string">' '</span> + user.lastName)</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h2><p>UI 不单单是对服务器端或业务逻辑状态的复制。实际上还有很多状态是针对具体的渲染目标。举个例子，在一个 text field 中打字。它不一定要复制到其他页面或者你的手机设备。滚动位置这个状态是一个典型的你几乎不会复制到多个渲染目标的。</p><p>我们倾向于使用不可变的数据模型。我们把可以改变 state 的函数串联起来作为原点放置在顶层。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyNameBox</span>(<span class="params">user, likes, onClick</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox([</span><br><span class="line">    <span class="string">'Name: '</span>, NameBox(user.firstName + <span class="string">' '</span> + user.lastName),</span><br><span class="line">    <span class="string">'Likes: '</span>, LikeBox(likes),</span><br><span class="line">    LikeButton(onClick)</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现细节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> likes = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOneMoreLike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  likes++;</span><br><span class="line">  rerender();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">FancyNameBox(</span><br><span class="line">  &#123; <span class="attr">firstName</span>: <span class="string">'Sebastian'</span>, <span class="attr">lastName</span>: <span class="string">'Markbåge'</span> &#125;,</span><br><span class="line">  likes,</span><br><span class="line">  addOneMoreLike</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><em>注意：本例更新状态时会带来副作用（addOneMoreLike 函数中）。我实际的想法是当一个“update”传入时我们返回下一个版本的状态，但那样会比较复杂。此示例待更新</em></p><h2 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a>Memoization</h2><p>对于纯函数，使用相同的参数一次次调用未免太浪费资源。我们可以创建一个函数的 memorized 版本，用来追踪最后一个参数和结果。这样如果我们继续使用同样的值，就不需要反复执行它了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cachedArg;</span><br><span class="line">  <span class="keyword">var</span> cachedResult;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cachedArg === arg) &#123;</span><br><span class="line">      <span class="keyword">return</span> cachedResult;</span><br><span class="line">    &#125;</span><br><span class="line">    cachedArg = arg;</span><br><span class="line">    cachedResult = fn(arg);</span><br><span class="line">    <span class="keyword">return</span> cachedResult;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> MemoizedNameBox = memoize(NameBox);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NameAndAgeBox</span>(<span class="params">user, currentTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox([</span><br><span class="line">    <span class="string">'Name: '</span>,</span><br><span class="line">    MemoizedNameBox(user.firstName + <span class="string">' '</span> + user.lastName),</span><br><span class="line">    <span class="string">'Age in milliseconds: '</span>,</span><br><span class="line">    currentTime - user.dateOfBirth</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="列表（Lists）"><a href="#列表（Lists）" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h2><p>大部分 UI 都是展示列表数据中不同 item 的列表结构。这是一个天然的层级。</p><p>为了管理列表中的每一个 item 的 state ，我们可以创造一个 Map 容纳具体 item 的 state。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserList</span>(<span class="params">users, likesPerUser, updateUserLikes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> users.map(<span class="function"><span class="params">user</span> =&gt;</span> FancyNameBox(</span><br><span class="line">    user,</span><br><span class="line">    likesPerUser.get(user.id),</span><br><span class="line">    () =&gt; updateUserLikes(user.id, likesPerUser.get(user.id) + <span class="number">1</span>)</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> likesPerUser = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateUserLikes</span>(<span class="params">id, likeCount</span>) </span>&#123;</span><br><span class="line">  likesPerUser.set(id, likeCount);</span><br><span class="line">  rerender();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserList(data.users, likesPerUser, updateUserLikes);</span><br></pre></td></tr></table></figure><p><em>注意：现在我们向 FancyNameBox 传了多个不同的参数。这打破了我们的 memoization 因为我们每次只能存储一个值。更多相关内容在下面。</em></p><h2 id="连续性（Continuations）"><a href="#连续性（Continuations）" class="headerlink" title="连续性（Continuations）"></a>连续性（Continuations）</h2><p>不幸的是，自从 UI 中有太多的列表，明确的管理就需要大量的重复性样板代码。</p><p>我们可以通过推迟一些函数的执行，进而把一些模板移出业务逻辑。比如，使用“柯里化”（JavaScript 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener"><code>bind</code></a>）。然后我们可以从核心的函数外面传递 state，这样就没有样板代码了。</p><p>下面这样并没有减少样板代码，但至少把它从关键业务逻辑中剥离。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyUserList</span>(<span class="params">users</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox(</span><br><span class="line">    UserList.bind(<span class="literal">null</span>, users)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> box = FancyUserList(data.users);</span><br><span class="line"><span class="keyword">const</span> resolvedChildren = box.children(likesPerUser, updateUserLikes);</span><br><span class="line"><span class="keyword">const</span> resolvedBox = &#123;</span><br><span class="line">  ...box,</span><br><span class="line">  children: resolvedChildren</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="State-Map"><a href="#State-Map" class="headerlink" title="State Map"></a>State Map</h2><p>之前我们知道可以使用组合避免重复执行相同的东西这样一种重复模式。我们可以把执行和传递 state 逻辑挪动到被复用很多的低层级的函数中去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBoxWithState</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  stateMap,</span></span></span><br><span class="line"><span class="function"><span class="params">  updateState</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox(</span><br><span class="line">    children.map(<span class="function"><span class="params">child</span> =&gt;</span> child.continuation(</span><br><span class="line">      stateMap.get(child.key),</span><br><span class="line">      updateState</span><br><span class="line">    ))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserList</span>(<span class="params">users</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> users.map(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">    continuation: FancyNameBox.bind(<span class="literal">null</span>, user),</span><br><span class="line">    key: user.id</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyUserList</span>(<span class="params">users</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBoxWithState.bind(<span class="literal">null</span>,</span><br><span class="line">    UserList(users)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> continuation = FancyUserList(data.users);</span><br><span class="line">continuation(likesPerUser, updateUserLikes);</span><br></pre></td></tr></table></figure><h2 id="Memoization-Map"><a href="#Memoization-Map" class="headerlink" title="Memoization Map"></a>Memoization Map</h2><p>一旦我们想在一个 memoization 列表中 memoize 多个 item 就会变得很困难。因为你需要制定复杂的缓存算法来平衡调用频率和内存占有率。</p><p>还好 UI 在同一个位置会相对的稳定。相同的位置一般每次都会接受相同的参数。这样以来，使用一个集合来做 memoization 是一个非常好用的策略。</p><p>我们可以用对待 state 同样的方式，在组合的函数中传递一个 memoization 缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg, memoizationCache</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memoizationCache.arg === arg) &#123;</span><br><span class="line">      <span class="keyword">return</span> memoizationCache.result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = fn(arg);</span><br><span class="line">    memoizationCache.arg = arg;</span><br><span class="line">    memoizationCache.result = result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBoxWithState</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  stateMap,</span></span></span><br><span class="line"><span class="function"><span class="params">  updateState,</span></span></span><br><span class="line"><span class="function"><span class="params">  memoizationCache</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox(</span><br><span class="line">    children.map(<span class="function"><span class="params">child</span> =&gt;</span> child.continuation(</span><br><span class="line">      stateMap.get(child.key),</span><br><span class="line">      updateState,</span><br><span class="line">      memoizationCache.get(child.key)</span><br><span class="line">    ))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MemoizedFancyNameBox = memoize(FancyNameBox);</span><br></pre></td></tr></table></figure><h2 id="代数效应（Algebraic-Effects）"><a href="#代数效应（Algebraic-Effects）" class="headerlink" title="代数效应（Algebraic Effects）"></a>代数效应（Algebraic Effects）</h2><p>多层抽象需要共享琐碎数据时，一层层传递数据非常麻烦。如果能有一种方式可以在多层抽象中快捷地传递数据，同时又不需要牵涉到中间层级，那该有多好。React 中我们把它叫做“context”。</p><p>有时候数据依赖并不是严格按照抽象树自上而下进行。举个例子，在布局算法中，你需要在实现他们的位置之前了解子节点的大小。</p><p>现在，这个例子有一点超纲。我会使用 <a href="http://math.andrej.com/eff/" target="_blank" rel="noopener">代数效应</a> 这个由我发起的 <a href="https://esdiscuss.org/topic/one-shot-delimited-continuations-with-effect-handlers" target="_blank" rel="noopener">ECMAScript 新特性提议</a>。如果你对函数式编程很熟悉，它们 在避免由 monad 强制引入的仪式一样的编码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeBorderColorRequest</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBox</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> color = raise <span class="keyword">new</span> ThemeBorderColorRequest();</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    borderWidth: <span class="string">'1px'</span>,</span><br><span class="line">    borderColor: color,</span><br><span class="line">    children: children</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlueTheme</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">    children();</span><br><span class="line">  &#125; <span class="keyword">catch</span> effect ThemeBorderColorRequest -&gt; [, continuation] &#123;</span><br><span class="line">    continuation(<span class="string">'blue'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BlueTheme(</span><br><span class="line">    FancyUserList.bind(<span class="literal">null</span>, data.users)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React中的state和props</title>
      <link href="/archives/992.html"/>
      <url>/archives/992.html</url>
      <content type="html"><![CDATA[<!-- build time:Mon Oct 15 2018 19:12:00 GMT+0800 (中国标准时间) --><p>整理一下React中关于state和props的知识点。</p><hr><p>在任何应用中，数据都是必不可少的。我们需要直接的改变页面上一块的区域来使得视图的刷新，或者间接地改变其他地方的数据。React的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在<code>props</code>和<code>state</code>中，这两个属性有啥子区别呢？</p><a id="more"></a><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>React的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件。</p><p>组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是<code>props</code>，所以可以把<code>props</code>理解为从外部传入组件内部的数据。由于React是单向数据流，所以<code>props</code>基本上也就是从服父级组件向子组件传递的数据。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>假设我们现在需要实现一个列表，根据React组件化思想，我们可以把列表中的行当做一个组件，也就是有这样两个组件：<code>&lt;ItemList/&gt;</code>和<code>&lt;Item/&gt;</code>。</p><p>先看看<code>&lt;ItemList/&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Item from &quot;./item&quot;;</span><br><span class="line">export default class ItemList extends React.Component&#123;</span><br><span class="line">  const itemList = data.map(item =&gt; &lt;Item item=item /&gt;);</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &#123;itemList&#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>列表的数据我们就暂时先假设是放在一个<code>data</code>变量中，然后通过<code>map</code>函数返回一个每一项都是<code>&lt;Item item=&#39;数据&#39;/&gt;</code>的数组，也就是说这里其实包含了<code>data.length</code>个<code>&lt;Item/&gt;</code>组件，数据通过在组件上自定义一个参数传递。当然，这里想传递几个自定义参数都可以。</p><p>在<code>&lt;Item /&gt;</code>中是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default class Item extends React.Component&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;li&gt;&#123;this.props.item&#125;&lt;/li&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>render</code>函数中可以看出，组件内部是使用<code>this.props</code>来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个<code>item</code>属性，所以通过<code>this.props.item</code>来获取即可。</p><h3 id="只读性"><a href="#只读性" class="headerlink" title="只读性"></a>只读性</h3><p><code>props</code>经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的<code>props</code>是只读的，不可改变的。如果<code>props</code>在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的<code>props</code>传入组件中。</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>在组件中，我们最好为<code>props</code>中的参数设置一个<code>defaultProps</code>，并且制定它的类型。比如，这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Item.defaultProps = &#123;</span><br><span class="line">  item: &apos;Hello Props&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Item.propTypes = &#123;</span><br><span class="line">  item: PropTypes.string,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于<code>propTypes</code>，可以声明为以下几种类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">optionalArray: PropTypes.array,</span><br><span class="line">optionalBool: PropTypes.bool,</span><br><span class="line">optionalFunc: PropTypes.func,</span><br><span class="line">optionalNumber: PropTypes.number,</span><br><span class="line">optionalObject: PropTypes.object,</span><br><span class="line">optionalString: PropTypes.string,</span><br><span class="line">optionalSymbol: PropTypes.symbol,</span><br></pre></td></tr></table></figure><p>注意，<code>bool</code>和<code>func</code>是简写。</p><p>这些知识基础数据类型，还有一些复杂的，附上链接：</p><p><a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">https://facebook.github.io/react/docs/typechecking-with-proptypes.html</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>props</code>是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的<code>props</code>来重新渲染子组件，否则子组件的<code>props</code>以及展现形式不会改变。</p><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p><code>state</code>是什么呢？</p><blockquote><p>State is similar to props, but it is private and fully controlled by the component.</p></blockquote><p>一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是<code>props</code>，而数据状态就是<code>state</code>。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default class ItemList extends React.Component&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      itemList:&apos;一些数据&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &#123;this.state.itemList&#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，在组件初始化的时候，通过<code>this.state</code>给组件设定一个初始的<code>state</code>，在第一次<code>render</code>的时候就会用这个数据来渲染组件。</p><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p><code>state</code>不同于<code>props</code>的一点是，<code>state</code>是可以被改变的。不过，不可以直接通过<code>this.state=</code>的方式来修改，而需要通过<code>this.setState()</code>方法来修改<code>state</code>。</p><p>比如，我们经常会通过异步操作来获取数据，我们需要在<code>didMount</code>阶段来执行异步操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">  fetch(&apos;url&apos;)</span><br><span class="line">    .then(response =&gt; response.json())</span><br><span class="line">    .then((data) =&gt; &#123;</span><br><span class="line">      this.setState(&#123;itemList:item&#125;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数据获取完成后，通过<code>this.setState</code>来修改数据状态。</p><p>当我们调用<code>this.setState</code>方法时，React会更新组件的数据状态<code>state</code>，并且重新调用<code>render</code>方法，也就是会对组件进行重新渲染。</p><p><strong>注意：通过<code>this.state=</code>来初始化<code>state</code>，使用<code>this.setState</code>来修改<code>state</code>，<code>constructor</code>是唯一能够初始化的地方。</strong></p><p><code>setState</code>接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default class ItemList extends React.Component&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      name:&apos;axuebin&apos;,</span><br><span class="line">      age:25,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    this.setState(&#123;age:18&#125;)  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行完<code>setState</code>之后的<code>state</code>应该是<code>{name:&#39;axuebin&#39;,age:18}</code>。</p><p><code>setState</code>还可以接受第二个参数，它是一个函数，会在<code>setState</code>调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">  name:&apos;xb&apos;</span><br><span class="line">&#125;,()=&gt;console.log(&apos;setState finished&apos;))</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>state</code>的主要作用是用于组件保存、控制以及修改自己的状态，它只能在<code>constructor</code>中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的<code>this.setState</code>来修改，修改<code>state</code>属性会导致组件的重新渲染。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li><code>state</code>是组件自己管理数据，控制自己的状态，可变；</li><li><code>props</code>是外部传入的数据参数，不可变；</li><li>没有<code>state</code>的叫做无状态组件，有<code>state</code>的叫做有状态组件；</li><li>多用<code>props</code>，少用<code>state</code>。也就是多写无状态组件。</li></ol><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>

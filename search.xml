<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在浏览器输入 URL 回车之后发生了什么（超详细版）]]></title>
    <url>%2Farchives%2Fab98.html</url>
    <content type="text"><![CDATA[本文由 简悦 SimpRead 转码， 原文地址 https://4ark.me/post/b6c7c0a2.html#3-%E6%B8%B2%E6%9F%93%E6%A0%91这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。前言这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。这篇笔记是我这两天看了数十篇文章总结出来的，所以相对全面一点，但由于我是做前端的，所以会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅，注意：本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。大致流程URL 解析DNS 查询TCP 连接处理请求接受响应渲染页面一、URL 解析地址解析：首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。HSTS由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：你所不知道的 HSTS。其他操作浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。检查缓存二、DNS 查询基本步骤1. 浏览器缓存浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。2. 操作系统缓存操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。3. 路由器缓存路由器也有自己的缓存。4. ISP DNS 缓存ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。根域名服务器查询在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：根域名服务器：维基百科需要注意的点递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地 DNS 服务器的过程）迭代方式，就是本地 DNS 服务器到根域名服务器查询的方式。什么是 DNS 劫持前端 dns-prefetch 优化三、TCP 连接TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：1. 应用层：发送 HTTP 请求在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：请求报头（Request Header）：请求方法、目标地址、遵循的协议等等请求主体（其他参数）其中需要注意的点：浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法2. 传输层：TCP 传输报文传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。在建立连接前，会先进行 TCP 三次握手。关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。相关知识点：SYN 泛洪攻击3. 网络层：IP 协议查询 Mac 地址将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线。判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。4. 链路层：以太网协议以太网协议根据以太网协议将数据分为以 “帧” 为单位的数据包，每一帧分为两个部分：标头：数据包的发送者、接受者、数据类型数据：数据包具体内容Mac 地址以太网规定了连入网络的所有设备都必须具备 “网卡” 接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。广播发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。注意：接收方回应是单播。相关知识点：ARP 攻击服务器接受请求接受过程就是把以上步骤逆转过来，参见上图。四、服务器处理请求大致流程HTTPD最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。它会监听得到的请求，然后开启一个子进程去处理这个请求。处理请求接受 TCP 报文后，会对连接进行处理，对 HTTP 协议进行解析（请求方法、域名、路径等），并且进行一些验证：验证是否配置虚拟主机验证虚拟主机是否接受此方法验证该用户可以使用该方法（根据 IP 地址、身份信息等）重定向假如服务器配置了 HTTP 重定向，就会返回一个 301永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。关于更多：详见这篇文章URL 重写然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js 文件等，则会直接把这个文件返回。否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。五、浏览器接受响应浏览器接收到来自服务器的响应资源后，会对资源进行分析。首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。如果响应资源进行了压缩（比如 gzip），还需要进行解压。然后，对响应资源做缓存。接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。六、渲染页面浏览器内核不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。基本流程1.HTML 解析首先要知道浏览器解析是从上往下一行一行地解析的。解析的过程可以分为四个步骤：1. 解码（encoding）传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如 UTF-8）转换成字符串，也就是 HTML 代码。2. 预解析（pre-parsing）预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如img标签的src属性，并将这个请求加到请求队列中。3. 符号化（Tokenization）符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。它通过一个状态机去识别符号的状态，比如遇到&lt;，&gt;状态都会产生变化。4. 构建树（tree construction）注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。在上一步符号化中，解析器获得这些标记，然后以合适的方法创建DOM对象并把这些符号插入到DOM对象中。1234567891011&lt;html&gt;&lt;head&gt; &lt;title&gt;Web page parsing&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;Web page parsing&lt;/h1&gt; &lt;p&gt;This is an example Web page.&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;浏览器容错进制你从来没有在浏览器看过类似” 语法无效” 的错误，这是因为浏览器去纠正错误的语法，然后继续工作。事件当整个解析的过程完成以后，浏览器会通过DOMContentLoaded事件来通知DOM解析完成。2. CSS 解析一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据语法规范解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。CSS 匹配规则在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：div p { font-size :14px }会先寻找所有的p标签然后判断它的父元素是否为div。所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。3. 渲染树其实这就是一个 DOM 树和 CSS 规则树合并的过程。注意：渲染树会忽略那些不需要渲染的节点，比如设置了display:none的节点。计算通过计算让任何尺寸值都减少到三个可能之一：auto、百分比、px，比如把rem转化为px。级联浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做specificity的公式，这个公式会通过：标签名、class、id是否内联样式!important然后得出一个权重值，取最高的那个。渲染阻塞当遇到一个script标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。所有我们知道：CSS 会阻塞 JS 执行JS 会阻塞后面的 DOM 解析为了避免这种情况，应该以下原则：CSS 资源排在 JavaScript 资源前面JS 放在 HTML 最底部，也就是 &lt;/body&gt;前另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：这篇文章4. 布局与绘制确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。5. 合并渲染层把以上绘制的所有图片合并，最终输出一张图片。6. 回流与重绘回流 (reflow)当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从html标签开始递归往下，重新计算位置和大小。reflow 基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。重绘 (repaint)改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。比如：display:none 会触发回流，而 visibility:hidden 只会触发重绘。7. JavaScript 编译执行大致流程可以分为三个阶段：1. 词法分析JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出 “语法错误”，停止执行。几个步骤：分词，例如将var a = 2，，分成var、a、=、2这样的词法单元。解析，将词法单元转换成抽象语法树（AST）。代码生成，将抽象语法树转换成机器指令。2. 预编译JS 有三种运行环境：全局环境函数环境eval每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。创建执行上下文创建执行上下文的过程中，主要做了以下三件事：创建变量对象参数、函数、变量建立作用域链确认当前执行环境是否能访问变量确定 This 指向3. 执行JS 线程虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：其中三个只是协助，只有 JS 引擎线程是真正执行的JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行定时器触发线程：主要控制setInterval和setTimeout，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。HTTP 异步请求线程：通过 XMLHttpRequest 连接后，通过浏览器新开的一个线程，监控 readyState 状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待 JS 引擎线程执行。注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。宏任务分为：同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待 JS 引擎主线程上的任务执行完毕时才开始执行，例如异步 Ajax、DOM 事件，setTimeout 等。微任务微任务是 ES6 和 Node 环境下的，主要 API 有：Promise，process.nextTick。微任务的执行在宏任务的同步任务之后，在异步任务之前。代码例子1234567891011121314console.log(&apos;1&apos;); // 宏任务 同步setTimeout(function() &#123; console.log(&apos;2&apos;); // 宏任务 异步&#125;)new Promise(function(resolve) &#123; console.log(&apos;3&apos;); // 宏任务 同步 resolve();&#125;).then(function() &#123; console.log(&apos;4&apos;) // 微任务&#125;)console.log(&apos;5&apos;) // 宏任务 同步以上代码输出顺序为：1,3,5,4,2参考文档what-happens-when-zh_CNTags to DOM彻底理解浏览器的缓存机制浏览器的工作原理：新式网络浏览器幕后揭秘深入浅出浏览器渲染原理js 引擎的执行过程（一）还有一些找不到了。。。。。]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React深入】从Mixin到HOC再到Hook]]></title>
    <url>%2Farchives%2F90ac.html</url>
    <content type="text"><![CDATA[本文由 简悦 SimpRead 转码， 原文地址 https://juejin.im/post/5cad39b3f265da03502b1c0a#heading-35导读前端发展速度非常之快，页面和组件变得越来越复杂，如何更好的实现状态逻辑复用一直都是应用程序中重要的一部分，这直接关系着应用程序的质量以及维护的难易程度。本文介绍了React采用的三种实现状态逻辑复用的技术，并分析了他们的实现原理、使用方法、实际应用以及如何选择使用他们。本文略长，下面是本文的思维导图，您可以从头开始阅读，也可以选择感兴趣的部分阅读：Mixin 设计模式Mixin（混入）是一种通过扩展收集功能的方式，它本质上是将一个对象的属性拷贝到另一个对象上面去，不过你可以拷贝任意多个对象的任意个方法到一个新对象上去，这是继承所不能实现的。它的出现主要就是为了解决代码复用问题。很多开源库提供了Mixin的实现，如Underscore的_.extend方法、JQuery的extend方法。使用_.extend方法实现代码复用：1234567891011121314151617var LogMixin = &#123; actionLog: function() &#123; console.log(&apos;action...&apos;); &#125;, requestLog: function() &#123; console.log(&apos;request...&apos;); &#125;,&#125;;function User() &#123; /*..*/ &#125;function Goods() &#123; /*..*/ &#125;_.extend(User.prototype, LogMixin);_.extend(Goods.prototype, LogMixin);var user = new User();var good = new Goods();user.actionLog();good.requestLog();复制代码我们可以尝试手动写一个简单的Mixin方法：1234567891011121314151617function setMixin(target, mixin) &#123; if (arguments[2]) &#123; for (var i = 2, len = arguments.length; i &lt; len; i++) &#123; target.prototype[arguments[i]] = mixin.prototype[arguments[i]]; &#125; &#125; else &#123; for (var methodName in mixin.prototype) &#123; if (!Object.hasOwnProperty(target.prototype, methodName)) &#123; target.prototype[methodName] = mixin.prototype[methodName]; &#125; &#125; &#125;&#125;setMixin(User,LogMixin,&apos;actionLog&apos;);setMixin(Goods,LogMixin,&apos;requestLog&apos;);复制代码您可以使用setMixin方法将任意对象的任意方法扩展到目标对象上。React 中应用 MixinReact也提供了Mixin的实现，如果完全不同的组件有相似的功能，我们可以引入来实现代码复用，当然只有在使用createClass来创建React组件时才可以使用，因为在React组件的es6写法中它已经被废弃掉了。例如下面的例子，很多组件或页面都需要记录用户行为，性能指标等。如果我们在每个组件都引入写日志的逻辑，会产生大量重复代码，通过Mixin我们可以解决这一问题：1234567891011121314151617181920212223242526var LogMixin = &#123; log: function() &#123; console.log(&apos;log&apos;); &#125;, componentDidMount: function() &#123; console.log(&apos;in&apos;); &#125;, componentWillUnmount: function() &#123; console.log(&apos;out&apos;); &#125;&#125;;var User = React.createClass(&#123; mixins: [LogMixin], render: function() &#123; return (&lt;div&gt;...&lt;/div&gt;) &#125;&#125;);var Goods = React.createClass(&#123; mixins: [LogMixin], render: function() &#123; return (&lt;div&gt;...&lt;/div&gt;) &#125;&#125;);复制代码Mixin 带来的危害React官方文档在 Mixins Considered Harmful 一文中提到了Mixin带来了危害：Mixin 可能会相互依赖，相互耦合，不利于代码维护不同的Mixin中的方法可能会相互冲突Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性React现在已经不再推荐使用Mixin来解决代码复用问题，因为Mixin带来的危害比他产生的价值还要巨大，并且React全面推荐使用高阶组件来替代它。另外，高阶组件还能实现更多其他更强大的功能，在学习高阶组件之前，我们先来看一个设计模式。装饰模式装饰者 (decorator) 模式能够在不改变对象自身的基础上，在程序运行期间给对像动态的添加职责。与继承相比，装饰者是一种更轻便灵活的做法。高阶组件（HOC）高阶组件可以看作React对装饰模式的一种实现，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。高阶组件（HOC）是React中的高级技术，用来重用组件逻辑。但高阶组件本身并不是React API。它只是一种模式，这种模式是由React自身的组合性质必然产生的。12345678910function visible(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, ...props &#125; = this.props; if (visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125;复制代码上面的代码就是一个HOC的简单应用，函数接收一个组件作为参数，并返回一个新组件，新组建可以接收一个visible props，根据visible的值来判断是否渲染 Visible。下面我们从以下几方面来具体探索HOC。HOC 的实现方式属性代理函数返回一个我们自己定义的组件，然后在render中返回要包裹的组件，这样我们就可以代理所有传入的props，并且决定如何渲染，实际上 ，这种方式生成的高阶组件就是原组件的父组件，上面的函数visible就是一个HOC属性代理的实现方式。12345678function proxyHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125;&#125;复制代码对比原生组件增强的项：可操作所有传入的props可操作组件的生命周期可操作组件的static方法获取refs反向继承返回一个组件，继承原组件，在render中调用原组件的render。由于继承了原组件，能通过 this 访问到原组件的生命周期、props、state、render等，相比属性代理它能操作更多的属性。12345678function inheritHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; return super.render(); &#125; &#125;&#125;复制代码对比原生组件增强的项：可操作所有传入的props可操作组件的生命周期可操作组件的static方法获取refs可操作state可以渲染劫持HOC 可以实现什么功能组合渲染可使用任何其他组件和原组件进行组合渲染，达到样式、布局复用等效果。通过属性代理实现1234567891011function stylHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; return (&lt;div&gt; &lt;div class&gt;&#123;this.props.title&#125;&lt;/div&gt; &lt;WrappedComponent &#123;...this.props&#125; /&gt; &lt;/div&gt;); &#125; &#125;&#125;复制代码通过反向继承实现1234567891011function styleHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; return &lt;div&gt; &lt;div class&gt;&#123;this.props.title&#125;&lt;/div&gt; &#123;super.render()&#125; &lt;/div&gt; &#125; &#125;&#125;复制代码条件渲染根据特定的属性决定原组件是否渲染通过属性代理实现123456789function visibleHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; if (this.props.visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125;复制代码通过反向继承实现123456789101112function visibleHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; if (this.props.visible === false) &#123; return null &#125; else &#123; return super.render() &#125; &#125; &#125;&#125;复制代码操作 props可以对传入组件的props进行增加、修改、删除或者根据特定的props进行特殊的操作。通过属性代理实现123456789101112function proxyHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const newProps = &#123; ...this.props, user: &apos;ConardLi&apos; &#125; return &lt;WrappedComponent &#123;...newProps&#125; /&gt;; &#125; &#125;&#125;复制代码获取 refs高阶组件中可获取原组件的ref，通过ref获取组件实力，如下面的代码，当程序初始化完成后调用原组件的 log 方法。(不知道 refs 怎么用，请👇Refs &amp; DOM)通过属性代理实现1234567891011function refHOC(WrappedComponent) &#123; return class extends Component &#123; componentDidMount() &#123; this.wapperRef.log() &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; ref=&#123;ref =&gt; &#123; this.wapperRef = ref &#125;&#125; /&gt;; &#125; &#125;&#125;复制代码这里注意：调用高阶组件的时候并不能获取到原组件的真实ref，需要手动进行传递，具体请看传递 refs状态管理将原组件的状态提取到HOC中进行管理，如下面的代码，我们将Input的value提取到HOC中进行管理，使它变成受控组件，同时不影响它使用onChange方法进行一些其他操作。基于这种方式，我们可以实现一个简单的双向绑定，具体请看双向绑定。通过属性代理实现123456789101112131415161718192021222324252627282930313233343536function proxyHoc(WrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: &apos;&apos; &#125;; &#125; onChange = (event) =&gt; &#123; const &#123; onChange &#125; = this.props; this.setState(&#123; value: event.target.value, &#125;, () =&gt; &#123; if(typeof onChange ===&apos;function&apos;)&#123; onChange(event); &#125; &#125;) &#125; render() &#123; const newProps = &#123; value: this.state.value, onChange: this.onChange, &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; &#125; &#125;&#125;class HOC extends Component &#123; render() &#123; return &lt;input &#123;...this.props&#125;&gt;&lt;/input&gt; &#125;&#125;export default proxyHoc(HOC);复制代码操作 state上面的例子通过属性代理利用 HOC 的 state 对原组件进行了一定的增强，但并不能直接控制原组件的state，而通过反向继承，我们可以直接操作原组件的state。但是并不推荐直接修改或添加原组件的state，因为这样有可能和组件内部的操作构成冲突。通过反向继承实现1234567891011121314function debugHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; console.log(&apos;props&apos;, this.props); console.log(&apos;state&apos;, this.state); return ( &lt;div class&gt; &#123;super.render()&#125; &lt;/div&gt; ) &#125; &#125;&#125;复制代码上面的HOC在render中将props和state打印出来，可以用作调试阶段，当然你可以在里面写更多的调试代码。想象一下，只需要在我们想要调试的组件上加上@debug就可以对该组件进行调试，而不需要在每次调试的时候写很多冗余代码。(如果你还不知道怎么使用 HOC，请👇如何使用 HOC)渲染劫持高阶组件可以在 render 函数中做非常多的操作，从而控制原组件的渲染输出。只要改变了原组件的渲染，我们都将它称之为一种渲染劫持。实际上，上面的组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可以实现以上两点，还可直接增强由原组件render函数产生的React元素。通过反向继承实现123456789101112131415function hijackHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; const tree = super.render(); let newProps = &#123;&#125;; if (tree &amp;&amp; tree.type === &apos;input&apos;) &#123; newProps = &#123; value: &apos;渲染被劫持了&apos; &#125;; &#125; const props = Object.assign(&#123;&#125;, tree.props, newProps); const newTree = React.cloneElement(tree, props, tree.props.children); return newTree; &#125; &#125;&#125;复制代码注意上面的说明我用的是增强而不是更改。render函数内实际上是调用React.creatElement产生的React元素：虽然我们能拿到它，但是我们不能直接修改它里面的属性，我们通过getOwnPropertyDescriptors函数来打印下它的配置项：可以发现，所有的writable属性均被配置为了false，即所有属性是不可变的。（对这些配置项有疑问，请👇defineProperty）不能直接修改，我们可以借助cloneElement方法来在原组件的基础上增强一个新组件：React.cloneElement()克隆并返回一个新的React元素，使用element作为起点。生成的元素将会拥有原始元素 props 与新 props 的浅合并。新的子级会替换现有的子级。来自原始元素的 key 和 ref 将会保留。React.cloneElement()几乎相当于：12&lt;element.type &#123;...element.props&#125; &#123;...props&#125;&gt;&#123;children&#125;&lt;/element.type&gt;复制代码如何使用 HOC上面的示例代码都写的是如何声明一个HOC，HOC实际上是一个函数，所以我们将要增强的组件作为参数调用HOC函数，得到增强后的组件。1234567class myComponent extends Component &#123; render() &#123; return (&lt;span&gt;原组件&lt;/span&gt;) &#125;&#125;export default inheritHOC(myComponent);复制代码compose在实际应用中，一个组件可能被多个HOC增强，我们使用的是被所有的HOC增强后的组件，借用一张装饰模式的图来说明，可能更容易理解：假设现在我们有logger，visible，style等多个HOC，现在要同时增强一个Input组件：12logger(visible(style(Input)))复制代码这种代码非常的难以阅读，我们可以手动封装一个简单的函数组合工具，将写法改写如下：123const compose = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; g(f(...args)));compose(logger,visible,style)(Input);复制代码compose函数返回一个所有函数组合后的函数，compose(f, g, h) 和 (...args) =&gt; f(g(h(...args)))是一样的。很多第三方库都提供了类似compose的函数，例如lodash.flowRight，Redux提供的combineReducers函数等。Decorators我们还可以借助ES7为我们提供的Decorators来让我们的写法变的更加优雅：1234567@logger@visible@styleclass Input extends Component &#123; // ...&#125;复制代码Decorators是ES7的一个提案，还没有被标准化，但目前Babel转码器已经支持，我们需要提前配置babel-plugin-transform-decorators-legacy：12&quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;]复制代码还可以结合上面的compose函数使用：123456const hoc = compose(logger, visible, style);@hocclass Input extends Component &#123; // ...&#125;复制代码HOC 的实际应用下面是一些我在生产环境中实际对HOC的实际应用场景，由于文章篇幅原因，代码经过很多简化，如有问题欢迎在评论区指出：日志打点实际上这属于一类最常见的应用，多个组件拥有类似的逻辑，我们要对重复的逻辑进行复用， 官方文档中CommentList的示例也是解决了代码复用问题，写的很详细，有兴趣可以👇使用高阶组件（HOC）解决横切关注点。某些页面需要记录用户行为，性能指标等等，通过高阶组件做这些事情可以省去很多重复代码。12345678910111213141516171819function logHoc(WrappedComponent) &#123; return class extends Component &#123; componentWillMount() &#123; this.start = Date.now(); &#125; componentDidMount() &#123; this.end = Date.now(); console.log(`$&#123;WrappedComponent.dispalyName&#125; 渲染时间：$&#123;this.end - this.start&#125; ms`); console.log(`$&#123;user&#125;进入$&#123;WrappedComponent.dispalyName&#125;`); &#125; componentWillUnmount() &#123; console.log(`$&#123;user&#125;退出$&#123;WrappedComponent.dispalyName&#125;`); &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt; &#125; &#125;&#125;复制代码可用、权限控制123456789101112function auth(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, auth, display = null, ...props &#125; = this.props; if (visible === false || (auth &amp;&amp; authList.indexOf(auth) === -1)) &#123; return display &#125; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125;复制代码authList是我们在进入程序时向后端请求的所有权限列表，当组件所需要的权限不列表中，或者设置的 visible是false，我们将其显示为传入的组件样式，或者null。我们可以将任何需要进行权限校验的组件应用HOC：12345678 @auth class Input extends Component &#123; ... &#125; @auth class Button extends Component &#123; ... &#125; &lt;Button auth=&quot;user/addUser&quot;&gt;添加用户&lt;/Button&gt; &lt;Input auth=&quot;user/search&quot; visible=&#123;false&#125; &gt;添加用户&lt;/Input&gt;复制代码双向绑定在vue中，绑定一个变量后可实现双向数据绑定，即表单中的值改变后绑定的变量也会自动改变。而React中没有做这样的处理，在默认情况下，表单元素都是非受控组件。给表单元素绑定一个状态后，往往需要手动书写onChange方法来将其改写为受控组件，在表单元素非常多的情况下这些重复操作是非常痛苦的。我们可以借助高阶组件来实现一个简单的双向绑定，代码略长，可以结合下面的思维导图进行理解。首先我们自定义一个Form组件，该组件用于包裹所有需要包裹的表单组件，通过contex向子组件暴露两个属性：model：当前Form管控的所有数据，由表单name和value组成，如{name:&#39;ConardLi&#39;,pwd:&#39;123&#39;}。model可由外部传入，也可自行管控。changeModel：改变model中某个name的值。12345678910111213141516171819202122232425262728293031323334353637383940class Form extends Component &#123; static childContextTypes = &#123; model: PropTypes.object, changeModel: PropTypes.func &#125; constructor(props, context) &#123; super(props, context); this.state = &#123; model: props.model || &#123;&#125; &#125;; &#125; componentWillReceiveProps(nextProps) &#123; if (nextProps.model) &#123; this.setState(&#123; model: nextProps.model &#125;) &#125; &#125; changeModel = (name, value) =&gt; &#123; this.setState(&#123; model: &#123; ...this.state.model, [name]: value &#125; &#125;) &#125; getChildContext() &#123; return &#123; changeModel: this.changeModel, model: this.props.model || this.state.model &#125;; &#125; onSubmit = () =&gt; &#123; console.log(this.state.model); &#125; render() &#123; return &lt;div&gt; &#123;this.props.children&#125; &lt;button onClick=&#123;this.onSubmit&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &#125;&#125;复制代码下面定义用于双向绑定的HOC，其代理了表单的onChange属性和value属性：发生onChange事件时调用上层Form的changeModel方法来改变context中的model。在渲染时将value改为从context中取出的值。123456789101112131415161718192021222324252627282930313233function proxyHoc(WrappedComponent) &#123; return class extends Component &#123; static contextTypes = &#123; model: PropTypes.object, changeModel: PropTypes.func &#125; onChange = (event) =&gt; &#123; const &#123; changeModel &#125; = this.context; const &#123; onChange &#125; = this.props; const &#123; v_model &#125; = this.props; changeModel(v_model, event.target.value); if(typeof onChange === &apos;function&apos;)&#123;onChange(event);&#125; &#125; render() &#123; const &#123; model &#125; = this.context; const &#123; v_model &#125; = this.props; return &lt;WrappedComponent &#123;...this.props&#125; value=&#123;model[v_model]&#125; onChange=&#123;this.onChange&#125; /&gt;; &#125; &#125;&#125;@proxyHocclass Input extends Component &#123; render() &#123; return &lt;input &#123;...this.props&#125;&gt;&lt;/input&gt; &#125;&#125;复制代码上面的代码只是简略的一部分，除了input，我们还可以将HOC应用在select等其他表单组件，甚至还可以将上面的HOC兼容到span、table等展示组件，这样做可以大大简化代码，让我们省去了很多状态管理的工作，使用如下：1234567891011export default class extends Component &#123; render() &#123; return ( &lt;Form &gt; &lt;Input v_model=&quot;name&quot;&gt;&lt;/Input&gt; &lt;Input v_model=&quot;pwd&quot;&gt;&lt;/Input&gt; &lt;/Form&gt; ) &#125;&#125;复制代码表单校验基于上面的双向绑定的例子，我们再来一个表单验证器，表单验证器可以包含验证函数以及提示信息，当验证不通过时，展示错误信息：12345678910111213141516171819202122232425function validateHoc(WrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; error: &apos;&apos; &#125; &#125; onChange = (event) =&gt; &#123; const &#123; validator &#125; = this.props; if (validator &amp;&amp; typeof validator.func === &apos;function&apos;) &#123; if (!validator.func(event.target.value)) &#123; this.setState(&#123; error: validator.msg &#125;) &#125; else &#123; this.setState(&#123; error: &apos;&apos; &#125;) &#125; &#125; &#125; render() &#123; return &lt;div&gt; &lt;WrappedComponent onChange=&#123;this.onChange&#125; &#123;...this.props&#125; /&gt; &lt;div&gt;&#123;this.state.error || &apos;&apos;&#125;&lt;/div&gt; &lt;/div&gt; &#125; &#125;&#125;复制代码1234567891011const validatorName = &#123; func: (val) =&gt; val &amp;&amp; !isNaN(val), msg: &apos;请输入数字&apos;&#125;const validatorPwd = &#123; func: (val) =&gt; val &amp;&amp; val.length &gt; 6, msg: &apos;密码必须大于6位&apos;&#125;&lt;HOCInput validator=&#123;validatorName&#125; v_model=&quot;name&quot;&gt;&lt;/HOCInput&gt;&lt;HOCInput validator=&#123;validatorPwd&#125; v_model=&quot;pwd&quot;&gt;&lt;/HOCInput&gt;复制代码当然，还可以在Form提交的时候判断所有验证器是否通过，验证器也可以设置为数组等等，由于文章篇幅原因，代码被简化了很多，有兴趣的同学可以自己实现。Redux 的 connectredux 中的connect，其实就是一个HOC，下面就是一个简化版的connect实现：123456789101112131415161718192021222324252627282930313233343536373839export const connect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor () &#123; super() this.state = &#123; allProps: &#123;&#125; &#125; &#125; componentWillMount () &#123; const &#123; store &#125; = this.context this._updateProps() store.subscribe(() =&gt; this._updateProps()) &#125; _updateProps () &#123; const &#123; store &#125; = this.context let stateProps = mapStateToProps ? mapStateToProps(store.getState(), this.props): &#123;&#125; let dispatchProps = mapDispatchToProps? mapDispatchToProps(store.dispatch, this.props) : &#123;&#125; this.setState(&#123; allProps: &#123; ...stateProps, ...dispatchProps, ...this.props &#125; &#125;) &#125; render () &#123; return &lt;WrappedComponent &#123;...this.state.allProps&#125; /&gt; &#125; &#125; return Connect&#125;复制代码代码非常清晰，connect函数其实就做了一件事，将mapStateToProps和mapDispatchToProps分别解构后传给原组件，这样我们在原组件内就可以直接用props获取state以及dispatch函数了。使用 HOC 的注意事项告诫—静态属性拷贝当我们应用HOC去增强另一个组件时，我们实际使用的组件已经不是原组件了，所以我们拿不到原组件的任何静态属性，我们可以在HOC的结尾手动拷贝他们：1234567891011function proxyHOC(WrappedComponent) &#123; class HOCComponent extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; HOCComponent.staticMethod = WrappedComponent.staticMethod; // ... return HOCComponent;&#125;复制代码如果原组件有非常多的静态属性，这个过程是非常痛苦的，而且你需要去了解需要增强的所有组件的静态属性是什么，我们可以使用 hoist-non-react-statics来帮助我们解决这个问题，它可以自动帮我们拷贝所有非React的静态方法，使用方式如下：1234567891011import hoistNonReactStatic from &apos;hoist-non-react-statics&apos;;function proxyHOC(WrappedComponent) &#123; class HOCComponent extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; hoistNonReactStatic(HOCComponent,WrappedComponent); return HOCComponent;&#125;复制代码告诫—传递 refs使用高阶组件后，获取到的ref实际上是最外层的容器组件，而非原组件，但是很多情况下我们需要用到原组件的ref。高阶组件并不能像透传props那样将refs透传，我们可以用一个回调函数来完成ref的传递：1234567891011121314151617181920function hoc(WrappedComponent) &#123; return class extends Component &#123; getWrappedRef = () =&gt; this.wrappedRef; render() &#123; return &lt;WrappedComponent ref=&#123;ref =&gt; &#123; this.wrappedRef = ref &#125;&#125; &#123;...this.props&#125; /&gt;; &#125; &#125;&#125;@hocclass Input extends Component &#123; render() &#123; return &lt;input&gt;&lt;/input&gt; &#125;&#125;class App extends Component &#123; render() &#123; return ( &lt;Input ref=&#123;ref =&gt; &#123; this.inpitRef = ref.getWrappedRef() &#125;&#125; &gt;&lt;/Input&gt; ); &#125;&#125;复制代码React 16.3版本提供了一个forwardRef API来帮助我们进行refs传递，这样我们在高阶组件上获取的ref就是原组件的ref了，而不需要再手动传递，如果你的React版本大于16.3，可以使用下面的方式:123456789101112function hoc(WrappedComponent) &#123; class HOC extends Component &#123; render() &#123; const &#123; forwardedRef, ...props &#125; = this.props; return &lt;WrappedComponent ref=&#123;forwardedRef&#125; &#123;...props&#125; /&gt;; &#125; &#125; return React.forwardRef((props, ref) =&gt; &#123; return &lt;HOC forwardedRef=&#123;ref&#125; &#123;...props&#125; /&gt;; &#125;);&#125;复制代码告诫—不要在 render 方法内创建高阶组件React Diff算法的原则是：使用组件标识确定是卸载还是更新组件如果组件的和前一次渲染时标识是相同的，递归更新子组件如果标识不同卸载组件重新挂载新组件每次调用高阶组件生成的都是是一个全新的组件，组件的唯一标识响应的也会改变，如果在render方法调用了高阶组件，这会导致组件每次都会被卸载后重新挂载。约定 - 不要改变原始组件官方文档对高阶组件的说明：高阶组件就是一个没有副作用的纯函数。我们再来看看纯函数的定义：如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。 该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变。如果我们在高阶组件对原组件进行了修改，例如下面的代码：12InputComponent.prototype.componentWillReceiveProps = function(nextProps) &#123; ... &#125;复制代码这样就破坏了我们对高阶组件的约定，同时也改变了使用高阶组件的初衷：我们使用高阶组件是为了增强而非改变原组件。约定 - 透传不相关的 props使用高阶组件，我们可以代理所有的props，但往往特定的HOC只会用到其中的一个或几个props。我们需要把其他不相关的props透传给原组件，如下面的代码：12345678910function visible(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, ...props &#125; = this.props; if (visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125;复制代码我们只使用visible属性来控制组件的显示可隐藏，把其他props透传下去。约定 - displayName在使用React Developer Tools进行调试时，如果我们使用了HOC，调试界面可能变得非常难以阅读，如下面的代码：12345678910111213@visibleclass Show extends Component &#123; render() &#123; return &lt;h1&gt;我是一个标签&lt;/h1&gt; &#125;&#125;@visibleclass Title extends Component &#123; render() &#123; return &lt;h1&gt;我是一个标题&lt;/h1&gt; &#125;&#125;复制代码为了方便调试，我们可以手动为HOC指定一个displayName，官方推荐使用HOCName(WrappedComponentName)：12static displayName = `Visible($&#123;WrappedComponent.displayName&#125;)`复制代码这个约定帮助确保高阶组件最大程度的灵活性和可重用性。使用 HOC 的动机回顾下上文提到的 Mixin 带来的风险：Mixin 可能会相互依赖，相互耦合，不利于代码维护不同的Mixin中的方法可能会相互冲突Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性而HOC的出现可以解决这些问题：高阶组件就是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些行为高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担HOC 的缺陷HOC需要在原组件上进行包裹或者嵌套，如果大量使用HOC，将会产生非常多的嵌套，这让调试变得非常困难。HOC可以劫持props，在不遵守约定的情况下也可能造成冲突。HooksHooks是React v16.7.0-alpha中加入的新特性。它可以让你在class以外使用state和其他React特性。使用Hooks，你可以在将含有state的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试。同时，Hooks可以帮助你在不重写组件结构的情况下复用这些逻辑。所以，它也可以作为一种实现状态逻辑复用的方案。阅读下面的章节使用 Hook 的动机你可以发现，它可以同时解决Mixin和HOC带来的问题。官方提供的 HooksState Hook我们要使用class组件实现一个计数器功能，我们可能会这样写：1234567891011121314151617export default class Count extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;复制代码通过useState，我们使用函数式组件也能实现这样的功能：123456789101112export default function HookTest() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setNumber(number + 1); &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;复制代码useState是一个钩子，他可以为函数式组件增加一些状态，并且提供改变这些状态的函数，同时它接收一个参数，这个参数作为状态的默认值。Effect HookEffect Hook 可以让你在函数组件中执行一些具有 side effect（副作用）的操作参数useEffect方法接收传入两个参数：回调函数：在第组件一次render和之后的每次update后运行，React保证在DOM已经更新完成之后才会运行回调。状态依赖 (数组)：当配置了状态依赖项后，只有检测到配置的状态变化时，才会调用回调函数。1234567 useEffect(() =&gt; &#123; // 只要组件render后就会执行 &#125;); useEffect(() =&gt; &#123; // 只有count改变时才会执行 &#125;,[count]);复制代码回调返回值useEffect的第一个参数可以返回一个函数，当页面渲染了下一次更新的结果后，执行下一次useEffect之前，会调用这个函数。这个函数常常用来对上一次调用useEffect进行清理。123456789101112131415161718export default function HookTest() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; console.log(&apos;执行...&apos;, count); return () =&gt; &#123; console.log(&apos;清理...&apos;, count); &#125; &#125;, [count]); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setNumber(number + 1); &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;复制代码执行上面的代码，并点击几次按钮，会得到下面的结果：注意，如果加上浏览器渲染的情况，结果应该是这样的：123456789101112 页面渲染...1 执行... 1 页面渲染...2 清理... 1 执行... 2 页面渲染...3 清理... 2 执行... 3 页面渲染...4 清理... 3 执行... 4复制代码那么为什么在浏览器渲染完后，再执行清理的方法还能找到上次的state呢？原因很简单，我们在useEffect中返回的是一个函数，这形成了一个闭包，这能保证我们上一次执行函数存储的变量不被销毁和污染。你可以尝试下面的代码可能更好理解1234567891011121314151617181920212223 var flag = 1; var clean; function effect(flag) &#123; return function () &#123; console.log(flag); &#125; &#125; clean = effect(flag); flag = 2; clean(); clean = effect(flag); flag = 3; clean(); clean = effect(flag); // 执行结果 effect... 1 clean... 1 effect... 2 clean... 2 effect... 3复制代码模拟 componentDidMountcomponentDidMount等价于useEffect的回调仅在页面初始化完成后执行一次，当useEffect的第二个参数传入一个空数组时可以实现这个效果。1234function useDidMount(callback) &#123; useEffect(callback, []);&#125;复制代码官方不推荐上面这种写法，因为这有可能导致一些错误。模拟 componentWillUnmount1234function useUnMount(callback) &#123; useEffect(() =&gt; callback, []);&#125;复制代码不像 componentDidMount 或者 componentDidUpdate，useEffect 中使用的 effect 并不会阻滞浏览器渲染页面。这让你的 app 看起来更加流畅。ref Hook使用useRef Hook，你可以轻松的获取到dom的ref。12345678910111213export default function Input() &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; inputEl.current.focus(); &#125;; return ( &lt;div&gt; &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot; /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/div&gt; );&#125;复制代码注意useRef()并不仅仅可以用来当作获取ref使用，使用useRef产生的ref的current属性是可变的，这意味着你可以用它来保存一个任意值。模拟 componentDidUpdatecomponentDidUpdate就相当于除去第一次调用的useEffect，我们可以借助useRef生成一个标识，来记录是否为第一次执行：123456789101112function useDidUpdate(callback, prop) &#123; const init = useRef(true); useEffect(() =&gt; &#123; if (init.current) &#123; init.current = false; &#125; else &#123; return callback(); &#125; &#125;, prop);&#125;复制代码使用 Hook 的注意事项使用范围只能在React函数式组件或自定义Hook中使用Hook。Hook的提出主要就是为了解决class组件的一系列问题，所以我们能在class组件中使用它。声明约束不要在循环，条件或嵌套函数中调用 Hook。Hook通过数组实现的，每次useState 都会改变下标，React需要利用调用顺序来正确更新相应的状态，如果useState 被包裹循环或条件语句中，那每就可能会引起调用顺序的错乱，从而造成意想不到的错误。我们可以安装一个eslint插件来帮助我们避免这些问题。1234567891011121314// 安装npm install eslint-plugin-react-hooks --save-dev// 配置&#123; &quot;plugins&quot;: [ // ... &quot;react-hooks&quot; ], &quot;rules&quot;: &#123; // ... &quot;react-hooks/rules-of-hooks&quot;: &quot;error&quot; &#125;&#125;复制代码自定义 Hook像上面介绍的HOC和mixin一样，我们同样可以通过自定义的Hook将组件中类似的状态逻辑抽取出来。自定义Hook非常简单，我们只需要定义一个函数，并且把相应需要的状态和effect封装进去，同时，Hook之间也是可以相互引用的。使用use开头命名自定义Hook，这样可以方便eslint进行检查。下面我们看几个具体的Hook封装：日志打点我们可以使用上面封装的生命周期Hook。1234567891011121314151617const useLogger = (componentName, ...params) =&gt; &#123; useDidMount(() =&gt; &#123; console.log(`$&#123;componentName&#125;初始化`, ...params); &#125;); useUnMount(() =&gt; &#123; console.log(`$&#123;componentName&#125;卸载`, ...params); &#125;) useDidUpdate(() =&gt; &#123; console.log(`$&#123;componentName&#125;更新`, ...params); &#125;);&#125;;function Page1(props)&#123; useLogger(&apos;Page1&apos;,props); return (&lt;div&gt;...&lt;/div&gt;)&#125;复制代码修改 title根据不同的页面名称修改页面title:1234567891011121314function useTitle(title) &#123; useEffect( () =&gt; &#123; document.title = title; return () =&gt; (document.title = &quot;主页&quot;); &#125;, [title] );&#125;function Page1(props)&#123; useTitle(&apos;Page1&apos;); return (&lt;div&gt;...&lt;/div&gt;)&#125;复制代码双向绑定我们将表单onChange的逻辑抽取出来封装成一个Hook，这样所有需要进行双向绑定的表单组件都可以进行复用：123456789101112131415function useBind(init) &#123; let [value, setValue] = useState(init); let onChange = useCallback(function(event) &#123; setValue(event.currentTarget.value); &#125;, []); return &#123; value, onChange &#125;;&#125;function Page1(props)&#123; let value = useBind(&apos;&apos;); return &lt;input &#123;...value&#125; /&gt;;&#125;复制代码当然，你可以向上面的HOC那样，结合context和form来封装一个更通用的双向绑定，有兴趣可以手动实现一下。使用 Hook 的动机减少状态逻辑复用的风险Hook和Mixin在用法上有一定的相似之处，但是Mixin引入的逻辑和状态是可以相互覆盖的，而多个Hook之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。在不遵守约定的情况下使用HOC也有可能带来一定冲突，比如props覆盖等等，使用Hook则可以避免这些问题。避免地狱式嵌套大量使用HOC的情况下让我们的代码变得嵌套层级非常深，使用Hook，我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套。让组件更容易理解在使用class组件构建我们的程序时，他们各自拥有自己的状态，业务逻辑的复杂使这些组件变得越来越庞大，各个生命周期中会调用越来越多的逻辑，越来越难以维护。使用Hook，可以让你更大限度的将公用逻辑抽离，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割。使用函数代替 class相比函数，编写一个class可能需要掌握更多的知识，需要注意的点也越多，比如this指向、绑定事件等等。另外，计算机理解一个函数比理解一个class更快。Hooks让你可以在classes之外使用更多React的新特性。理性的选择实际上，Hook在react 16.8.0才正式发布Hook稳定版本，笔者也还未在生产环境下使用，目前笔者在生产环境下使用的最多的是HOC。React官方完全没有把classes从React中移除的打算，class组件和Hook完全可以同时存在，官方也建议避免任何 “大范围重构”，毕竟这是一个非常新的版本，如果你喜欢它，可以在新的非关键性的代码中使用Hook。小结mixin已被抛弃，HOC正当壮年，Hook初露锋芒，前端圈就是这样，技术迭代速度非常之快，但我们在学习这些知识之时一定要明白为什么要学，学了有没有用，要不要用。不忘初心，方得始终。文中如有错误，欢迎在评论区指正，谢谢阅读。推荐阅读【React 深入】setState 的执行机制【React 深入】React 事件机制]]></content>
  </entry>
  <entry>
    <title><![CDATA[30分钟精通React Hooks]]></title>
    <url>%2Farchives%2F66c2.html</url>
    <content type="text"><![CDATA[本文由 简悦 SimpRead 转码， 原文地址 https://juejin.im/post/5be3ea136fb9a049f9121014你还在为该使用无状态组件（Function）还是有状态组件（Class）而烦恼吗？ ——拥有了 hooks，你再也不需要写 Class 了，你的所有组件都将是 Function。你还在为搞不清使用哪个生命周期钩子函数而日夜难眠吗？ ——拥有了 Hooks，生命周期钩子函数可以先丢一边了。你在还在为组件中的 this 指向而晕头转向吗？ ——既然 Class 都丢掉了，哪里还有 this？你的人生第一次不再需要面对 this。这样看来，说 React Hooks 是今年最劲爆的新特性真的毫不夸张。如果你也对 react 感兴趣，或者正在使用 react 进行项目开发，答应我，请一定抽出至少 30 分钟的时间来阅读本文好吗？一个最简单的 Hooks首先让我们看一下一个简单的有状态组件：1234567891011121314151617181920class Example extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;复制代码我们再来看一下使用 hooks 后的版本：123456789101112131415import &#123; useState &#125; from &apos;react&apos;;function Example() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;复制代码是不是简单多了！可以看到，Example变成了一个函数，但这个函数却有自己的状态（count），同时它还可以更新自己的状态（setCount）。这个函数之所以这么了不得，就是因为它注入了一个 hook–useState，就是这个 hook 让我们的函数变成了一个有状态的函数。除了useState这个 hook 外，还有很多别的 hook，比如useEffect提供了类似于componentDidMount等生命周期钩子的功能，useContext提供了上下文（context）的功能等等。Hooks 本质上就是一类特殊的函数，它们可以为你的函数型组件（function component）注入一些特殊的功能。咦？这听起来有点像被诟病的 Mixins 啊？难道是 Mixins 要在 react 中死灰复燃了吗？当然不会了，等会我们再来谈两者的区别。总而言之，这些 hooks 的目标就是让你不再写 class，让 function 一统江湖。React 为什么要搞一个 Hooks？想要复用一个有状态的组件太麻烦了！我们都知道 react 都核心思想就是，将一个页面拆成一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来。但假如你在大型的工作项目中用 react，你会发现你的项目中实际上很多 react 组件冗长且难以复用。尤其是那些写成 class 的组件，它们本身包含了状态（state），所以复用这类组件就变得很麻烦。那之前，官方推荐怎么解决这个问题呢？答案是：渲染属性（Render Props）和高阶组件（Higher-Order Components）。我们可以稍微跑下题简单看一下这两种模式。渲染属性指的是使用一个值为函数的 prop 来传递需要动态渲染的 nodes 或组件。如下面的代码可以看到我们的DataProvider组件包含了所有跟状态相关的代码，而Cat组件则可以是一个单纯的展示型组件，这样一来DataProvider就可以单独复用了。123456789101112131415161718192021import Cat from &apos;components/cat&apos;class DataProvider extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; target: &apos;Zac&apos; &#125;; &#125; render() &#123; return ( &lt;div&gt; &#123;this.props.render(this.state)&#125; &lt;/div&gt; ) &#125;&#125;&lt;DataProvider render=&#123;data =&gt; ( &lt;Cat target=&#123;data.target&#125; /&gt;)&#125;/&gt;复制代码虽然这个模式叫 Render Props，但不是说非用一个叫 render 的 props 不可，习惯上大家更常写成下面这种：1234567...&lt;DataProvider&gt; &#123;data =&gt; ( &lt;Cat target=&#123;data.target&#125; /&gt; )&#125;&lt;/DataProvider&gt;复制代码高阶组件这个概念就更好理解了，说白了就是一个函数接受一个组件作为参数，经过一系列加工后，最后返回一个新的组件。看下面的代码示例，withUser函数就是一个高阶组件，它返回了一个新的组件，这个组件具有了它提供的获取用户信息的功能。12345678910111213const withUser = WrappedComponent =&gt; &#123; const user = sessionStorage.getItem(&quot;user&quot;); return props =&gt; &lt;WrappedComponent user=&#123;user&#125; &#123;...props&#125; /&gt;;&#125;;const UserPage = props =&gt; ( &lt;div class=&quot;user-container&quot;&gt; &lt;p&gt;My name is &#123;props.user&#125;!&lt;/p&gt; &lt;/div&gt;);export default withUser(UserPage);复制代码以上这两种模式看上去都挺不错的，很多库也运用了这种模式，比如我们常用的 React Router。但我们仔细看这两种模式，会发现它们会增加我们代码的层级关系。最直观的体现，打开 devtool 看看你的组件层级嵌套是不是很夸张吧。这时候再回过头看我们上一节给出的 hooks 例子，是不是简洁多了，没有多余的层级嵌套。把各种想要的功能写成一个一个可复用的自定义 hook，当你的组件想用什么功能时，直接在组件里调用这个 hook 即可。生命周期钩子函数里的逻辑太乱了吧！我们通常希望一个函数只做一件事情，但我们的生命周期钩子函数里通常同时做了很多事情。比如我们需要在componentDidMount中发起 ajax 请求获取数据，绑定一些事件监听等等。同时，有时候我们还需要在componentDidUpdate做一遍同样的事情。当项目变复杂后，这一块的代码也变得不那么直观。classes 真的太让人困惑了！我们用 class 来创建 react 组件时，还有一件很麻烦的事情，就是 this 的指向问题。为了保证 this 的指向正确，我们要经常写这样的代码：this.handleClick = this.handleClick.bind(this)，或者是这样的代码：&lt;button onClick={() =&gt; this.handleClick(e)}&gt;。一旦我们不小心忘了绑定 this，各种 bug 就随之而来，很麻烦。还有一件让我很苦恼的事情。我在之前的 react 系列文章当中曾经说过，尽可能把你的组件写成无状态组件的形式，因为它们更方便复用，可独立测试。然而很多时候，我们用 function 写了一个简洁完美的无状态组件，后来因为需求变动这个组件必须得有自己的 state，我们又得很麻烦的把 function 改成 class。在这样的背景下，Hooks 便横空出世了！什么是 State Hooks？回到一开始我们用的例子，我们分解来看到底 state hooks 做了什么：123456789101112131415import &#123; useState &#125; from &apos;react&apos;;function Example() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;复制代码声明一个状态变量12345import &#123; useState &#125; from &apos;react&apos;;function Example() &#123; const [count, setCount] = useState(0);复制代码useState是 react 自带的一个 hook 函数，它的作用就是用来声明状态变量。useState这个函数接收的参数是我们的状态初始值（initial state），它返回了一个数组，这个数组的第[0]项是当前当前的状态值，第[1]项是可以改变状态值的方法函数。所以我们做的事情其实就是，声明了一个状态变量 count，把它的初始值设为 0，同时提供了一个可以更改 count 的函数 setCount。上面这种表达形式，是借用了 es6 的数组解构（array destructuring），它可以让我们的代码看起来更简洁。不清楚这种用法的可以先去看下我的这篇文章 30 分钟掌握 ES6/ES2015 核心内容（上）。如果不用数组解构的话，可以写成下面这样。实际上数组解构是一件开销很大的事情，用下面这种写法，或者改用对象解构，性能会有很大的提升。具体可以去这篇文章的分析 Array destructuring for multi-value returns (in light of React hooks)，这里不详细展开，我们就按照官方推荐使用数组解构就好。1234let _useState = useState(0);let count = _useState[0];let setCount = _useState[1];复制代码读取状态值12&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;复制代码是不是超简单？因为我们的状态 count 就是一个单纯的变量而已，我们再也不需要写成{this.state.count}这样了。更新状态1234 &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt;复制代码当用户点击按钮时，我们调用 setCount 函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给 react 了，react 将会重新渲染我们的 Example 组件，并且使用的是更新后的新的状态，即 count=1。这里我们要停下来思考一下，Example 本质上也是一个普通的函数，为什么它可以记住之前的状态？一个至关重要的问题这里我们就发现了问题，通常来说我们在一个函数中声明的变量，当函数运行完成后，这个变量也就销毁了（这里我们先不考虑闭包等情况），比如考虑下面的例子：123456789function add(n) &#123; const result = 0; return result + 1;&#125;add(1); //1add(1); //1复制代码不管我们反复调用 add 函数多少次，结果都是 1。因为每一次我们调用 add 时，result 变量都是从初始值 0 开始的。那为什么上面的 Example 函数每次执行的时候，都是拿的上一次执行完的状态值作为初始值？答案是：是 react 帮我们记住的。至于 react 是用什么机制记住的，我们可以再思考一下。假如一个组件有多个状态值怎么办？首先，useState 是可以多次调用的，所以我们完全可以这样写：12345function ExampleWithManyStates() &#123; const [age, setAge] = useState(42); const [fruit, setFruit] = useState(&apos;banana&apos;); const [todos, setTodos] = useState([&#123; text: &apos;Learn Hooks&apos; &#125;]);复制代码其次，useState 接收的初始值没有规定一定要是 string/number/boolean 这种简单数据类型，它完全可以接收对象或者数组作为参数。唯一需要注意的点是，之前我们的this.setState做的是合并状态后返回一个新状态，而useState是直接替换老状态后返回新状态。最后，react 也给我们提供了一个 useReducer 的 hook，如果你更喜欢 redux 式的状态管理方案的话。从 ExampleWithManyStates 函数我们可以看到，useState 无论调用多少次，相互之间是独立的。这一点至关重要。为什么这么说呢？其实我们看 hook 的 “形态”，有点类似之前被官方否定掉的 Mixins 这种方案，都是提供一种“插拔式的功能注入” 的能力。而 mixins 之所以被否定，是因为 Mixins 机制是让多个 Mixins 共享一个对象的数据空间，这样就很难确保不同 Mixins 依赖的状态不发生冲突。而现在我们的 hook，一方面它是直接用在 function 当中，而不是 class；另一方面每一个 hook 都是相互独立的，不同组件调用同一个 hook 也能保证各自状态的独立性。这就是两者的本质区别了。react 是怎么保证多个 useState 的相互独立的？还是看上面给出的 ExampleWithManyStates 例子，我们调用了三次 useState，每次我们传的参数只是一个值（如 42，‘banana’），我们根本没有告诉 react 这些值对应的 key 是哪个，那 react 是怎么保证这三个 useState 找到它对应的 state 呢？答案是，react 是根据 useState 出现的顺序来定的。我们具体来看一下：12345678910 //第一次渲染 useState(42); //将age初始化为42 useState(&apos;banana&apos;); //将fruit初始化为banana useState([&#123; text: &apos;Learn Hooks&apos; &#125;]); //... //第二次渲染 useState(42); //读取状态变量age的值（这时候传的参数42直接被忽略） useState(&apos;banana&apos;); //读取状态变量fruit的值（这时候传的参数banana直接被忽略） useState([&#123; text: &apos;Learn Hooks&apos; &#125;]); //...复制代码假如我们改一下代码：1234567891011let showFruit = true;function ExampleWithManyStates() &#123; const [age, setAge] = useState(42); if(showFruit) &#123; const [fruit, setFruit] = useState(&apos;banana&apos;); showFruit = false; &#125; const [todos, setTodos] = useState([&#123; text: &apos;Learn Hooks&apos; &#125;]);复制代码这样一来，12345678910 //第一次渲染 useState(42); //将age初始化为42 useState(&apos;banana&apos;); //将fruit初始化为banana useState([&#123; text: &apos;Learn Hooks&apos; &#125;]); //... //第二次渲染 useState(42); //读取状态变量age的值（这时候传的参数42直接被忽略） // useState(&apos;banana&apos;); useState([&#123; text: &apos;Learn Hooks&apos; &#125;]); //读取到的却是状态变量fruit的值，导致报错复制代码鉴于此，react 规定我们必须把 hooks 写在函数的最外层，不能写在 ifelse 等条件语句当中，来确保 hooks 的执行顺序一致。什么是 Effect Hooks?我们在上一节的例子中增加一个新功能：123456789101112131415161718192021import &#123; useState, useEffect &#125; from &apos;react&apos;;function Example() &#123; const [count, setCount] = useState(0); // 类似于componentDidMount 和 componentDidUpdate: useEffect(() =&gt; &#123; // 更新文档的标题 document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;复制代码我们对比着看一下，如果没有 hooks，我们会怎么写？1234567891011121314151617181920212223242526272829class Example extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; componentDidMount() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; componentDidUpdate() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;复制代码我们写的有状态组件，通常会产生很多的副作用（side effect），比如发起 ajax 请求获取数据，添加一些监听的注册和取消注册，手动修改 dom 等等。我们之前都把这些副作用的函数写在生命周期函数钩子里，比如 componentDidMount，componentDidUpdate 和 componentWillUnmount。而现在的 useEffect 就相当与这些声明周期函数钩子的集合体。它以一抵三。同时，由于前文所说 hooks 可以反复多次使用，相互独立。所以我们合理的做法是，给每一个副作用一个单独的 useEffect 钩子。这样一来，这些副作用不再一股脑堆在生命周期钩子里，代码变得更加清晰。useEffect 做了什么？我们再梳理一遍下面代码的逻辑：1234567function Example() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;);复制代码首先，我们声明了一个状态变量count，将它的初始值设为 0。然后我们告诉 react，我们的这个组件有一个副作用。我们给useEffecthook 传了一个匿名函数，这个匿名函数就是我们的副作用。在这个例子里，我们的副作用是调用 browser API 来修改文档标题。当 react 要渲染我们的组件时，它会先记住我们用到的副作用。等 react 更新了 DOM 之后，它再依次执行我们定义的副作用函数。这里要注意几点： 第一，react 首次渲染和之后的每次渲染都会调用一遍传给 useEffect 的函数。而之前我们要用两个声明周期函数来分别表示首次渲染（componentDidMount），和之后的更新导致的重新渲染（componentDidUpdate）。第二，useEffect 中定义的副作用函数的执行不会阻碍浏览器更新视图，也就是说这些函数是异步执行的，而之前的 componentDidMount 或 componentDidUpdate 中的代码则是同步执行的。这种安排对大多数副作用说都是合理的，但有的情况除外，比如我们有时候需要先根据 DOM 计算出某个元素的尺寸再重新渲染，这时候我们希望这次重新渲染是同步发生的，也就是说它会在浏览器真的去绘制这个页面前发生。useEffect 怎么解绑一些副作用这种场景很常见，当我们在 componentDidMount 里添加了一个注册，我们得马上在 componentWillUnmount 中，也就是组件被注销之前清除掉我们添加的注册，否则内存泄漏的问题就出现了。怎么清除呢？让我们传给 useEffect 的副作用函数返回一个新的函数即可。这个新的函数将会在组件下一次重新渲染之后执行。这种模式在一些 pubsub 模式的实现中很常见。看下面的例子：1234567891011121314151617181920212223import &#123; useState, useEffect &#125; from &apos;react&apos;;function FriendStatus(props) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); // 一定注意下这个顺序：告诉react在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus之前执行cleanup return function cleanup() &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); if (isOnline === null) &#123; return &apos;Loading...&apos;; &#125; return isOnline ? &apos;Online&apos; : &apos;Offline&apos;;&#125;复制代码这里有一个点需要重视！这种解绑的模式跟 componentWillUnmount 不一样。componentWillUnmount 只会在组件被销毁前执行一次而已，而 useEffect 里的函数，每次组件渲染后都会执行一遍，包括副作用函数返回的这个清理函数也会重新执行一遍。所以我们一起来看一下下面这个问题。为什么要让副作用函数每次组件更新都执行一遍？我们先看以前的模式：1234567891011121314 componentDidMount() &#123; ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; componentWillUnmount() &#123; ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125;复制代码很清除，我们在 componentDidMount 注册，再在 componentWillUnmount 清除注册。但假如这时候props.friend.id变了怎么办？我们不得不再添加一个 componentDidUpdate 来处理这种情况：123456789101112131415... componentDidUpdate(prevProps) &#123; // 先把上一个friend.id解绑 ChatAPI.unsubscribeFromFriendStatus( prevProps.friend.id, this.handleStatusChange ); // 再重新注册新但friend.id ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125;...复制代码看到了吗？很繁琐，而我们但 useEffect 则没这个问题，因为它在每次组件更新后都会重新执行一遍。所以代码的执行顺序是这样的：1234567891.页面首次渲染2.替friend.id=1的朋友注册3.突然friend.id变成了24.页面重新渲染5.清除friend.id=1的绑定6.替friend.id=2的朋友注册...复制代码怎么跳过一些不必要的副作用函数按照上一节的思路，每次重新渲染都要执行一遍这些副作用函数，显然是不经济的。怎么跳过一些不必要的计算呢？我们只需要给 useEffect 传第二个参数即可。用第二个参数来告诉 react 只有当这个参数的值发生改变时，才执行我们传的副作用函数（第一个参数）。1234useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // 只有当count的值发生变化时，才会重新执行`document.title`这一句复制代码当我们第二个参数传一个空数组 [] 时，其实就相当于只在首次渲染的时候执行。也就是 componentDidMount 加 componentWillUnmount 的模式。不过这种用法可能带来 bug，少用。还有哪些自带的 Effect Hooks?除了上文重点介绍的 useState 和 useEffect，react 还给我们提供来很多有用的 hooks：useContext useReducer useCallback useMemo useRef useImperativeMethods useMutationEffect useLayoutEffect我不再一一介绍，大家自行去查阅官方文档。怎么写自定义的 Effect Hooks?为什么要自己去写一个 Effect Hooks? 这样我们才能把可以复用的逻辑抽离出来，变成一个个可以随意插拔的 “插销”，哪个组件要用来，我就插进哪个组件里，so easy！看一个完整的例子，你就明白了。比如我们可以把上面写的 FriendStatus 组件中判断朋友是否在线的功能抽出来，新建一个 useFriendStatus 的 hook 专门用来判断某个 id 是否在线。12345678910111213141516171819import &#123; useState, useEffect &#125; from &apos;react&apos;;function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); &#125;; &#125;); return isOnline;&#125;复制代码这时候 FriendStatus 组件就可以简写为：123456789function FriendStatus(props) &#123; const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) &#123; return &apos;Loading...&apos;; &#125; return isOnline ? &apos;Online&apos; : &apos;Offline&apos;;&#125;复制代码简直 Perfect！假如这个时候我们又有一个朋友列表也需要显示是否在线的信息：12345678910function FriendListItem(props) &#123; const isOnline = useFriendStatus(props.friend.id); return ( &lt;li style=&#123;&#123; color: isOnline ? &apos;green&apos; : &apos;black&apos; &#125;&#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; );&#125;复制代码简直 Fabulous!结尾不知道你阅读完整篇文章的感受如何，或者对 hooks 有任何角度的看法和思考都欢迎在评论区一起讨论。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git 设置代理和取消代理]]></title>
    <url>%2Farchives%2Fa16d.html</url>
    <content type="text"><![CDATA[如果代理类型是 socks5 进行如下设置即可：12git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080如果是普通的 http/https 进行如下设置即可：12git config --global https.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080取消代理设置：12git config --global --unset http.proxygit config --global --unset https.proxy]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈 React 性能优化的方向]]></title>
    <url>%2Farchives%2F6df4.html</url>
    <content type="text"><![CDATA[本文由 简悦 SimpRead 转码， 原文地址 https://juejin.im/post/5d045350f265da1b695d5bf2本文来源于公司内部的一次闪电分享，稍作润色分享出来。主要讨论 React 性能优化的主要方向和一些小技巧。如果你觉得可以，请多点赞，鼓励我写出更精彩的文章🙏。React 渲染性能优化的三个方向，其实也适用于其他软件开发领域，这三个方向分别是:减少计算的量。 -&gt; 对应到 React 中就是减少渲染的节点 或者 降低组件渲染的复杂度利用缓存。-&gt; 对应到 React 中就是如何避免重新渲染，利用函数式编程的 memo 方式来避免组件重新渲染精确重新计算的范围。 对应到 React 中就是绑定组件和状态关系, 精确判断更新的’时机’和’范围’. 只重新渲染’脏’的组件，或者说降低渲染范围目录减少渲染的节点 / 降低渲染计算量 (复杂度)0️⃣ 不要在渲染函数都进行不必要的计算1️⃣ 减少不必要的嵌套2️⃣ 虚拟列表3️⃣ 惰性渲染4️⃣ 选择合适的样式方案避免重新渲染0️⃣ 简化 props1️⃣ 不变的事件处理器2️⃣ 不可变数据3️⃣ 简化 state4️⃣ 使用 recompose 精细化比对精细化渲染0️⃣ 响应式数据的精细化渲染1️⃣ 不要滥用 Context扩展减少渲染的节点 / 降低渲染计算量 (复杂度)首先从计算的量上下功夫，减少节点渲染的数量或者降低渲染的计算量可以显著的提高组件渲染性能。0️⃣ 不要在渲染函数都进行不必要的计算比如不要在渲染函数 (render) 中进行数组排序、数据转换、订阅事件、创建事件处理器等等. 渲染函数中不应该放置太多副作用1️⃣ 减少不必要的嵌套我们团队是重度的 styled-components 用户，其实大部分情况下我们都不需要这个玩意，比如纯静态的样式规则，以及需要重度性能优化的场景。除了性能问题，另外一个困扰我们的是它带来的节点嵌套地狱 (如上图)。所以我们需要理性地选择一些工具，比如使用原生的 CSS，减少 React 运行时的负担.一般不必要的节点嵌套都是滥用高阶组件 / RenderProps 导致的。所以还是那句话‘只有在必要时才使用 xxx’。 有很多种方式来代替高阶组件 / RenderProps，例如优先使用 props、React Hooks2️⃣ 虚拟列表虚拟列表是常见的‘长列表’和’复杂组件树’优化方式，它优化的本质就是减少渲染的节点。虚拟列表只渲染当前视口可见元素:虚拟列表渲染性能对比:虚拟列表常用于以下组件场景:无限滚动列表，grid, 表格，下拉列表，spreadsheets无限切换的日历或轮播图大数据量或无限嵌套的树聊天窗，数据流 (feed), 时间轴等等相关组件方案:react-virtualizedreact-window 更轻量的 react-virtualized, 同出一个作者更多扩展：Creating more efficient React views with windowingRendering large lists with react-window3️⃣ 惰性渲染惰性渲染的初衷本质上和虚表一样，也就是说我们只在必要时才去渲染对应的节点。举个典型的例子，我们常用 Tab 组件，我们没有必要一开始就将所有 Tab 的 panel 都渲染出来，而是等到该 Tab 被激活时才去惰性渲染。还有很多场景会用到惰性渲染，例如树形选择器，模态弹窗，下拉列表，折叠组件等等。这里就不举具体的代码例子了，留给读者去思考.4️⃣ 选择合适的样式方案如图 (图片来源于 THE PERFORMANCE OF STYLED REACT COMPONENTS), 这个图片是 17 年的了，但是大抵的趋势还是这样。所以在样式运行时性能方面大概可以总结为：CSS &gt; 大部分CSS-in-js &gt; inline style避免重新渲染减少不必要的重新渲染也是 React 组件性能优化的重要方向. 为了避免不必要的组件重新渲染需要在做到两点:保证组件纯粹性。即控制组件的副作用，如果组件有副作用则无法安全地缓存渲染结果通过shouldComponentUpdate生命周期函数来比对 state 和 props, 确定是否要重新渲染。对于函数组件可以使用React.memo包装另外这些措施也可以帮助你更容易地优化组件重新渲染:0️⃣ 简化 props① 如果一个组件的 props 太复杂一般意味着这个组件已经违背了‘单一职责’，首先应该尝试对组件进行拆解. ② 另外复杂的 props 也会变得难以维护, 比如会影响shallowCompare效率, 还会让组件的变动变得难以预测和调试.下面是一个典型的例子, 为了判断列表项是否处于激活状态，这里传入了一个当前激活的 id:这是一个非常糟糕的设计，一旦激活 id 变动，所有列表项都会重新刷新. 更好的解决办法是使用类似actived这样的布尔值 prop. actived 现在只有两种变动情况，也就是说激活 id 的变动，最多只有两个组件需要重新渲染.简化的 props 更容易理解, 且可以提高组件缓存的命中率1️⃣ 不变的事件处理器①避免使用箭头函数形式的事件处理器, 例如:12&lt;ComplexComponent onClick=&#123;evt =&gt; onClick(evt.id)&#125; otherProps=&#123;values&#125; /&gt;复制代码假设 ComplexComponent 是一个复杂的 PureComponent, 这里使用箭头函数，其实每次渲染时都会创建一个新的事件处理器，这会导致 ComplexComponent 始终会被重新渲染.更好的方式是使用实例方法:123456789class MyComponent extends Component &#123; render() &#123; &lt;ComplexComponent onClick=&#123;this.handleClick&#125; otherProps=&#123;values&#125; /&gt;; &#125; handleClick = () =&gt; &#123; /*...*/ &#125;;&#125;复制代码② 即使现在使用hooks，我依然会使用useCallback来包装事件处理器，尽量给下级组件暴露一个静态的函数:123456const handleClick = useCallback(() =&gt; &#123; /*...*/&#125;, []);return &lt;ComplexComponent onClick=&#123;handleClick&#125; otherProps=&#123;values&#125; /&gt;;复制代码但是如果useCallback依赖于很多状态，你的useCallback可能会变成这样:12345const handleClick = useCallback(() =&gt; &#123; /*...*/ // 🤭&#125;, [foo, bar, baz, bazz, bazzzz]);复制代码这种写法实在让人难以接受，这时候谁还管什么函数式非函数式的。我是这样处理的:123456789101112131415161718function useRefProps&lt;T&gt;(props: T) &#123; const ref = useRef &lt; T &gt; props; // 每次渲染更新props useEffect(() =&gt; &#123; ref.current = props; &#125;);&#125;function MyComp(props) &#123; const propsRef = useRefProps(props); // 现在handleClick是始终不变的 const handleClick = useCallback(() =&gt; &#123; const &#123; foo, bar, baz, bazz, bazzzz &#125; = propsRef.current; // do something &#125;, []);&#125;复制代码③设计更方便处理的 Event Props. 有时候我们会被逼的不得不使用箭头函数来作为事件处理器：123456&lt;List&gt; &#123;list.map(i =&gt; ( &lt;Item key=&#123;i.id&#125; onClick=&#123;() =&gt; handleDelete(i.id)&#125; value=&#123;i.value&#125; /&gt; ))&#125;&lt;/List&gt;复制代码上面的 onClick 是一个糟糕的实现，它没有携带任何信息来标识事件来源，所以这里只能使用闭包形式，更好的设计可能是这样的:12345678910111213// onClick传递事件来源信息const handleDelete = useCallback((id: string) =&gt; &#123; /*删除操作*/&#125;, []);return ( &lt;List&gt; &#123;list.map(i =&gt; ( &lt;Item key=&#123;i.id&#125; id=&#123;i.id&#125; onClick=&#123;handleDelete&#125; value=&#123;i.value&#125; /&gt; ))&#125; &lt;/List&gt;);复制代码如果是第三方组件或者 DOM 组件呢? 实在不行，看能不能传递data-*属性:12345678910111213const handleDelete = useCallback(event =&gt; &#123; const id = event.dataset.id; /*删除操作*/&#125;, []);return ( &lt;ul&gt; &#123;list.map(i =&gt; ( &lt;li key=&#123;i.id&#125; data-id=&#123;i.id&#125; onClick=&#123;handleDelete&#125; value=&#123;i.value&#125; /&gt; ))&#125; &lt;/ul&gt;);复制代码2️⃣ 不可变数据不可变数据可以让状态变得可预测，也让 shouldComponentUpdate ‘浅比较’变得更可靠和高效. 笔者在 React 组件设计实践总结 04 - 组件的思维介绍过不可变数据，有兴趣读者可以看看.相关的工具有 Immutable.js、Immer、immutability-helper 以及 seamless-immutable。3️⃣ 简化 state不是所有状态都应该放在组件的 state 中. 例如缓存数据。按照我的原则是：如果需要组件响应它的变动, 或者需要渲染到视图中的数据才应该放到 state 中。这样可以避免不必要的数据变动导致组件重新渲染.4️⃣ 使用 recompose 精细化比对尽管 hooks 出来后，recompose 宣称不再更新了，但还是不影响我们使用 recompose 来控制shouldComponentUpdate方法, 比如它提供了以下方法来精细控制应该比较哪些 props:1234567 /* 相当于React.memo */ pure() /* 自定义比较 */ shouldUpdate(test: (props: Object, nextProps: Object) =&gt; boolean): HigherOrderComponent /* 只比较指定key */ onlyUpdateForKeys( propKeys: Array&lt;string&gt;): HigherOrderComponent复制代码其实还可以再扩展一下，比如omitUpdateForKeys忽略比对某些 key.精细化渲染所谓精细化渲染指的是只有一个数据来源导致组件重新渲染, 比如说 A 只依赖于 a 数据，那么只有在 a 数据变动时才渲染 A, 其他状态变化不应该影响组件 A。Vue 和 Mobx 宣称自己性能好的一部分原因是它们的’响应式系统’, 它允许我们定义一些‘响应式数据’，当这些响应数据变动时，依赖这些响应式数据视图就会重新渲染. 来看看 Vue 官方是如何描述的:0️⃣ 响应式数据的精细化渲染大部分情况下，响应式数据可以实现视图精细化的渲染, 但它还是不能避免开发者写出低效的程序. 本质上还是因为组件违背‘单一职责’.举个例子，现在有一个 MyComponent 组件，依赖于 A、B、C 三个数据源，来构建一个 vdom 树。现在的问题是什么呢？现在只要 A、B、C 任意一个变动，那么 MyComponent 整个就会重新渲染:更好的做法是让组件的职责更单一，精细化地依赖响应式数据，或者说对响应式数据进行‘隔离’. 如下图, A、B、C 都抽取各自的组件中了，现在 A 变动只会渲染 A 组件本身，而不会影响父组件和 B、C 组件:举一个典型的例子，列表渲染:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React from &apos;react&apos;;import &#123; observable &#125; from &apos;mobx&apos;;import &#123; observer &#125; from &apos;mobx-react-lite&apos;;const initialList = [];for (let i = 0; i &lt; 10; i++) &#123; initialList.push(&#123; id: i, name: `name-$&#123;i&#125;`, value: 0 &#125;);&#125;const store = observable(&#123; list: initialList,&#125;);export const List = observer(() =&gt; &#123; const list = store.list; console.log(&apos;List渲染&apos;); return ( &lt;div class&gt; &lt;ul&gt; &#123;list.map((i, idx) =&gt; ( &lt;div class key=&#123;i.id&#125;&gt; &#123;/* 假设这是一个复杂的组件 */&#125; &#123;console.log(&apos;render&apos;, i.id)&#125; &lt;span class&gt;&#123;i.name&#125; &lt;/span&gt; &lt;span class&gt;&#123;i.value&#125; &lt;/span&gt; &lt;button class onClick=&#123;() =&gt; &#123; i.value++; console.log(&apos;递增&apos;); &#125;&#125; &gt; 递增 &lt;/button&gt; &lt;button class onClick=&#123;() =&gt; &#123; if (idx &lt; list.length - 1) &#123; console.log(&apos;移位&apos;); let t = list[idx]; list[idx] = list[idx + 1]; list[idx + 1] = t; &#125; &#125;&#125; &gt; 下移 &lt;/button&gt; &lt;/div&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; );&#125;);复制代码上述的例子是存在性能问题的，单个 list-item 的递增和移位都会导致整个列表的重新渲染:原因大概能猜出来吧? 对于 Vue 或者 Mobx 来说，一个组件的渲染函数就是一个依赖收集的上下文。上面 List 组件渲染函数内’访问’了所有的列表项数据，那么 Vue 或 Mobx 就会认为你这个组件依赖于所有的列表项，这样就导致，只要任意一个列表项的属性值变动就会重新渲染整个 List 组件。解决办法也很简单，就是将数据隔离抽取到单一职责的组件中。对于 Vue 或 Mobx 来说，越细粒度的组件，可以收获更高的性能优化效果:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export const ListItem = observer(props =&gt; &#123; const &#123; item, onShiftDown &#125; = props; return ( &lt;div class&gt; &#123;console.log(&apos;render&apos;, item.id)&#125; &#123;/* 假设这是一个复杂的组件 */&#125; &lt;span class&gt;&#123;item.name&#125; &lt;/span&gt; &lt;span class&gt;&#123;item.value&#125; &lt;/span&gt; &lt;button class onClick=&#123;() =&gt; &#123; item.value++; console.log(&apos;递增&apos;); &#125;&#125; &gt; 递增 &lt;/button&gt; &lt;button class onClick=&#123;() =&gt; onShiftDown(item)&#125;&gt; 下移 &lt;/button&gt; &lt;/div&gt; );&#125;);export const List = observer(() =&gt; &#123; const list = store.list; const handleShiftDown = useCallback(item =&gt; &#123; const idx = list.findIndex(i =&gt; i.id === item.id); if (idx !== -1 &amp;&amp; idx &lt; list.length - 1) &#123; console.log(&apos;移位&apos;); let t = list[idx]; list[idx] = list[idx + 1]; list[idx + 1] = t; &#125; // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, []); console.log(&apos;List 渲染&apos;); return ( &lt;div class&gt; &lt;ul&gt; &#123;list.map((i, idx) =&gt; ( &lt;ListItem key=&#123;i.id&#125; item=&#123;i&#125; onShiftDown=&#123;handleShiftDown&#125; /&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; );&#125;);复制代码效果很明显, list-item 递增只会重新渲染本身; 而移位只会重新渲染 List， 因为列表项没有变动, 所以下级 list-item 也不需要重新渲染:1️⃣ 不要滥用 Context其实 Context 的用法和响应式数据正好相反。笔者也看过不少滥用 Context API 的例子, 说到底还是没有处理好‘状态的作用域问题’.首先要理解 Context API 的更新特点，它是可以穿透React.memo或者shouldComponentUpdate的比对的，也就是说，一旦 Context 的 Value 变动，所有依赖该 Context 的组件会全部 forceUpdate.这个和 Mobx 和 Vue 的响应式系统不同，Context API 并不能细粒度地检测哪些组件依赖哪些状态，所以说上节提到的‘精细化渲染’组件模式，在 Context 这里就成为了‘反模式’.总结一下使用 Context API 要遵循一下原则:明确状态作用域, Context 只放置必要的，关键的，被大多数组件所共享的状态。比较典型的是鉴权状态举一个简单的例子:扩展：Context 其实有个实验性或者说非公开的选项observedBits, 可以用于控制 ContextConsumer 是否需要更新. 详细可以看这篇文章 &lt;ObservedBits: React Context 的秘密功能 &gt;. 不过不推荐在实际项目中使用，而且这个 API 也比较难用，不如直接上 mobx。粗粒度地订阅 Context如下图. 细粒度的 Context 订阅会导致不必要的重新渲染, 所以这里推荐粗粒度的订阅. 比如在父级订阅 Context，然后再通过 props 传递给下级。另外程墨 Morgan 在避免 React Context 导致的重复渲染一文中也提到 ContextAPI 的一个陷阱:123456789&lt;Context.Provider value=&#123;&#123; theme: this.state.theme, switchTheme: this.switchTheme &#125;&#125;&gt; &lt;div class&gt; &lt;Header /&gt; &lt;Content /&gt; &lt;/div&gt;&lt;/Context.Provider&gt;复制代码上面的组件会在 state 变化时重新渲染整个组件树，至于为什么留给读者去思考。所以我们一般都不会裸露地使用 Context.Provider, 而是封装为独立的 Provider 组件:1234567891011121314export function ThemeProvider(props) &#123; const [theme, switchTheme] = useState(redTheme); return ( &lt;Context.Provider value=&#123;&#123; theme, switchTheme &#125;&#125;&gt; &#123;props.children&#125; &lt;/Context.Provider&gt; );&#125;// 顺便暴露useTheme, 让外部必须直接使用Contextexport function useTheme() &#123; return useContext(Context);&#125;复制代码现在 theme 变动就不会重新渲染整个组件树，因为 props.children 由外部传递进来，并没有发生变动。其实上面的代码还有另外一个比较难发现的陷阱 (官方文档也有提到):1234567891011export function ThemeProvider(props) &#123; const [theme, switchTheme] = useState(redTheme); return ( &#123;/* 👇 💣这里每一次渲染ThemeProvider, 都会创建一个新的value(即使theme和switchTheme没有变动), 从而导致强制渲染所有依赖该Context的组件 */&#125; &lt;Context.Provider value=&#123;&#123; theme, switchTheme &#125;&#125;&gt; &#123;props.children&#125; &lt;/Context.Provider&gt; );&#125;复制代码所以传递给 Context 的 value 最好做一下缓存:123456export function ThemeProvider(props) &#123; const [theme, switchTheme] = useState(redTheme); const value = useMemo(() =&gt; (&#123; theme, switchTheme &#125;), [theme]); return &lt;Context.Provider value=&#123;value&#125;&gt;&#123;props.children&#125;&lt;/Context.Provider&gt;;&#125;复制代码扩展Optimizing Performance React 官方文档，最好的教程, 利用好 React 的性能分析工具。Twitter Lite and High Performance React Progressive Web Apps at Scale 看看 Twitter 如何优化的]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精读《Function VS Class 组件》]]></title>
    <url>%2Farchives%2Fecb7.html</url>
    <content type="text"><![CDATA[本文由 简悦 SimpRead 转码， 原文地址 https://zhuanlan.zhihu.com/p/59558396引言为什么要了解 Function 写法的组件呢？因为它正在变得越来越重要。那么 React 中 Function Component 与 Class Component 有何不同？how-are-function-components-different-from-classes 这篇文章带来了一个独特的视角。顺带一提，以后会用 Function Component 代替 Stateless Component 的说法，原因是：自从 Hooks 出现，函数式组件功能在不断丰富，函数式组件不再需要强调其无状态特性，因此叫 Function Component 更为恰当。概述原文事先申明：并没有对 Function 与 Classes 进行优劣对比，而仅仅进行特性对比，所以不接受任何吐槽。这两种写法没有好坏之分，性能差距也几乎可以忽略，而且 React 会长期支持这两种写法。Capture props对比下面两段代码。Class Component:12345678910111213class ProfilePage extends React.Component &#123; showMessage = () =&gt; &#123; alert(&quot;Followed &quot; + this.props.user); &#125;; handleClick = () =&gt; &#123; setTimeout(this.showMessage, 3000); &#125;; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125;Function Component:1234567891011function ProfilePage(props) &#123; const showMessage = () =&gt; &#123; alert(&quot;Followed &quot; + props.user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt;;&#125;（在线 Demo）这两个组件都描述了同一个逻辑：点击按钮 3 秒后 alert 父级传入的用户名。如下父级组件的调用方式：12&lt;ProfilePageFunction user=&#123;this.state.user&#125; /&gt;&lt;ProfilePageClass user=&#123;this.state.user&#125; /&gt;那么当点击按钮后的 3 秒内，父级修改了 this.state.user，弹出的用户名是修改前的还是修改后的呢？Class Component 展示的是修改后的值：&lt;img src=”https://pic4.zhimg.com/v2-9d9d77bb138395301509792d9ae9acbf_b.gif“ data-caption=””data-size=”normal”data-rawwidth=”950”data-rawheight=”351”data-thumbnail=”https://pic4.zhimg.com/v2-9d9d77bb138395301509792d9ae9acbf_b.jpg“width=”950”data-original=”https://pic4.zhimg.com/v2-9d9d77bb138395301509792d9ae9acbf_r.jpg“/&gt;Function Component 展示的是修改前的值：&lt;img src=”https://pic3.zhimg.com/v2-84396c4b3982827bead96912a947904e_b.gif“ data-caption=””data-size=”normal”data-rawwidth=”901”data-rawheight=”293”data-thumbnail=”https://pic3.zhimg.com/v2-84396c4b3982827bead96912a947904e_b.jpg“width=”901”data-original=”https://pic3.zhimg.com/v2-84396c4b3982827bead96912a947904e_r.jpg“/&gt;那么 React 文档中描述的 props 不是不可变（Immutable） 数据吗？为啥在运行时还会发生变化呢？原因在于，虽然 props 不可变，是 this 在 Class Component 中是可变的，因此 this.props 的调用会导致每次都访问最新的 props。而 Function Component 不存在 this.props 的语法，因此 props 总是不可变的。为了便于理解，笔者补充一些代码注解：Function Component:123456function ProfilePage(props) &#123; setTimeout(() =&gt; &#123; // 就算父组件 reRender，这里拿到的 props 也是初始的 console.log(props); &#125;, 3000);&#125;Class Component:123456789class ProfilePage extends React.Component &#123; render() &#123; setTimeout(() =&gt; &#123; // 如果父组件 reRender，this.props 拿到的永远是最新的。 // 并不是 props 变了，而是 this.props 指向了新的 props，旧的 props 找不到了 console.log(this.props); &#125;, 3000); &#125;&#125;如果希望在 Class Component 捕获瞬时 Props，可以： const props = this.props;，但这样的代码很蹩脚，所以如果希望拿到稳定的 props，使用 Function Component 是更好的选择。Hooks 也具有 capture value 特性看下面的代码：12345678910111213141516171819202122function MessageThread() &#123; const [message, setMessage] = useState(&quot;&quot;); const showMessage = () =&gt; &#123; alert(&quot;You said: &quot; + message); &#125;; const handleSendClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; const handleMessageChange = e =&gt; &#123; setMessage(e.target.value); &#125;; return ( &lt;&gt; &lt;input value=&#123;message&#125; onChange=&#123;handleMessageChange&#125; /&gt; &lt;button onClick=&#123;handleSendClick&#125;&gt;Send&lt;/button&gt; &lt;/&gt; );&#125;（在线 Demo）在点击 Send 按钮后，再次修改输入框的值，3 秒后的输出依然是 点击前输入框的值。这说明 Hooks 同样具有 capture value 的特性。利用 useRef 可以规避 capture value 特性：123456789101112131415function MessageThread() &#123; const latestMessage = useRef(&quot;&quot;); const showMessage = () =&gt; &#123; alert(&quot;You said: &quot; + latestMessage.current); &#125;; const handleSendClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; const handleMessageChange = e =&gt; &#123; latestMessage.current = e.target.value; &#125;;&#125;只要将赋值与取值的对象变成 useRef，而不是 useState，就可以躲过 capture value 特性，在 3 秒后得到最新的值。这说明了利用 Function Component + Hooks 可以实现 Class Component 做不到的 capture props、capture value，而且 React 官方也推荐 新的代码使用 Hooks 编写。精读原文 how-are-function-components-different-from-classes 从一个侧面讲述了 Function Component 与 Class Component 的不同点，之所以将 Function Component 与 Class Component 相提并论，几乎都要归功于 Hooks API 的出现，有了 Hooks，Function Component 的能力才得以向 Class Component 看齐。关于 React Hooks，之前的两篇精读分别有过介绍：精读《React Hooks》精读《怎么用 React Hooks 造轮子》但是，虽然 Hook 已经发布了稳定版本，但周边生态跟进还需要时间（比如 useRouter）、最佳实践整理还需要时间，因此不建议重构老代码。为了更好的使用 Function Component，建议时常与 Class Component 的功能做对比，方便理解和记忆。下面整理一些常见的 Function Component 问题：非常建议完整阅读 React Hooks FAQ。怎么替代 shouldComponentUpdate说实话，Function Component 替代 shouldComponentUpdate 的方案并没有 Class Component 优雅，代码是这样的：123const Button = React.memo(props =&gt; &#123; // your component&#125;);或者在父级就直接生成一个自带 memo 的子元素：123456789101112function Parent(&#123; a, b &#125;) &#123; // Only re-rendered if `a` changes: const child1 = useMemo(() =&gt; &lt;Child1 a=&#123;a&#125; /&gt;, [a]); // Only re-rendered if `b` changes: const child2 = useMemo(() =&gt; &lt;Child2 b=&#123;b&#125; /&gt;, [b]); return ( &lt;&gt; &#123;child1&#125; &#123;child2&#125; &lt;/&gt; );&#125;相比之下，Class Component 的写法通常是：1class Button extends React.PureComponent &#123;&#125;这样就自带了 shallowEqual 的 shouldComponentUpdate。怎么替代 componentDidUpdate由于 useEffect 每次 Render 都会执行，因此需要模拟一个 useUpdate 函数：12345678const mounting = useRef(true);useEffect(() =&gt; &#123; if (mounting.current) &#123; mounting.current = false; &#125; else &#123; fn(); &#125;&#125;);更多可以查看 精读《怎么用 React Hooks 造轮子》怎么替代 forceUpdateReact 官方文档提供了一种方案：12345const [ignored, forceUpdate] = useReducer(x =&gt; x + 1, 0);function handleClick() &#123; forceUpdate();&#125;每次执行 dispatch 时，只要 state 变化就会触发组件更新。当然 useState 也同样可以模拟：1const useUpdate = () =&gt; useState(0)[1];我们知道 useState 下标为 1 的项是用来更新数据的，而且就算数据没有变化，调用了也会刷新组件，所以我们可以把返回一个没有修改数值的 setValue，这样它的功能就仅剩下刷新组件了。更多可以查看 精读《怎么用 React Hooks 造轮子》state 拆分过多useState 目前的一种实践，是将变量名打平，而非像 Class Component 一样写在一个 State 对象里：1234567891011121314151617class ClassComponent extends React.PureComponent &#123; state = &#123; left: 0, top: 0, width: 100, height: 100 &#125;;&#125;// VSfunction FunctionComponent &#123; const [left,setLeft] = useState(0) const [top,setTop] = useState(0) const [width,setWidth] = useState(100) const [height,setHeight] = useState(100)&#125;实际上在 Function Component 中也可以聚合管理 State：12345678function FunctionComponent() &#123; const [state, setState] = useState(&#123; left: 0, top: 0, width: 100, height: 100 &#125;);&#125;只是更新的时候，不再会自动 merge，而需要使用 ...state 语法：1setState(state =&gt; (&#123; ...state, left: e.pageX, top: e.pageY &#125;));可以看到，更少的黑魔法，更可预期的结果。获取上一个 props虽然不怎么常用，但是毕竟 Class Component 可以通过 componentWillReceiveProps 拿到 previousProps 与 nextProps，对于 Function Component，最好通过自定义 Hooks 方式拿到上一个状态：1234567891011121314151617function Counter() &#123; const [count, setCount] = useState(0); const prevCount = usePrevious(count); return ( &lt;h1&gt; Now: &#123;count&#125;, before: &#123;prevCount&#125; &lt;/h1&gt; );&#125;function usePrevious(value) &#123; const ref = useRef(); useEffect(() =&gt; &#123; ref.current = value; &#125;); return ref.current;&#125;通过 useEffect 在组件渲染完毕后再执行的特性，再利用 useRef 的可变特性，让 usePrevious 的返回值是 “上一次” Render 时的。可见，合理运用 useEffect useRef，可以做许多事情，而且封装成 CustomHook 后使用起来仍然很方便。未来 usePrevious 可能成为官方 Hooks 之一。性能注意事项useState 函数的参数虽然是初始值，但由于整个函数都是 Render，因此每次初始化都会被调用，如果初始值计算非常消耗时间，建议使用函数传入，这样只会执行一次：123function FunctionComponent(props) &#123; const [rows, setRows] = useState(() =&gt; createRows(props.count));&#125;useRef 不支持这种特性，需要写一些冗余的函判定是否进行过初始化。掌握了这些，Function Component 使用起来与 Class Component 就几乎没有差别了！总结Function Component 功能已经可以与 Class Component 媲美了，但目前最佳实践比较零散，官方文档推荐的一些解决思路甚至不比社区第三方库的更好，可以预料到，Class Component 的功能会被五花八门的实现出来，那些没有被收纳进官方的 Hooks 乍看上去可能会眼花缭乱。总之选择了 Function Component 就同时选择了函数式的好与坏。好处是功能强大，几乎可以模拟出任何想要的功能，坏处是由于可以灵活组合，如果自定义 Hooks 命名和实现不够标准，函数与函数之间对接的沟通成本会更大。讨论地址是：精读《Stateless VS Class 组件》 · Issue #137 · dt-fe/weekly如果你想参与讨论，请 点击这里，每周都有新的主题，周末或周一发布。前端精读 - 帮你筛选靠谱的内容。关注 前端精读微信公众号&lt;img src=”https://pic3.zhimg.com/v2-d817340c54185469ec4df17c0938742e_b.jpg“ data-caption=””data-size=”normal”data-rawwidth=”258”data-rawheight=”258”width=”258”/&gt;special SponsorsDevOps 全流程平台版权声明：自由转载 - 非商用 - 非衍生 - 保持署名（创意共享 3.0 许可证）写下你的评论…在线 Demo 挂了~修复了class 的这个 bug Dan 好像提过 用 const {XXX} = this.props 可以解决你在文中好像提了 我没仔细看 不好意思那么问题来了，为什么要用 hooks…生命在于不息我觉得那段 props immutable 解释的是不是有点歧义。。比如，instance 的 this 是可变的，this 在完整的组件声明周期里并不会修改啊，只是 this 上的 props 可能会修改指向。然后。下文用 setTimeout 这段表达的其实是闭包针对变量的捕获吧，这个和是不是 immutable 关系并不大吧 （我觉得这里完全就是闭包的问题）？]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React Hooks</tag>
        <tag>React组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的工作原理：现代网络浏览器幕后揭秘]]></title>
    <url>%2Farchives%2F35c4.html</url>
    <content type="text"><![CDATA[本文由 简悦 SimpRead 转码， 原文地址 https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入 google.com 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。我们要讨论的浏览器目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera。本文中以开放源代码浏览器为例，即 Firefox、Chrome 浏览器和 Safari（部分开源）。根据 StatCounter 浏览器统计数据，目前（2011 年 8 月）Firefox、Safari 和 Chrome 浏览器的总市场占有率将近 60%。由此可见，如今开放源代码浏览器在浏览器市场中占据了非常坚实的部分。浏览器的主要功能浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。浏览器的用户界面有很多彼此相同的元素，其中包括：用来输入 URI 的地址栏前进和后退按钮书签设置选项用于刷新和停止加载当前文档的刷新和停止按钮用于返回主页的主页按钮奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。浏览器的高层结构浏览器的主要组件为 (1.1)：用户界面 - 包括地址栏、前进 / 后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。浏览器引擎 - 在用户界面和呈现引擎之间传送指令。呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。JavaScript 解释器。用于解析和执行 JavaScript 代码。数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了 “网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 图：浏览器的主要组件。值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。呈现引擎呈现引擎的作用嘛… 当然就是 “呈现” 了，也就是在浏览器的屏幕上显示请求的内容。默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。呈现引擎本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司 “自制” 的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。有关详情，请参阅 webkit.org。主流程呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。然后进行如下所示的基本流程： 图：呈现引擎的基本流程。呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成 “内容树” 上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。呈现树构建完毕之后，进入 “布局” 处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。主流程示例 图：WebKit 主流程 图：Mozilla 的 Gecko 呈现引擎主流程 (3.6)从图 3 和图 4 可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。Gecko 将视觉格式化元素组成的树称为 “框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它由“呈现对象” 组成。对于元素的放置，WebKit 使用的术语是 “布局”，而 Gecko 称之为“重排”。对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽” 的层，用于生成 DOM 元素。我们会逐一论述流程中的每一部分：解析 - 综述解析是呈现引擎中非常重要的一个环节，因此我们要更深入地讲解。首先，来介绍一下解析。解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。示例 - 解析 2 + 3 - 1 这个表达式，会返回下面的树： 图：数学表达式树节点语法解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础的。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为与上下文无关的语法。人类语言并不属于这样的语言，因此无法用常规的解析技术进行解析。解析器和词法分析器的组合解析的过程可以分成两个子过程：词法分析和语法分析。词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。语法分析是应用语言的语法规则的过程。解析器通常将解析工作分给以下两个组件来处理：词法分析器（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而解析器负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。 图：从源文档到解析树解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。翻译很多时候，解析树还不是最终产品。解析通常是在翻译过程中使用的，而翻译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。 图：编译流程解析示例在图 5 中，我们通过一个数学表达式建立了解析树。现在，让我们试着定义一个简单的数学语言，用来演示解析的过程。词汇：我们用的语言可包含整数、加号和减号。语法：构成语言的语法单位是表达式、项和运算符。我们用的语言可以包含任意数量的表达式。表达式的定义是：一个 “项” 接一个“运算符”，然后再接一个“项”。运算符是加号或减号。项是一个整数或一个表达式。让我们分析一下 2 + 3 - 1。匹配语法规则的第一个子串是 2，而根据第 5 条语法规则，这是一个项。匹配语法规则的第二个子串是 2 + 3，而根据第 3 条规则（一个项接一个运算符，然后再接一个项），这是一个表达式。下一个匹配项已经到了输入的结束。2 + 3 - 1 是一个表达式，因为我们已经知道 2 + 3 是一个项，这样就符合 “一个项接一个运算符，然后再接一个项” 的规则。2 + + 不与任何规则匹配，因此是无效的输入。词汇和语法的正式定义词汇通常用正则表达式表示。例如，我们的示例语言可以定义如下：123INTEGER :0|[1-9][0-9]*PLUS : +MINUS: -正如您所看到的，这里用正则表达式给出了整数的定义。语法通常使用一种称为 BNF 的格式来定义。我们的示例语言可以定义如下：123expression := term operation termoperation := PLUS | MINUSterm := INTEGER | expression之前我们说过，如果语言的语法是与上下文无关的语法，就可以由常规解析器进行解析。与上下文无关的语法的直观定义就是可以完全用 BNF 格式表达的语法。有关正式定义，请参阅关于与上下文无关的语法的维基百科文章。解析器类型有两种基本类型的解析器：自上而下解析器和自下而上解析器。直观地来说，自上而下的解析器从语法的高层结构出发，尝试从中找到匹配的结构。而自下而上的解析器从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则。让我们来看看这两种解析器会如何解析我们的示例：自上而下的解析器会从高层的规则开始：首先将 2 + 3 标识为一个表达式，然后将 2 + 3 - 1 标识为一个表达式（标识表达式的过程涉及到匹配其他规则，但是起点是最高级别的规则）。自下而上的解析器将扫描输入内容，找到匹配的规则后，将匹配的输入内容替换成规则。如此继续替换，直到输入内容的结尾。部分匹配的表达式保存在解析器的堆栈中。堆栈输入2 + 3 - 1项+ 3 - 1项运算3 - 1表达式- 1表达式运算符1表达式这种自下而上的解析器称为移位归约解析器，因为输入在向右移位（设想有一个指针从输入内容的开头移动到结尾），并且逐渐归约到语法规则上。自动生成解析器有一些工具可以帮助您生成解析器，它们称为解析器生成器。您只要向其提供您所用语言的语法（词汇和语法规则），它就会生成相应的解析器。创建解析器需要对解析有深刻理解，而人工创建并优化解析器并不是一件容易的事情，所以解析器生成器是非常实用的。WebKit 使用了两种非常有名的解析器生成器：用于创建词法分析器的 Flex 以及用于创建解析器的 Bison（您也可能遇到 Lex 和 Yacc 这样的别名）。Flex 的输入是包含标记的正则表达式定义的文件。Bison 的输入是采用 BNF 格式的语言语法规则。HTML 解析器HTML 解析器的任务是将 HTML 标记解析成解析树。HTML 语法定义HTML 的词汇和语法在 W3C 组织创建的规范中进行了定义。当前的版本是 HTML4，HTML5 正在处理过程中。非与上下文无关的语法正如我们在解析过程的简介中已经了解到的，语法可以用 BNF 等格式进行正式定义。很遗憾，所有的常规解析器都不适用于 HTML（我并不是开玩笑，它们可以用于解析 CSS 和 JavaScript）。HTML 并不能很容易地用解析器所需的与上下文无关的语法来定义。有一种可以定义 HTML 的正规格式：DTD（Document Type Definition，文档类型定义），但它不是与上下文无关的语法。这初看起来很奇怪：HTML 和 XML 非常相似。有很多 XML 解析器可以使用。HTML 存在一个 XML 变体 (XHTML)，那么有什么大的区别呢？区别在于 HTML 的处理更为 “宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 XML 严格的语法不同，HTML 整体来看是一种“软性” 的语法。显然，这种看上去细微的差别实际上却带来了巨大的影响。一方面，这是 HTML 如此流行的原因：它能包容您的错误，简化网络开发。另一方面，这使得它很难编写正式的语法。概括地说，HTML 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过 XML 解析器来解析。HTML DTDHTML 的定义采用了 DTD 格式。此格式可用于定义 SGML 族的语言。它包括所有允许使用的元素及其属性和层次结构的定义。如上文所述，HTML DTD 无法构成与上下文无关的语法。DTD 存在一些变体。严格模式完全遵守 HTML 规范，而其他模式可支持以前的浏览器所使用的标记。这样做的目的是确保向下兼容一些早期版本的内容。最新的严格模式 DTD 可以在这里找到：www.w3.org/TR/html4/strict.dtdDOM解析器的输出 “解析树” 是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。解析树的根节点是 “Document” 对象。DOM 与标记之间几乎是一一对应的关系。比如下面这段标记：12345678&lt;html&gt; &lt;body&gt; &lt;p&gt; Hello World &lt;/p&gt; &lt;div&gt; &lt;img src=&quot;example.png&quot;/&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;可翻译成如下的 DOM 树： 图：示例标记的 DOM 树和 HTML 一样，DOM 也是由 W3C 组织指定的。请参见 www.w3.org/DOM/DOMTR。这是关于文档操作的通用规范。其中一个特定模块描述针对 HTML 的元素。HTML 的定义可以在这里找到：www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html。我所说的树包含 DOM 节点，指的是树是由实现了某个 DOM 接口的元素构成的。浏览器在具体的实现中会有一些供内部使用的其他属性。解析算法我们在之前章节已经说过，HTML 无法用常规的自上而下或自下而上的解析器进行解析。原因在于：语言的宽容本质。浏览器历来对一些常见的无效 HTML 用法采取包容态度。解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容。由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析 HTML。HTML5 规范详细地描述了解析算法。此算法由两个阶段组成：标记化和树构建。标记化是词法分析过程，将输入内容解析成多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。 图：HTML 解析流程（摘自 HTML5 规范）标记化算法该算法的输出结果是 HTML 标记。该算法使用状态机来表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。该算法相当复杂，无法在此详述，所以我们通过一个简单的示例来帮助大家理解其原理。基本示例 - 将下面的 HTML 代码标记化：12345&lt;html&gt; &lt;body&gt; Hello world &lt;/body&gt;&lt;/html&gt;初始状态是数据状态。遇到字符 &lt; 时，状态更改为 “标记打开状态”。接收一个 a-z 字符会创建 “起始标记”，状态更改为 “标记名称状态”。这个状态会一直保持到接收 &gt; 字符。在此期间接收的每个字符都会附加到新的标记名称上。在本例中，我们创建的标记是 html 标记。遇到 &gt; 标记时，会发送当前的标记，状态改回 “数据状态”。&lt;body&gt; 标记也会进行同样的处理。目前 html 和 body 标记均已发出。现在我们回到 “数据状态”。接收到 Hello world 中的 H 字符时，将创建并发送字符标记，直到接收 &lt;/body&gt; 中的 &lt;。我们将为 Hello world 中的每个字符都发送一个字符标记。现在我们回到 “标记打开状态”。接收下一个输入字符 / 时，会创建 end tag token 并改为 “标记名称状态”。我们会再次保持这个状态，直到接收 &gt;。然后将发送新的标记，并回到 “数据状态”。&lt;/html&gt; 输入也会进行同样的处理。 图：对示例输入进行标记化树构建算法在创建解析器的同时，也会创建 Document 对象。在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为 “插入模式”。让我们来看看示例输入的树构建过程：12345&lt;html&gt; &lt;body&gt; Hello world &lt;/body&gt;&lt;/html&gt;树构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是 “initial mode”。接收 HTML 标记后转为 “before html” 模式，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 Document 根对象上。然后状态将改为 “before head”。此时我们接收 “body” 标记。即使我们的示例中没有 “head” 标记，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。现在我们进入了 “in head” 模式，然后转入 “after head” 模式。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为 “in body”。现在，接收由 “Hello world” 字符串生成的一系列字符标记。接收第一个字符时会创建并插入 “Text” 节点，而其他字符也将附加到该节点。接收 body 结束标记会触发 “after body” 模式。现在我们将接收 HTML 结束标记，然后进入 “after after body” 模式。接收到文件结束标记后，解析过程就此结束。 图：示例 HTML 的树构建解析结束后的操作在此阶段，浏览器会将文档标注为交互状态，并开始解析那些处于 “deferred” 模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态将设置为 “完成”，一个“加载” 事件将随之触发。您可以在 HTML5 规范中查看标记化和树构建的完整算法浏览器的容错机制您在浏览 HTML 网页时从来不会看到 “语法无效” 的错误。这是因为浏览器会纠正任何无效内容，然后继续工作。以下面的 HTML 代码为例：123456789&lt;html&gt; &lt;mytag&gt; &lt;/mytag&gt; &lt;div&gt; &lt;p&gt; &lt;/div&gt; Really lousy HTML &lt;/p&gt;&lt;/html&gt;在这里，我已经违反了很多语法规则（“mytag”不是标准的标记，“p”和 “div” 元素之间的嵌套有误等等），但是浏览器仍然会正确地显示这些内容，并且毫无怨言。因为有大量的解析器代码会纠正 HTML 网页作者的错误。不同浏览器的错误处理机制相当一致，但令人称奇的是，这种机制并不是 HTML 当前规范的一部分。和书签管理以及前进 / 后退按钮一样，它也是浏览器在多年发展中的产物。很多网站都普遍存在着一些已知的无效 HTML 结构，每一种浏览器都会尝试通过和其他浏览器一样的方式来修复这些无效结构。HTML5 规范定义了一部分这样的要求。WebKit 在 HTML 解析器类的开头注释中对此做了很好的概括。解析器对标记化输入内容进行解析，以构建文档树。如果文档的格式正确，就直接进行解析。遗憾的是，我们不得不处理很多格式错误的 HTML 文档，所以解析器必须具备一定的容错性。我们至少要能够处理以下错误情况：明显不能在某些外部标记中添加的元素。在此情况下，我们应该关闭所有标记，直到出现禁止添加的元素，然后再加入该元素。我们不能直接添加的元素。这很可能是网页作者忘记添加了其中的一些标记（或者其中的标记是可选的）。这些标签可能包括：HTML HEAD BODY TBODY TR TD LI（还有遗漏的吗？）。向 inline 元素内添加 block 元素。关闭所有 inline 元素，直到出现下一个较高级的 block 元素。如果这样仍然无效，可关闭所有元素，直到可以添加元素为止，或者忽略该标记。让我们看一些 WebKit 容错的示例：使用了而不是有些网站使用了而不是。为了与 IE 和 Firefox 兼容，WebKit 将其与做同样的处理。代码如下：1234if (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) &#123; reportError(MalformedBRError); t-&gt;beginTag = true;&#125;请注意，错误处理是在内部进行的，用户并不会看到这个过程。离散表格离散表格是指位于其他表格内容中，但又不在任何一个单元格内的表格。比如以下的示例：123456&lt;table&gt; &lt;table&gt; &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;WebKit 会将其层次结构更改为两个同级表格：123456&lt;table&gt; &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt; &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;代码如下：12if (m_inStrayTableContent &amp;&amp; localName == tableTag) popBlock(tableTag);WebKit 使用一个堆栈来保存当前的元素内容，它会从外部表格的堆栈中弹出内部表格。现在，这两个表格就变成了同级关系。嵌套的表单元素如果用户在一个表单元素中又放入了另一个表单，那么第二个表单将被忽略。代码如下：123if (!m_currentFormElement) &#123; m_currentFormElement = new HTMLFormElement(formTag, m_document);&#125;过于复杂的标记层次结构代码的注释已经说得很清楚了。123456789bool HTMLParser::allowNestedRedundantTag(const AtomicString&amp; tagName)&#123;unsigned i = 0;for (HTMLStackElem* curr = m_blockStack; i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName == tagName; curr = curr-&gt;next, i++) &#123; &#125;return i != cMaxRedundantTagDepth;&#125;放错位置的 html 或者 body 结束标记同样，代码的注释已经说得很清楚了。支持格式非常糟糕的 HTML 代码。我们从不关闭 body 标记，因为一些愚蠢的网页会在实际文档结束之前就关闭。我们通过调用 end() 来执行关闭操作。12if (t-&gt;tagName == htmlTag || t-&gt;tagName == bodyTag ) return;所以网页作者需要注意，除非您想作为反面教材出现在 WebKit 容错代码段的示例中，否则还请编写格式正确的 HTML 代码。CSS 解析还记得简介中解析的概念吗？和 HTML 不同，CSS 是上下文无关的语法，可以使用简介中描述的各种解析器进行解析。事实上，CSS 规范定义了 CSS 的词法和语法。让我们来看一些示例：词法语法（词汇）是针对各个标记用正则表达式定义的：1234567comment \/\*[^*]*\*+([^/*][^*]*\*+)*\/num [0-9]+|[0-9]*&quot;.&quot;[0-9]+nonascii [\200-\377]nmstart [_a-z]|&#123;nonascii&#125;|&#123;escape&#125;nmchar [_a-z0-9-]|&#123;nonascii&#125;|&#123;escape&#125;name &#123;nmchar&#125;+ident &#123;nmstart&#125;&#123;nmchar&#125;*“ident”是标识符 (identifier) 的缩写，比如类名。“name”是元素的 ID（通过 “#” 来引用）。语法是采用 BNF 格式描述的。123456789101112131415161718192021222324ruleset : selector [ &apos;,&apos; S* selector ]* &apos;&#123;&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;&#125;&apos; S* ;selector : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]? ;simple_selector : element_name [ HASH | class | attrib | pseudo ]* | [ HASH | class | attrib | pseudo ]+ ;class : &apos;.&apos; IDENT ;element_name : IDENT | &apos;*&apos; ;attrib : &apos;[&apos; S* IDENT S* [ [ &apos;=&apos; | INCLUDES | DASHMATCH ] S* [ IDENT | STRING ] S* ] &apos;]&apos; ;pseudo : &apos;:&apos; [ IDENT | FUNCTION S* [IDENT S*] &apos;)&apos; ] ;解释：这是一个规则集的结构：1234div.error , a.error &#123; color:red; font-weight:bold;&#125;div.error 和 a.error 是选择器。大括号内的部分包含了由此规则集应用的规则。此结构的正式定义是这样的：1234ruleset : selector [ &apos;,&apos; S* selector ]* &apos;&#123;&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;&#125;&apos; S* ;这表示一个规则集就是一个选择器，或者由逗号和空格（S 表示空格）分隔的多个（数量可选）选择器。规则集包含了大括号，以及其中的一个或多个（数量可选）由分号分隔的声明。“声明”和 “选择器” 将由下面的 BNF 格式定义。WebKit CSS 解析器WebKit 使用 Flex 和 Bison 解析器生成器，通过 CSS 语法文件自动创建解析器。正如我们之前在解析器简介中所说，Bison 会创建自下而上的移位归约解析器。Firefox 使用的是人工编写的自上而下的解析器。这两种解析器都会将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。 图：解析 CSS处理脚本和样式表的顺序脚本网络的模型是同步的。网页作者希望解析器遇到 &lt;script&gt; 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为 “defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。预解析WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。样式表另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。呈现树构建在 DOM 树构建的同时，浏览器还会构建另一个树结构：呈现树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。Firefox 将呈现树中的元素称为 “框架”。WebKit 使用的术语是呈现器或呈现对象。呈现器知道如何布局并将自身及其子元素绘制出来。WebKits RenderObject 类是所有呈现器的基类，其定义如下：12345678class RenderObject&#123; virtual void layout(); virtual void paint(PaintInfo); virtual void rect repaintRect(); Node* node; //the DOM node RenderStyle* style; // the computed style RenderLayer* containgLayer; //the containing z-index layer&#125;每一个呈现器都代表了一个矩形的区域，通常对应于相关节点的 CSS 框，这一点在 CSS2 规范中有所描述。它包含诸如宽度、高度和位置等几何信息。框的类型会受到与节点相关的 “display” 样式属性的影响（请参阅样式计算章节）。下面这段 WebKit 代码描述了根据 display 属性的不同，针对同一个 DOM 节点应创建什么类型的呈现器。123456789101112131415161718192021222324252627RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)&#123; Document* doc = node-&gt;document(); RenderArena* arena = doc-&gt;renderArena(); ... RenderObject* o = 0; switch (style-&gt;display()) &#123; case NONE: break; case INLINE: o = new (arena) RenderInline(node); break; case BLOCK: o = new (arena) RenderBlock(node); break; case INLINE_BLOCK: o = new (arena) RenderBlock(node); break; case LIST_ITEM: o = new (arena) RenderListItem(node); break; ... &#125; return o;&#125;元素类型也是考虑因素之一，例如表单控件和表格都对应特殊的框架。在 WebKit 中，如果一个元素需要创建特殊的呈现器，就会替换 createRenderer 方法。呈现器所指向的样式对象中包含了一些和几何无关的信息。呈现树和 DOM 树的关系呈现器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入呈现树中，例如 “head” 元素。如果元素的 display 属性值为 “none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden” 的元素仍会显示）。有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select” 元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。另一个关于多呈现器的例子是格式无效的 HTML。根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 呈现器，以包裹 inline 元素。有一些呈现对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。 图：呈现树及其对应的 DOM 树 (3.1)。初始容器 block 为 “viewport”，而在 WebKit 中则为“RenderView” 对象。构建呈现树的流程在 Firefox 中，系统会针对 DOM 更新注册展示层，作为侦听器。展示层将框架创建工作委托给 FrameConstructor，由该构造器解析样式（请参阅样式计算）并创建框架。在 WebKit 中，解析样式和创建呈现器的过程称为 “附加”。每个 DOM 节点都有一个“attach” 方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点 “attach” 方法。处理 html 和 body 标记就会构建呈现树根节点。这个根节点呈现对象对应于 CSS 规范中所说的容器 block，这是最上层的 block，包含了其他所有 block。它的尺寸就是视口，即浏览器窗口显示区域的尺寸。Firefox 称之为 ViewPortFrame，而 WebKit 称之为 RenderView。这就是文档所指向的呈现对象。呈现树的其余部分以 DOM 树节点插入的形式来构建。请参阅关于处理模型的 CSS2 规范。样式计算构建呈现树时，需要计算每一个呈现对象的可视化属性。这是通过计算每个元素的样式属性来完成的。样式包括来自各种来源的样式表、inline 样式元素和 HTML 中的可视化属性（例如 “bgcolor” 属性）。其中后者将经过转化以匹配 CSS 样式属性。样式表的来源包括浏览器的默认样式表、由网页作者提供的样式表以及由浏览器用户提供的用户样式表（浏览器允许您定义自己喜欢的样式。以 Firefox 为例，用户可以将自己喜欢的样式表放在 “Firefox Profile” 文件夹下）。样式计算存在以下难点：样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。例如下面这个组合选择器：123div div div div&#123; ...&#125;这意味着规则适用于作为 3 个 div 元素的子代的 `&lt;div&gt;`。如果您要检查规则是否适用于某个指定的 `&lt;div&gt;` 元素，应选择树上的一条向上路径进行检查。您可能需要向上遍历节点树，结果发现只有两个 div，而且规则并不适用。然后，您必须尝试树中的其他路径。 应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）。让我们来看看浏览器是如何处理这些问题的：共享样式数据WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：这些元素必须处于相同的鼠标状态（例如，不允许其中一个是 “:hover” 状态，而另一个不是）任何元素都没有 ID标记名称应匹配类属性应匹配映射属性的集合必须是完全相同的链接状态必须匹配焦点状态必须匹配任何元素都不应受属性选择器的影响，这里所说的 “影响” 是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配元素中不能有任何 inline 样式属性不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。Firefox 规则树为了简化样式计算，Firefox 还采用了另外两种树：规则树和样式上下文树。WebKit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 DOM 节点指向此类对象的相关样式。 图：Firefox 样式上下文树 (2.2)样式上下文包含端值。要计算出这些值，应按照正确顺序应用所有的匹配规则，并将其从逻辑值转化为具体的值。例如，如果逻辑值是屏幕大小的百分比，则需要换算成绝对的单位。规则树的点子真的很巧妙，它使得节点之间可以共享这些值，以避免重复计算，还可以节约空间。所有匹配的规则都存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。规则的存储是延迟进行的。规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径。这个想法相当于将规则树路径视为词典中的单词。如果我们已经计算出如下的规则树：假设我们需要为内容树中的另一个元素匹配规则，并且找到匹配路径是 B - E - I（按照此顺序）。由于我们在树中已经计算出了路径 A - B - E - I - L，因此就已经有了此路径，这就减少了现在所需的工作量。让我们看看规则树如何帮助我们减少工作。结构划分样式上下文可分割成多个结构。这些结构体包含了特定类别（如 border 或 color）的样式信息。结构中的属性都是继承的或非继承的。继承属性如果未由元素定义，则继承自其父代。非继承属性（也称为 “重置” 属性）如果未进行定义，则使用默认值。规则树通过缓存整个结构（包含计算出的端值）为我们提供帮助。这一想法假定底层节点没有提供结构的定义，则可使用上层节点中的缓存结构。使用规则树计算样式上下文在计算某个特定元素的样式上下文时，我们首先计算规则树中的对应路径，或者使用现有的路径。然后我们沿此路径应用规则，在新的样式上下文中填充结构。我们从路径中拥有最高优先级的底层节点（通常也是最特殊的选择器）开始，并向上遍历规则树，直到结构填充完毕。如果该规则节点对于此结构没有任何规范，那么我们可以实现更好的优化：寻找路径更上层的节点，找到后指定完整的规范并指向相关节点即可。这是最好的优化方法，因为整个结构都能共享。这可以减少端值的计算量并节约内存。如果我们找到了部分定义，就会向上遍历规则树，直到结构填充完毕。如果我们找不到结构的任何定义，那么假如该结构是 “继承” 类型，我们会在上下文树中指向父代的结构，这样也可以共享结构。如果是 reset 类型的结构，则会使用默认值。如果最特殊的节点确实添加了值，那么我们需要另外进行一些计算，以便将这些值转化成实际值。然后我们将结果缓存在树节点中，供子代使用。如果某个元素与其同级元素都指向同一个树节点，那么它们就可以共享整个样式上下文。让我们来看一个例子，假设我们有如下 HTML 代码：123456789101112&lt;html&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt; this is a &lt;span&gt; big error &lt;/span&gt; this is also a &lt;span&gt; very big error&lt;/span&gt; error &lt;/p&gt; &lt;/div&gt; &lt;div&gt;another error&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;还有如下规则：123456789101112div &#123;margin:5px;color:black&#125;.err &#123;color:red&#125;.big &#123;margin-top:3px&#125;div span &#123;margin-bottom:4px&#125;#div1 &#123;color:blue&#125;#div2 &#123;color:green&#125;div &#123;margin:5px;color:black&#125;.err &#123;color:red&#125;.big &#123;margin-top:3px&#125;div span &#123;margin-bottom:4px&#125;#div1 &#123;color:blue&#125;#div2 &#123;color:green&#125;为了简便起见，我们只需要填充两个结构：color 结构和 margin 结构。color 结构只包含一个成员（即 “color”），而 margin 结构包含四条边。形成的规则树如下图所示（节点的标记方式为 “节点名 : 指向的规则序号”）： 图：规则树上下文树如下图所示（节点名 : 指向的规则节点）： 图：上下文树假设我们解析 HTML 时遇到了第二个标记，我们需要为此节点创建样式上下文，并填充其样式结构。经过规则匹配，我们发现该的匹配规则是第 1、2 和 6 条。这意味着规则树中已有一条路径可供我们的元素使用，我们只需要再为其添加一个节点以匹配第 6 条规则（规则树中的 F 节点）。我们将创建样式上下文并将其放入上下文树中。新的样式上下文将指向规则树中的 F 节点。现在我们需要填充样式结构。首先要填充的是 margin 结构。由于最后的规则节点 (F) 并没有添加到 margin 结构，我们需要上溯规则树，直至找到在先前节点插入中计算过的缓存结构，然后使用该结构。我们会在指定 margin 规则的最上层节点（即 B 节点）上找到该结构。我们已经有了 color 结构的定义，因此不能使用缓存的结构。由于 color 有一个属性，我们无需上溯规则树以填充其他属性。我们将计算端值（将字符串转化为 RGB 等）并在此节点上缓存经过计算的结构。第二个 元素处理起来更加简单。我们将匹配规则，最终发现它和之前的 span 一样指向规则 G。由于我们找到了指向同一节点的同级，就可以共享整个样式上下文了，只需指向之前 span 的上下文即可。对于包含了继承自父代的规则的结构，缓存是在上下文树中进行的（事实上 color 属性是继承的，但是 Firefox 将其视为 reset 属性，并缓存到规则树上）。例如，如果我们在某个段落中添加 font 规则：1p &#123;font-family:Verdana;font size:10px;font-weight:bold&#125;那么，该段落元素作为上下文树中的 div 的子代，就会共享与其父代相同的 font 结构（前提是该段落没有指定 font 规则）。在 WebKit 中没有规则树，因此会对匹配的声明遍历 4 次。首先应用非重要高优先级的属性（由于作为其他属性的依据而应首先应用的属性，例如 display），接着是高优先级重要规则，然后是普通优先级非重要规则，最后是普通优先级重要规则。这意味着多次出现的属性会根据正确的层叠顺序进行解析。最后出现的最终生效。因此概括来说，共享样式对象（整个对象或者对象中的部分结构）可以解决问题 1 和问题 3。Firefox 规则树还有助于按照正确的顺序应用属性。对规则进行处理以简化匹配样式规则有一些来源：外部样式表或样式元素中的 CSS 规则1p &#123;color:blue&#125;inline 样式属性及类似内容1&lt;p /&gt;HTML 可视化属性（映射到相关的样式规则）1&lt;p bgcolor=&quot;blue&quot; /&gt;后两种很容易和元素进行匹配，因为元素拥有样式属性，而且 HTML 属性可以使用元素作为键值进行映射。我们之前在第 2 个问题中提到过，CSS 规则匹配可能比较棘手。为了解决这一难题，可以对 CSS 规则进行一些处理，以便访问。样式表解析完毕后，系统会根据选择器将 CSS 规则添加到某个哈希表中。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果选择器是 ID，规则就会添加到 ID 表中；如果选择器是类，规则就会添加到类表中，依此类推。这种处理可以大大简化规则匹配。我们无需查看每一条声明，只要从哈希表中提取元素的相关规则即可。这种优化方法可排除掉 95% 以上规则，因此在匹配过程中根本就不用考虑这些规则了 (4.1)。我们以如下的样式规则为例：123p.error &#123;color:red&#125;#messageDiv &#123;height:50px&#125;div &#123;margin:5px&#125;第一条规则将插入类表，第二条将插入 ID 表，而第三条将插入标记表。对于下面的 HTML 代码段：12&lt;p&gt;an error occurred &lt;/p&gt;&lt;div&gt;this is a message&lt;/div&gt;我们首先会为 p 元素寻找匹配的规则。类表中有一个 “error” 键，在下面可以找到 “p.error” 的规则。div 元素在 ID 表（键为 ID）和标记表中有相关的规则。剩下的工作就是找出哪些根据键提取的规则是真正匹配的了。例如，如果 div 的对应规则如下：1table div &#123;margin:5px&#125;这条规则仍然会从标记表中提取出来，因为键是最右边的选择器，但这条规则并不匹配我们的 div 元素，因为 div 没有 table 祖先。WebKit 和 Firefox 都进行了这一处理。以正确的层叠顺序应用规则样式对象具有与每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。样式表层叠顺序某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为 “层叠” 顺序。根据 CSS2 规范，层叠的顺序为（优先级从低到高）：浏览器声明用户普通声明作者普通声明作者重要声明用户重要声明浏览器声明是重要程度最低的，而用户只有将该声明标记为 “重要” 才可以替换网页作者的声明。同样顺序的声明会根据特异性进行排序，然后再是其指定顺序。HTML 可视化属性会转换成匹配的 CSS 声明。它们被视为低优先级的网页作者规则。特异性选择器的特异性由 CSS2 规范定义如下：如果声明来自于 “style” 属性，而不是带有选择器的规则，则记为 1，否则记为 0 (= a)记为选择器中 ID 属性的个数 (= b)记为选择器中其他属性和伪类的个数 (= c)记为选择器中元素名称和伪元素的个数 (= d)将四个数字按 a-b-c-d 这样连接起来（位于大数进制的数字系统中），构成特异性。您使用的进制取决于上述类别中的最高计数。例如，如果 a=14，您可以使用十六进制。如果 a=17，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：html body div div p …（在选择器中出现了 17 个标记，这样的可能性极低）。一些示例：12345678910* &#123;&#125; /* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */li &#123;&#125; /* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */li:first-line &#123;&#125; /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */ul li &#123;&#125; /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */ul ol+li &#123;&#125; /* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */h1 + *[rel=up]&#123;&#125; /* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */ul ol li.red &#123;&#125; /* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */li.red.level &#123;&#125; /* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */#x34y &#123;&#125; /* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */ /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */规则排序找到匹配的规则之后，应根据级联顺序将其排序。WebKit 对于较小的列表会使用冒泡排序，而对较大的列表则使用归并排序。对于以下规则，WebKit 通过替换 “&gt;” 运算符来实现排序：123456static bool operator &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2)&#123; int spec1 = r1.selector()-&gt;specificity(); int spec2 = r2.selector()-&gt;specificity(); return (spec1 == spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2;&#125;渐进式处理WebKit 使用一个标记来表示是否所有的顶级样式表（包括 @imports）均已加载完毕。如果在附加过程中尚未完全加载样式，则使用占位符，并在文档中进行标注，等样式表加载完毕后再重新计算。布局呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历 (3.5)。坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。布局是一个递归的过程。它从根呈现器（对应于 HTML 文档的 &lt;html&gt; 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。根呈现器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。所有的呈现器都有一个 “layout” 或者 “reflow” 方法，每一个呈现器都会调用其需要进行布局的子代的 layout 方法。Dirty 位系统为避免对所有细小更改都进行整体布局，浏览器采用了一种 “dirty 位” 系统。如果某个呈现器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。有两种标记：“dirty”和 “children are dirty”。“children are dirty” 表示尽管呈现器自身没有变化，但它至少有一个子代需要布局。全局布局和增量布局全局布局是指触发了整个呈现树范围的布局，触发原因可能包括：影响所有呈现器的全局样式更改，例如字体大小更改。屏幕大小调整。布局可以采用增量方式，也就是只对 dirty 呈现器进行布局（这样可能存在需要进行额外布局的弊端）。当呈现器为 dirty 时，会异步触发增量布局。例如，当来自网络的额外内容添加到 DOM 树之后，新的呈现器附加到了呈现树中。 图：增量布局 - 只有 dirty 呈现器及其子代进行布局 (3.6)。异步布局和同步布局增量布局是异步执行的。Firefox 将增量布局的 “reflow 命令” 加入队列，而调度程序会触发这些命令的批量执行。WebKit 也有用于执行增量布局的计时器：对呈现树进行遍历，并对 dirty 呈现器进行布局。请求样式信息（例如 “offsetHeight”）的脚本可同步触发增量布局。全局布局往往是同步触发的。有时，当初始布局完成之后，如果一些属性（如滚动位置）发生变化，布局就会作为回调而触发。优化如果布局是由 “大小调整” 或呈现器的位置（而非大小）改变而触发的，那么可以从缓存中获取呈现器的大小，而无需重新计算。在某些情况下，只有一个子树进行了修改，因此无需从根节点开始布局。这适用于在本地进行更改而不影响周围元素的情况，例如在文本字段中插入文本（否则每次键盘输入都将触发从根节点开始的布局）。布局处理布局通常具有以下模式：父呈现器确定自己的宽度。父呈现器依次处理子呈现器，并且：放置子呈现器（设置 x,y 坐标）。如果有必要，调用子呈现器的布局（如果子呈现器是 dirty 的，或者这是全局布局，或出于其他某些原因），这会计算子呈现器的高度。父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用。将其 dirty 位设置为 false。Firefox 使用 “state” 对象 (nsHTMLReflowState) 作为布局的参数（称为“reflow”），这其中包括了父呈现器的宽度。Firefox 布局的输出为 “metrics” 对象 (nsHTMLReflowMetrics)，其包含计算得出的呈现器高度。宽度计算呈现器宽度是根据容器块的宽度、呈现器样式中的 “width” 属性以及边距和边框计算得出的。例如以下 div 的宽度：1&lt;div/&gt;将由 WebKit 计算如下（BenderBox 类，calcWidth 方法）：容器的宽度取容器的 availableWidth 和 0 中的较大值。availableWidth 在本例中相当于 contentWidth，计算公式如下：1clientWidth() - paddingLeft() - paddingRight()clientWidth 和 clientHeight 表示一个对象的内部（除去边框和滚动条）。 元素的宽度是 “width” 样式属性。它会根据容器宽度的百分比计算得出一个绝对值。然后加上水平方向的边框和补白。现在计算得出的是 “preferred width”。然后需要计算最小宽度和最大宽度。如果首选宽度大于最大宽度，那么应使用最大宽度。如果首选宽度小于最小宽度（最小的不可破开单位），那么应使用最小宽度。这些值会缓存起来，以用于需要布局而宽度不变的情况。换行如果呈现器在布局过程中需要换行，会立即停止布局，并告知其父代需要换行。父代会创建额外的呈现器，并对其调用布局。绘制在绘制阶段，系统会遍历呈现树，并调用呈现器的 “paint” 方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。全局绘制和增量绘制和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块 “dirty 区域”，并生成“paint” 事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。绘制顺序CSS2 规范定义了绘制流程的顺序。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：背景颜色背景图片边框子代轮廓Firefox 显示列表Firefox 遍历整个呈现树，为绘制的矩形建立一个显示列表。列表中按照正确的绘制顺序（先是呈现器的背景，然后是边框等等）包含了与矩形相关的呈现器。这样等到重新绘制的时候，只需遍历一次呈现树，而不用多次遍历（绘制所有背景，然后绘制所有图片，再绘制所有边框等等）。Firefox 对此过程进行了优化，也就是不添加隐藏的元素，例如被不透明元素完全遮挡住的元素。WebKit 矩形存储在重新绘制之前，WebKit 会将原来的矩形另存为一张位图，然后只绘制新旧矩形之间的差异部分。动态变化在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大 “html” 元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。呈现引擎的线程呈现引擎采用了单线程。几乎所有操作（除了网络操作）都是在单线程中进行的。在 Firefox 和 Safari 中，该线程就是浏览器的主线程。而在 Chrome 浏览器中，该线程是标签进程的主线程。网络操作可由多个并行线程执行。并行连接数是有限的（通常为 2 至 6 个，以 Firefox 3 为例是 6 个）。事件循环浏览器的主线程是事件循环。它是一个无限循环，永远处于接受处理状态，并等待事件（如布局和绘制事件）发生，并进行处理。这是 Firefox 中关于主事件循环的代码：12while (!mExiting) NS_ProcessNextEvent(thread);CSS2 可视化模型画布根据 CSS2 规范，“画布” 这一术语是指 “用来呈现格式化结构的空间”，也就是供浏览器绘制内容的区域。画布的空间尺寸大小是无限的，但是浏览器会根据视口的尺寸选择一个初始宽度。根据 www.w3.org/TR/CSS2/zindex.html，画布如果包含在其他画布内，就是透明的；否则会由浏览器指定一种颜色。CSS 框模型CSS 框模型描述的是针对文档树中的元素而生成，并根据可视化格式模型进行布局的矩形框。每个框都有一个内容区域（例如文本、图片等），还有可选的周围补白、边框和边距区域。 图：CSS2 框模型每一个节点都会生成 0..n 个这样的框。所有元素都有一个 “display” 属性，决定了它们所对应生成的框类型。示例：123block - generates a block box.inline - generates one or more inline boxes.none - no box is generated.默认值是 inline，但是浏览器样式表设置了其他默认值。例如，“div” 元素的 display 属性默认值是 block。您可以在这里找到默认样式表示例：www.w3.org/TR/CSS2/sample.html定位方案有三种定位方案：普通：根据对象在文档中的位置进行定位，也就是说对象在呈现树中的位置和它在 DOM 树中的位置相似，并根据其框类型和尺寸进行布局。浮动：对象先按照普通流进行布局，然后尽可能地向左或向右移动。绝对：对象在呈现树中的位置和它在 DOM 树中的位置不同。定位方案是由 “position” 属性和 “float” 属性设置的。如果值是 static 和 relative，就是普通流如果值是 absolute 和 fixed，就是绝对定位static 定位无需定义位置，而是使用默认定位。对于其他方案，网页作者需要指定位置：top、bottom、left、right。框的布局方式是由以下因素决定的：框类型框尺寸定位方案外部信息，例如图片大小和屏幕大小框类型block 框：形成一个 block，在浏览器窗口中拥有其自己的矩形区域。 图：block 框inline 框：没有自己的 block，但是位于容器 block 内。 图：inline 框block 采用的是一个接一个的垂直格式，而 inline 采用的是水平格式。 图：block 和 inline 格式inline 框放置在行中或 “行框” 中。这些行至少和最高的框一样高，还可以更高，当框根据 “底线” 对齐时，这意味着元素的底部需要根据其他框中非底部的位置对齐。如果容器的宽度不够，inline 元素就会分为多行放置。在段落中经常发生这种情况。 图：行定位相对相对定位：先按照普通方式定位，然后根据所需偏移量进行移动。 图：相对定位浮动浮动框会移动到行的左边或右边。有趣的特征在于，其他框会浮动在它的周围。下面这段 HTML 代码：1234&lt;p&gt; &lt;img src=&quot;images/image.gif&quot; width=&quot;100&quot; height=&quot;100&quot;&gt; Lorem ipsum dolor sit amet, consectetuer...&lt;/p&gt;显示效果如下： 图：浮动绝对定位和固定定位这种布局是准确定义的，与普通流无关。元素不参与普通流。尺寸是相对于容器而言的。在固定定位中，容器就是可视区域。 图：固定定位请注意，即使在文档滚动时，固定框也不会移动。分层展示这是由 z-index CSS 属性指定的。它代表了框的第三个维度，也就是沿 “z 轴” 方向的位置。这些框分散到多个堆栈（称为堆栈上下文）中。在每一个堆栈中，会首先绘制后面的元素，然后在顶部绘制前面的元素，以便更靠近用户。如果出现重叠，新绘制的元素就会覆盖之前的元素。堆栈是按照 z-index 属性进行排序的。具有 “z-index” 属性的框形成了本地堆栈。视口具有外部堆栈。示例：12345678910111213141516&lt;style type=&quot;text/css&quot;&gt; div &#123; position: absolute; left: 2in; top: 2in; &#125;&lt;/style&gt;&lt;p&gt; &lt;div &gt; &lt;/div&gt; &lt;div &gt; &lt;/div&gt; &lt;/p&gt;结果如下： 图：固定定位虽然红色 div 在标记中的位置比绿色 div 靠前（按理应该在常规流程中优先绘制），但是 z-index 属性的优先级更高，因此它移动到了根框所保持的堆栈中更靠前的位置。参考资料浏览器架构Grosskurth, Alan. A Reference Architecture for Web Browsers (pdf)Gupta, Vineet. How Browsers Work - Part 1 - Architecture解析Aho, Sethi, Ullman, Compilers: Principles, Techniques, and Tools（即 “Dragon book”）, Addison-Wesley, 1986Rick Jelliffe. The Bold and the Beautiful: two new drafts for HTML 5.FirefoxL. David Baron, Faster HTML and CSS: Layout Engine Internals for Web Developers.L. David Baron, Faster HTML and CSS: Layout Engine Internals for Web Developers（Google 技术访谈视频）L. David Baron, Mozilla’s Layout EngineL. David Baron, Mozilla Style System DocumentationChris Waterson, Notes on HTML ReflowChris Waterson, Gecko OverviewAlexander Larsson, The life of an HTML HTTP requestWebKitDavid Hyatt, Implementing CSS（第一部分）David Hyatt, An Overview of WebCoreDavid Hyatt, WebCore RenderingDavid Hyatt, The FOUC ProblemW3C 规范HTML 4.01 规范W3C HTML5 规范层叠样式表第 2 级第 1 次修改 (CSS 2.1) 规范浏览器构建说明Firefox. https://developer.mozilla.org/en/Build_DocumentationWebKit. http://webkit.org/building/build.html]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十个案例学会 React Hooks]]></title>
    <url>%2Farchives%2Fcca6.html</url>
    <content type="text"><![CDATA[原文地址十个案例学会 React Hooks前言在 React 的世界中，有容器组件和 UI 组件之分，在 React Hooks 出现之前，UI 组件我们可以使用函数，无状态组件来展示 UI，而对于容器组件，函数组件就显得无能为力，我们依赖于类组件来获取数据，处理数据，并向下传递参数给 UI 组件进行渲染。在我看来，使用 React Hooks 相比于从前的类组件有以下几点好处：代码可读性更强，原本同一块功能的代码逻辑被拆分在了不同的生命周期函数中，容易使开发者不利于维护和迭代，通过 React Hooks 可以将功能代码聚合，方便阅读维护组件树层级变浅，在原本的代码中，我们经常使用 HOC/render props 等方式来复用组件的状态，增强功能等，无疑增加了组件树层数及渲染，而在 React Hooks 中，这些功能都可以通过强大的自定义的 Hooks 来实现React 在 v16.8 的版本中推出了 React Hooks 新特性，虽然社区还没有最佳实践如何基于 React Hooks 来打造复杂应用(至少我还没有)，凭借着阅读社区中大量的关于这方面的文章，下面我将通过十个案例来帮助你认识理解并可以熟练运用 React Hooks 大部分特性。useState 保存组件状态在类组件中，我们使用 this.state 来保存组件状态，并对其修改触发组件重新渲染。比如下面这个简单的计数器组件，很好诠释了类组件如何运行：在线 Demo1234567891011121314151617181920import React from "react";class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0, name: "alife" &#125;; &#125; render() &#123; const &#123; count &#125; = this.state; return ( &lt;div&gt; Count: &#123;count&#125; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: count + 1 &#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: count - 1 &#125;)&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;一个简单的计数器组件就完成了，而在函数组件中，由于没有 this 这个黑魔法，React 通过 useState 来帮我们保存组件的状态。在线 Demo1234567891011121314import React, &#123; useState &#125; from "react";function App() &#123; const [obj, setObject] = useState(&#123; count: 0, name: "alife" &#125;); return ( &lt;div className="App"&gt; Count: &#123;obj.count&#125; &lt;button onClick=&#123;() =&gt; setObject(&#123; ...obj, count: obj.count + 1 &#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setObject(&#123; ...obj, count: obj.count - 1 &#125;)&#125;&gt;-&lt;/button&gt; &lt;/div&gt; );&#125;通过传入 useState 参数后返回一个带有默认状态和改变状态函数的数组。通过传入新状态给函数来改变原本的状态值。值得注意的是 useState 不帮助你处理状态，相较于 setState 非覆盖式更新状态，useState 覆盖式更新状态，需要开发者自己处理逻辑。(代码如上)似乎有个 useState 后，函数组件也可以拥有自己的状态了，但仅仅是这样完全不够。useEffect 处理副作用函数组件能保存状态，但是对于异步请求，副作用的操作还是无能为力，所以 React 提供了 useEffect 来帮助开发者处理函数组件的副作用，在介绍新 API 之前，我们先来看看类组件是怎么做的：在线 Demo1234567891011121314151617181920212223242526272829303132import React, &#123; Component &#125; from "react";class App extends Component &#123; state = &#123; count: 1 &#125;; componentDidMount() &#123; const &#123; count &#125; = this.state; document.title = "componentDidMount" + count; this.timer = setInterval(() =&gt; &#123; this.setState((&#123; count &#125;) =&gt; (&#123; count: count + 1 &#125;)); &#125;, 1000); &#125; componentDidUpdate() &#123; const &#123; count &#125; = this.state; document.title = "componentDidMount" + count; &#125; componentWillUnmount() &#123; document.title = "componentWillUnmount"; clearInterval(this.timer); &#125; render() &#123; const &#123; count &#125; = this.state; return ( &lt;div&gt; Count:&#123;count&#125; &lt;button onClick=&#123;() =&gt; clearInterval(this.timer)&#125;&gt;clear&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;在例子中，组件每隔一秒更新组件状态，并且每次触发更新都会触发 document.title 的更新(副作用)，而在组件卸载时修改 document.title（类似于清除）从例子中可以看到，一些重复的功能开发者需要在 componentDidMount 和 componentDidUpdate 重复编写，而如果使用 useEffect 则完全不一样。在线 Demo123456789101112131415161718192021222324import React, &#123; useState, useEffect &#125; from "react";let timer = null;function App() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = "componentDidMount" + count; &#125;,[count]); useEffect(() =&gt; &#123; timer = setInterval(() =&gt; &#123; setCount(prevCount =&gt; prevCount + 1); &#125;, 1000); return () =&gt; &#123; document.title = "componentWillUnmount"; clearInterval(timer); &#125;; &#125;, []); return ( &lt;div&gt; Count: &#123;count&#125; &lt;button onClick=&#123;() =&gt; clearInterval(timer)&#125;&gt;clear&lt;/button&gt; &lt;/div&gt; );&#125;我们使用 useEffect 重写了上面的例子，useEffect 第一个参数传递函数，可以用来做一些副作用比如异步请求，修改外部参数等行为，而第二个参数是个数组，如果数组中的值才会触发 useEffect 第一个参数中的函数。返回值(如果有)则在组件销毁或者调用函数前调用。比如第一个 useEffect 中，理解起来就是一旦 count 值发生改变，则修改 documen.title 值而第二个 useEffect 中数组没有传值，代表不监听任何参数变化，即只有在组件初始化或销毁的时候才会触发，用来代替 componentDidMount 和 componentWillUnmount基于这个强大 Hooks，我们可以模拟封装出其他生命周期函数，比如 componentDidUpdate 代码十分简单1234567891011function useUpdate(fn) &#123; // useRef 创建一个引用 const mounting = useRef(true); useEffect(() =&gt; &#123; if (mounting.current) &#123; mounting.current = false; &#125; else &#123; fn(); &#125; &#125;);&#125;现在我们有了 useState 管理状态，useEffect 处理副作用，异步逻辑，学会这两招足以应对大部分类组件的使用场景。useContext 减少组件层级上面介绍了 useState、useEffect 这两个最基本的 API，接下来介绍的 useContext 是 React 帮你封装好的，用来处理多层级传递数据的方式，在以前组件树种，跨层级祖先组件想要给孙子组件传递数据的时候，除了一层层 props 往下透传之外，我们还可以使用 React Context API 来帮我们做这件事，举个简单的例子：在线 Demo1234567891011121314const &#123; Provider, Consumer &#125; = React.createContext(null);function Bar() &#123; return &lt;Consumer&gt;&#123;color =&gt; &lt;div&gt;&#123;color&#125;&lt;/div&gt;&#125;&lt;/Consumer&gt;;&#125;function Foo() &#123; return &lt;Bar /&gt;;&#125;function App() &#123; return ( &lt;Provider value=&#123;"grey"&#125;&gt; &lt;Foo /&gt; &lt;/Provider&gt; );&#125;通过 React createContext 的语法，在 APP 组件中可以跨过 Foo 组件给 Bar 传递数据。而在 React Hooks 中，我们可以使用 useContext 进行改造。在线 Demo123456789101112131415const colorContext = React.createContext("gray");function Bar() &#123; const color = useContext(colorContext); return &lt;div&gt;&#123;color&#125;&lt;/div&gt;;&#125;function Foo() &#123; return &lt;Bar /&gt;;&#125;function App() &#123; return ( &lt;colorContext.Provider value=&#123;"red"&#125;&gt; &lt;Foo /&gt; &lt;/colorContext.Provider&gt; );&#125;传递给 useContext 的是 context 而不是 consumer，返回值即是想要透传的数据了。用法很简单，使用 useContext 可以解决 Consumer 多状态嵌套的问题。参考例子123456789101112131415function HeaderBar() &#123; return ( &lt;CurrentUser.Consumer&gt; &#123;user =&gt; &lt;Notifications.Consumer&gt; &#123;notifications =&gt; &lt;header&gt; Welcome back, &#123;user.name&#125;! You have &#123;notifications.length&#125; notifications. &lt;/header&gt; &#125; &#125; &lt;/CurrentUser.Consumer&gt; );&#125;而使用 useContext 则变得十分简洁，可读性更强且不会增加组件树深度。12345678910function HeaderBar() &#123; const user = useContext(CurrentUser); const notifications = useContext(Notifications); return ( &lt;header&gt; Welcome back, &#123;user.name&#125;! You have &#123;notifications.length&#125; notifications. &lt;/header&gt; );&#125;useReduceruseReducer 这个 Hooks 在使用上几乎跟 Redux/React-Redux 一模一样，唯一缺少的就是无法使用 redux 提供的中间件。我们将上述的计时器组件改写为 useReducer，在线 Demo12345678910111213141516171819202122232425262728import React, &#123; useReducer &#125; from "react";const initialState = &#123; count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case "increment": return &#123; count: state.count + action.payload &#125;; case "decrement": return &#123; count: state.count - action.payload &#125;; default: throw new Error(); &#125;&#125;function App() &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: "increment", payload: 5 &#125;)&#125;&gt; + &lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: "decrement", payload: 5 &#125;)&#125;&gt; - &lt;/button&gt; &lt;/&gt; );&#125;用法跟 Redux 基本上是一致的，用法也很简单，算是提供一个 mini 的 Redux 版本。useCallback 记忆函数在类组件中，我们经常犯下面这样的错误：1234567class App &#123; render() &#123; return &lt;div&gt; &lt;SomeComponent style=&#123;&#123; fontSize: 14 &#125;&#125; doSomething=&#123; () =&gt; &#123; console.log('do something'); &#125;&#125; /&gt; &lt;/div&gt;; &#125;&#125;这样写有什么坏处呢？一旦 App 组件的 props 或者状态改变了就会触发重渲染，即使跟 SomeComponent 组件不相关，由于每次 render 都会产生新的 style 和 doSomething，所以会导致 SomeComponent 重新渲染，倘若 SomeComponent 是一个大型的组件树，这样的 Virtual Dom 的比较显然是很浪费的，解决的办法也很简单，将参数抽离成变量。1234567891011const fontSizeStyle = &#123; fontSize: 14 &#125;;class App &#123; doSomething = () =&gt; &#123; console.log('do something'); &#125; render() &#123; return &lt;div&gt; &lt;SomeComponent style=&#123;fontSizeStyle&#125; doSomething=&#123; this.doSomething &#125; /&gt; &lt;/div&gt;; &#125;&#125;在类组件中，我们还可以通过 this 这个对象来存储函数，而在函数组件中没办法进行挂载了。所以函数组件在每次渲染的时候如果有传递函数的话都会重渲染子组件。123456function App() &#123; const handleClick = () =&gt; &#123; console.log('Click happened'); &#125; return &lt;SomeComponent onClick=&#123;handleClick&#125;&gt;Click Me&lt;/SomeComponent&gt;;&#125;而有了 useCallback 就不一样了，你可以通过 useCallback 获得一个记忆后的函数。123456function App() &#123; const memoizedHandleClick = useCallback(() =&gt; &#123; console.log('Click happened') &#125;, []); // 空数组代表无论什么情况下该函数都不会发生改变 return &lt;SomeComponent onClick=&#123;memoizedHandleClick&#125;&gt;Click Me&lt;/SomeComponent&gt;;&#125;老规矩，第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。这样只要子组件继承了 PureComponent 或者使用 React.memo 就可以有效避免不必要的 VDOM 渲染。useMemo 记忆组件useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。1useCallback(fn, inputs) is equivalent to useMemo(() =&gt; fn, inputs).所以前面使用 useCallback 的例子可以使用 useMemo 进行改写：123456function App() &#123; const memoizedHandleClick = useMemo(() =&gt; () =&gt; &#123; console.log('Click happened') &#125;, []); // 空数组代表无论什么情况下该函数都不会发生改变 return &lt;SomeComponent onClick=&#123;memoizedHandleClick&#125;&gt;Click Me&lt;/SomeComponent&gt;;&#125;唯一的区别是：useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你。所以在前面的例子中，可以返回 handleClick 来达到存储函数的目的。所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。123456789101112function Parent(&#123; a, b &#125;) &#123; // Only re-rendered if `a` changes: const child1 = useMemo(() =&gt; &lt;Child1 a=&#123;a&#125; /&gt;, [a]); // Only re-rendered if `b` changes: const child2 = useMemo(() =&gt; &lt;Child2 b=&#123;b&#125; /&gt;, [b]); return ( &lt;&gt; &#123;child1&#125; &#123;child2&#125; &lt;/&gt; )&#125;当 a/b 改变时，child1/child2 才会重新渲染。从例子可以看出来，只有在第二个参数数组的值发生变化时，才会触发子组件的更新。useRef 保存引用值useRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用，看个简单的例子：在线 Demo1234567891011121314151617181920import React, &#123; useState, useRef &#125; from "react";function App() &#123; let [name, setName] = useState("Nate"); let nameRef = useRef(); const submitButton = () =&gt; &#123; setName(nameRef.current.value); &#125;; return ( &lt;div className="App"&gt; &lt;p&gt;&#123;name&#125;&lt;/p&gt; &lt;div&gt; &lt;input ref=&#123;nameRef&#125; type="text" /&gt; &lt;button type="button" onClick=&#123;submitButton&#125;&gt; Submit &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );&#125;useRef 返回的值传递给组件或者 DOM 的 ref 属性，就可以通过 ref.current 值访问组件或真实的 DOM 节点，从而可以对 DOM 进行一些操作，比如监听事件等等。当然 useRef 远比你想象中的功能更加强大，useRef 的功能有点像类属性，或者说您想要在组件中记录一些值，并且这些值在稍后可以更改。利用 useRef 就可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态，而不会在每个 Render 间存在隔离。参考例子：精读《Function VS Class 组件》React Hooks 中存在 Capture Value 的特性：在线 Demo12345678910111213141516171819202122function MessageThread() &#123; const [message, setMessage] = useState(""); const showMessage = () =&gt; &#123; alert("You said: " + message); &#125;; const handleSendClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; const handleMessageChange = e =&gt; &#123; setMessage(e.target.value); &#125;; return ( &lt;&gt; &lt;input value=&#123;message&#125; onChange=&#123;handleMessageChange&#125; /&gt; &lt;button onClick=&#123;handleSendClick&#125;&gt;Send&lt;/button&gt; &lt;/&gt; );&#125;在点击 Send 按钮后，再次修改输入框的值，3 秒后的输出依然是点击前输入框的值。这就是所谓的 capture value 的特性。而在类组件中 3 秒后输出的就是修改后的值，因为这时候 message 是挂载在 this 变量上，它保留的是一个引用值，对 this 属性的访问都会获取到最新的值。讲到这里你应该就明白了，useRef 创建一个引用，就可以有效规避 React Hooks 中 Capture Value 特性。123456789101112131415function MessageThread() &#123; const latestMessage = useRef(""); const showMessage = () =&gt; &#123; alert("You said: " + latestMessage.current); &#125;; const handleSendClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; const handleMessageChange = e =&gt; &#123; latestMessage.current = e.target.value; &#125;;&#125;只要将赋值与取值的对象变成 useRef，而不是 useState，就可以躲过 capture value 特性，在 3 秒后得到最新的值。useImperativeHandle 透传 Ref通过 useImperativeHandle 用于让父组件获取子组件内的索引 在线 Demo123456789101112131415161718import React, &#123; useRef, useEffect, useImperativeHandle, forwardRef &#125; from "react";function ChildInputComponent(props, ref) &#123; const inputRef = useRef(null); useImperativeHandle(ref, () =&gt; inputRef.current); return &lt;input type="text" name="child input" ref=&#123;inputRef&#125; /&gt;;&#125;const ChildInput = forwardRef(ChildInputComponent);function App() &#123; const inputRef = useRef(null); useEffect(() =&gt; &#123; inputRef.current.focus(); &#125;, []); return ( &lt;div&gt; &lt;ChildInput ref=&#123;inputRef&#125; /&gt; &lt;/div&gt; );&#125;通过这种方式，App 组件可以获得子组件的 input 的 DOM 节点。useLayoutEffect 同步执行副作用大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。在线 Demo1234567891011121314151617181920function App() &#123; const [width, setWidth] = useState(0); useLayoutEffect(() =&gt; &#123; const title = document.querySelector("#title"); const titleWidth = title.getBoundingClientRect().width; console.log("useLayoutEffect"); if (width !== titleWidth) &#123; setWidth(titleWidth); &#125; &#125;); useEffect(() =&gt; &#123; console.log("useEffect"); &#125;); return ( &lt;div&gt; &lt;h1 id="title"&gt;hello&lt;/h1&gt; &lt;h2&gt;&#123;width&#125;&lt;/h2&gt; &lt;/div&gt; );&#125;在上面的例子中，useLayoutEffect 会在 render，DOM 更新之后同步触发函数，会优于 useEffect 异步触发函数。React Hooks 不足尽管我们通过上面的例子看到 React Hooks 的强大之处，似乎类组件完全都可以使用 React Hooks 重写。但是当下 v16.8 的版本中，还无法实现 getSnapshotBeforeUpdate 和 componentDidCatch 这两个在类组件中的生命周期函数。官方也计划在不久的将来在 React Hooks 进行实现。]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
        <category>React Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS Iframe与父级页面通信及IE9兼容性]]></title>
    <url>%2Farchives%2Fd4bd.html</url>
    <content type="text"><![CDATA[本文由 简悦 SimpRead 转码， 原文地址 https://www.cnblogs.com/haosit/p/11301350.html一、 postMessagewindow.postMessage() 方法安全地启用 Window 对象之间的跨源通信；例如，在页面和它产生的弹出窗口之间，或者在页面和嵌入其中的 iframe 之间。二、语法otherWindow.postMessage(message, targetOrigin, [transfer]);otherWindow：是接收对象的窗体引用，例如：子窗体 (iframe) 对父级窗体的引用 “window.parent” 或者其他 Iframe 的引用 “Window.frames + 索引值(命名或数字)”message：将要发送到其他 window 的数据。在 IE9 以下的浏览器, message 不支持 JSON 对象，必须是字符串类型targetOrigin：通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串 “*”（表示无限制）或者一个 URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配 targetOrigin 提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。transfer：是一串和 message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。三、应用子窗体和父窗体之间的通信1. parent.html：添加有 Iframe(childIframe.html) 页面，并监听 message 事件12345678910111213141516171819202122&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta /&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; iframe&#123; border:none; width:100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;parent&lt;/h1&gt; &lt;iframe src=&quot;childiframe.html&quot;&gt;&lt;/iframe&gt; &lt;script&gt; window.addEventListener(&quot;message&quot;, function (message) &#123; alert(JSON.stringify(message.data)); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;2. childIframe.html：直接向 parent 发送一条消息1234567891011121314&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;childIframe&lt;/h1&gt; &lt;script&gt; window.parent.postMessage(&#123;type:&quot;open&quot;,url:&quot;iframe.html&quot;&#125;,&quot;*&quot;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;3. IE9 - 兼容问题：IE9 及以下的浏览器, message 不支持 JSON 对象，必须是字符串类型。发送时将 JSON 转换为字符串1window.parent.postMessage(JSON.stringify(&#123; type: &quot;open&quot;, url: &quot;iframe.html&quot; &#125;), &quot;*&quot;);IE9 还是 IE8 不兼容 addEventListener 和 “message” 监听方法和事件，兼容办法12345678910//IE8,IE9兼容方法if (window.attachEvent) &#123; window.attachEvent(&apos;onmessage&apos;, function (message) &#123; console.log(JSON.parse(message.data)); &#125;);&#125; else &#123; window.addEventListener(&apos;message&apos;, function (message) &#123; console.log(JSON.parse(message.data)); &#125;);&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>Iframe</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Iframe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Complete Guide to useEffect]]></title>
    <url>%2Farchives%2F6387.html</url>
    <content type="text"><![CDATA[本文由 简悦 SimpRead 转码， 原文地址 https://overreacted.io/a-complete-guide-to-useeffect/You wrote a few components with Hooks. Maybe even a small app. You’re mostly satisfied. You’re comfortable with the API and picked up a few tricks along the way. You even made some custom Hooks to extract repetitive logic (300 lines gone!) and showed it off to your colleagues. “Great job”, they said.But sometimes when you useEffect, the pieces don’t quite fit together. You have a nagging feeling that you’re missing something. It seems similar to class lifecycles… but is it really? You find yourself asking questions like:🤔 How do I replicate componentDidMount with useEffect?🤔 How do I correctly fetch data inside useEffect? What is []?🤔 Do I need to specify functions as effect dependencies or not?🤔 Why do I sometimes get an infinite refetching loop?🤔 Why do I sometimes get an old state or prop value inside my effect?When I just started using Hooks, I was confused by all of those questions too. Even when writing the initial docs, I didn’t have a firm grasp on some of the subtleties. I’ve since had a few “aha” moments that I want to share with you. This deep dive will make the answers to these questions look obvious to you.To see the answers, we need to take a step back. The goal of this article isn’t to give you a list of bullet point recipes. It’s to help you truly “grok” useEffect. There won’t be much to learn. In fact, we’ll spend most of our time _un_learning.It’s only after I stopped looking at the useEffect Hook through the prism of the familiar class lifecycle methods that everything came together for me.“Unlearn what you have learned.” — YodaThis article assumes that you’re somewhat familiar with useEffect API.It’s also really long. It’s like a mini-book. That’s just my preferred format. But I wrote a TLDR just below if you’re in a rush or don’t really care.If you’re not comfortable with deep dives, you might want to wait until these explanations appear elsewhere. Just like when React came out in 2013, it will take some time for people to recognize a different mental model and teach it.TLDRHere’s a quick TLDR if you don’t want to read the whole thing. If some parts don’t make sense, you can scroll down until you find something related.Feel free to skip it if you plan to read the whole post. I’ll link to it at the end.🤔 Question: How do I replicate componentDidMount with useEffect?While you can useEffect(fn, []), it’s not an exact equivalent. Unlike componentDidMount, it will capture props and state. So even inside the callbacks, you’ll see the initial props and state. If you want to see “latest” something, you can write it to a ref. But there’s usually a simpler way to structure the code so that you don’t have to. Keep in mind that the mental model for effects is different from componentDidMount and other lifecycles, and trying to find their exact equivalents may confuse you more than help. To get productive, you need to “think in effects”, and their mental model is closer to implementing synchronization than to responding to lifecycle events.🤔 Question: How do I correctly fetch data inside useEffect? What is []?This article is a good primer on data fetching with useEffect. Make sure to read it to the end! It’s not as long as this one. [] means the effect doesn’t use any value that participates in React data flow, and is for that reason safe to apply once. It is also a common source of bugs when the value actually _is_ used. You’ll need to learn a few strategies (primarily useReducer and useCallback) that can remove the need for a dependency instead of incorrectly omitting it.🤔 Question: Do I need to specify functions as effect dependencies or not?The recommendation is to hoist functions that don’t need props or state outside of your component, and pull the ones that are used only by an effect inside of that effect. If after that your effect still ends up using functions in the render scope (including function from props), wrap them into useCallback where they’re defined, and repeat the process. Why does it matter? Functions can “see” values from props and state — so they participate in the data flow. There’s a more detailed answer in our FAQ.🤔 Question: Why do I sometimes get an infinite refetching loop?This can happen if you’re doing data fetching in an effect without the second dependencies argument. Without it, effects run after every render — and setting the state will trigger the effects again. An infinite loop may also happen if you specify a value that always changes in the dependency array. You can tell which one by removing them one by one. However, removing a dependency you use (or blindly specifying []) is usually the wrong fix. Instead, fix the problem at its source. For example, functions can cause this problem, and putting them inside effects, hoisting them out, or wrapping them with useCallback helps. To avoid recreating objects, useMemo can serve a similar purpose.🤔 Why do I sometimes get an old state or prop value inside my effect?Effects always “see” props and state from the render they were defined in. That helps prevent bugs but in some cases can be annoying. For those cases, you can explicitly maintain some value in a mutable ref (the linked article explains it at the end). If you think you’re seeing some props or state from an old render but don’t expect it, you probably missed some dependencies. Try using the lint rule to train yourself to see them. A few days, and it’ll be like a second nature to you. See also this answer in our FAQ.I hope this TLDR was helpful! Otherwise, let’s go.Each Render Has Its Own Props and StateBefore we can talk about effects, we need to talk about rendering.Here’s a counter. Look at the highlighted line closely:1234567891011function Counter() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;What does it mean? Does count somehow “watch” changes to our state and update automatically? That might be a useful first intuition when you learn React but it’s not an accurate mental model.In this example, count is just a number. It’s not a magic “data binding”, a “watcher”, a “proxy”, or anything else. It’s a good old number like this one:123const count = 42;&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;The first time our component renders, the count variable we get from useState() is 0. When we call setCount(1), React calls our component again. This time, count will be 1. And so on:12345678910111213141516171819function Counter() &#123; const count = 0; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &#125;function Counter() &#123; const count = 1; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &#125;function Counter() &#123; const count = 2; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &#125;Whenever we update the state, React calls our component. Each render result “sees” its own counter state value which is a constant inside our function.So this line doesn’t do any special data binding:1&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;It only embeds a number value into the render output. That number is provided by React. When we setCount, React calls our component again with a different count value. Then React updates the DOM to match our latest render output.The key takeaway is that the count constant inside any particular render doesn’t change over time. It’s our component that’s called again — and each render “sees” its own count value that’s isolated between renders.(For an in-depth overview of this process, check out my post React as a UI Runtime.)Each Render Has Its Own Event HandlersSo far so good. What about event handlers?Look at this example. It shows an alert with the count after three seconds:12345678910111213function Counter() &#123; const [count, setCount] = useState(0); function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + count); &#125;, 3000); &#125; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;button onClick=&#123;handleAlertClick&#125;&gt; Show alert &lt;/button&gt; &lt;/div&gt; );&#125;Let’s say I do this sequence of steps:Increment the counter to 3Press “Show alert”Increment it to 5 before the timeout firesWhat do you expect the alert to show? Will it show 5 — which is the counter state at the time of the alert? Or will it show 3 — the state when I clicked?spoilers aheadGo ahead and try it yourself!If the behavior doesn’t quite make sense to you, imagine a more practical example: a chat app with the current recipient ID in the state, and a Send button. This article explores the reasons in depth but the correct answer is 3.The alert will “capture” the state at the time I clicked the button.(There are ways to implement the other behavior too but I’ll be focusing on the default case for now. When building a mental model, it’s important that we distinguish the “path of least resistance” from the opt-in escape hatches.)But how does it work?We’ve discussed that the count value is constant for every particular call to our function. It’s worth emphasizing this — our function gets called many times (once per each render), but every one of those times the count value inside of it is constant and set to a particular value (state for that render).This is not specific to React — regular functions work in a similar way:1234567891011121314function sayHi(person) &#123; const name = person.name; setTimeout(() =&gt; &#123; alert(&apos;Hello, &apos; + name); &#125;, 3000);&#125;let someone = &#123;name: &apos;Dan&apos;&#125;;sayHi(someone);someone = &#123;name: &apos;Yuzhi&apos;&#125;;sayHi(someone);someone = &#123;name: &apos;Dominic&apos;&#125;;sayHi(someone);In this example, the outer someone variable is reassigned several times. (Just like somewhere in React, the current component state can change.) However, inside sayHi, there is a local name constant that is associated with a person from a particular call. That constant is local, so it’s isolated between the calls! As a result, when the timeouts fire, each alert “remembers” its own name.This explains how our event handler captures the count at the time of the click. If we apply the same substitution principle, each render “sees” its own count:12345678910111213141516171819202122232425262728293031function Counter() &#123; const count = 0; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + count); &#125;, 3000); &#125; &#125;function Counter() &#123; const count = 1; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + count); &#125;, 3000); &#125; &#125;function Counter() &#123; const count = 2; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + count); &#125;, 3000); &#125; &#125;So effectively, each render returns its own “version” of handleAlertClick. Each of those versions “remembers” its own count:12345678910111213141516171819202122232425262728293031function Counter() &#123; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + 0); &#125;, 3000); &#125; &lt;button onClick=&#123;handleAlertClick&#125; /&gt; &#125;function Counter() &#123; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + 1); &#125;, 3000); &#125; &lt;button onClick=&#123;handleAlertClick&#125; /&gt; &#125;function Counter() &#123; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + 2); &#125;, 3000); &#125; &lt;button onClick=&#123;handleAlertClick&#125; /&gt; &#125;This is why in this demo event handlers “belong” to a particular render, and when you click, it keeps using the counter state from that render.Inside any particular render, props and state forever stay the same. But if props and state are isolated between renders, so are any values using them (including the event handlers). They also “belong” to a particular render. So even async functions inside an event handler will “see” the same count value.Side note: I inlined concrete count values right into handleAlertClick functions above. This mental substitution is safe because count can’t possibly change within a particular render. It’s declared as a const and is a number. It would be safe to think the same way about other values like objects too, but only if we agree to avoid mutating state. Calling setSomething(newObj) with a newly created object instead of mutating it is fine because state belonging to previous renders is intact.Each Render Has Its Own EffectsThis was supposed to be a post about effects but we still haven’t talked about effects yet! We’ll rectify this now. Turns out, effects aren’t really any different.Let’s go back to an example from the docs:12345678910111213function Counter() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;Here’s a question for you: how does the effect read the latest count state?Maybe, there’s some kind of “data binding” or “watching” that makes count update live inside the effect function? Maybe count is a mutable variable that React sets inside our component so that our effect always sees the latest value?Nope.We already know that count is constant within a particular component render. Event handlers “see” the count state from the render that they “belong” to because count is a variable in their scope. The same is true for effects!It’s not the count variable that somehow changes inside an “unchanging” effect. It’s the effect function itself that’s different on every render.Each version “sees” the count value from the render that it “belongs” to:12345678910111213141516171819202122function Counter() &#123; useEffect( () =&gt; &#123; document.title = `You clicked $&#123;0&#125; times`; &#125; ); &#125;function Counter() &#123; useEffect( () =&gt; &#123; document.title = `You clicked $&#123;1&#125; times`; &#125; ); &#125;function Counter() &#123; useEffect( () =&gt; &#123; document.title = `You clicked $&#123;2&#125; times`; &#125; ); &#125;React remembers the effect function you provided, and runs it after flushing changes to the DOM and letting the browser paint the screen.So even if we speak of a single conceptual effect here (updating the document title), it is represented by a different function on every render — and each effect function “sees” props and state from the particular render it “belongs” to.Conceptually, you can imagine effects are a part of the render result.Strictly saying, they’re not (in order to allow Hook composition without clumsy syntax or runtime overhead). But in the mental model we’re building up, effect functions belong to a particular render in the same way that event handlers do.To make sure we have a solid understanding, let’s recap our first render:React: Give me the UI when the state is 0.Your component:Here’s the render result: &lt;p&gt;You clicked 0 times&lt;/p&gt;.Also remember to run this effect after you’re done: () =&gt; { document.title = &#39;You clicked 0 times&#39; }.React: Sure. Updating the UI. Hey browser, I’m adding some stuff to the DOM.Browser: Cool, I painted it to the screen.React: OK, now I’m going to run the effect you gave me.Running () =&gt; { document.title = &#39;You clicked 0 times&#39; }.Now let’s recap what happens after we click:Your component: Hey React, set my state to 1.React: Give me the UI for when the state is 1.Your component:Here’s the render result: &lt;p&gt;You clicked 1 times&lt;/p&gt;.Also remember to run this effect after you’re done: () =&gt; { document.title = &#39;You clicked 1 times&#39; }.React: Sure. Updating the UI. Hey browser, I’ve changed the DOM.Browser: Cool, I painted your changes to the screen.React: OK, now I’ll run the effect that belongs to the render I just did.Running () =&gt; { document.title = &#39;You clicked 1 times&#39; }.Each Render Has Its Own… EverythingWe know now that effects run after every render, are conceptually a part of the component output, and “see” the props and state from that particular render.Let’s try a thought experiment. Consider this code:12345678910111213function Counter() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`You clicked $&#123;count&#125; times`); &#125;, 3000); &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;If I click several times with a small delay, what is the log going to look like?spoilers aheadYou might think this is a gotcha and the end result is unintuitive. It’s not! We’re going to see a sequence of logs — each one belonging to a particular render and thus with its own count value. You can try it yourself:You may think: “Of course that’s how it works! How else could it work?”Well, that’s not how this.state works in classes. It’s easy to make the mistake of thinking that this class implementation is equivalent:12345componentDidUpdate() &#123; setTimeout(() =&gt; &#123; console.log(`You clicked $&#123;this.state.count&#125; times`); &#125;, 3000);&#125;However, this.state.count always points at the latest count rather than the one belonging to a particular render. So you’ll see 5 logged each time instead:I think it’s ironic that Hooks rely so much on JavaScript closures, and yet it’s the class implementation that suffers from the canonical wrong-value-in-a-timeout confusion that’s often associated with closures. This is because the actual source of the confusion in this example is the mutation (React mutates this.state in classes to point to the latest state) and not closures themselves.Closures are great when the values you close over never change. That makes them easy to think about because you’re essentially referring to constants. And as we discussed, props and state never change within a particular render. By the way, we can fix the class version… by using a closure.Swimming Against the TideAt this point it’s important that we call it out explicitly: every function inside the component render (including event handlers, effects, timeouts or API calls inside them) captures the props and state of the render call that defined it.So these two examples are equivalent:1234567function Example(props) &#123; useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(props.counter); &#125;, 1000); &#125;); &#125;1234567function Example(props) &#123; const counter = props.counter; useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(counter); &#125;, 1000); &#125;); &#125;It doesn’t matter whether you read from props or state “early” inside of your component. They’re not going to change! Inside the scope of a single render, props and state stay the same. (Destructuring props makes this more obvious.)Of course, sometimes you want to read the latest rather than captured value inside some callback defined in an effect. The easiest way to do it is by using refs, as described in the last section of this article.Be aware that when you want to read the future props or state from a function in a past render, you’re swimming against the tide. It’s not wrong (and in some cases necessary) but it might look less “clean” to break out of the paradigm. This is an intentional consequence because it helps highlight which code is fragile and depends on timing. In classes, it’s less obvious when this happens.Here’s a version of our counter example that replicates the class behavior:1234567function Example() &#123; const [count, setCount] = useState(0); const latestCount = useRef(count); useEffect(() =&gt; &#123; latestCount.current = count; setTimeout(() =&gt; &#123; console.log(`You clicked $&#123;latestCount.current&#125; times`); &#125;, 3000); &#125;);It might seem quirky to mutate something in React. However, this is exactly how React itself reassigns this.state in classes. Unlike with captured props and state, you don’t have any guarantees that reading latestCount.current would give you the same value in any particular callback. By definition, you can mutate it any time. This is why it’s not a default, and you have to opt into that.So What About Cleanup?As the docs explain, some effects might have a cleanup phase. Essentially, its purpose is to “undo” an effect for cases like subscriptions.Consider this code:123456useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange); &#125;;&#125;);Say props is {id: 10} on the first render, and {id: 20} on the second render. You might think that something like this happens:React cleans up the effect for {id: 10}.React renders UI for {id: 20}.React runs the effect for {id: 20}.(This is not quite the case.)With this mental model, you might think the cleanup “sees” the old props because it runs before we re-render, and then the new effect “sees” the new props because it runs after the re-render. That’s the mental model lifted directly from the class lifecycles, and it’s not accurate here. Let’s see why.React only runs the effects after letting the browser paint. This makes your app faster as most effects don’t need to block screen updates. Effect cleanup is also delayed. The previous effect is cleaned up after the re-render with new props:React renders UI for {id: 20}.The browser paints. We see the UI for {id: 20} on the screen.React cleans up the effect for {id: 10}.React runs the effect for {id: 20}.You might be wondering: but how can the cleanup of the previous effect still “see” the old {id: 10} props if it runs after the props change to {id: 20}?We’ve been here before… 🤔Quoting the previous section:Every function inside the component render (including event handlers, effects, timeouts or API calls inside them) captures the props and state of the render call that defined it.Now the answer is clear! The effect cleanup doesn’t read the “latest” props, whatever that means. It reads props that belong to the render it’s defined in:1234567891011121314151617181920212223242526function Example() &#123; useEffect( () =&gt; &#123; ChatAPI.subscribeToFriendStatus(10, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(10, handleStatusChange); &#125;; &#125; ); &#125;function Example() &#123; useEffect( () =&gt; &#123; ChatAPI.subscribeToFriendStatus(20, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(20, handleStatusChange); &#125;; &#125; ); &#125;Kingdoms will rise and turn into ashes, the Sun will shed its outer layers to be a white dwarf, and the last civilization will end. But nothing will make the props “seen” by the first render effect’s cleanup anything other than {id: 10}.That’s what allows React to deal with effects right after painting — and make your apps faster by default. The old props are still there if our code needs them.Synchronization, Not LifecycleOne of my favorite things about React is that it unifies describing the initial render result and the updates. This reduces the entropy of your program.Say my component looks like this:1234567function Greeting(&#123; name &#125;) &#123; return ( &lt;h1 class&gt; Hello, &#123;name&#125; &lt;/h1&gt; );&#125;It doesn’t matter if I render &lt;Greeting /&gt; and later &lt;Greeting /&gt;, or if I just render &lt;Greeting /&gt;. In the end, we will see “Hello, Yuzhi” in both cases.People say: “It’s all about the journey, not the destination”. With React, it’s the opposite. It’s all about the destination, not the journey. That’s the difference between $.addClass and $.removeClass calls in jQuery code (our “journey”) and specifying what the CSS class should be in React code (our “destination”).React synchronizes the DOM according to our current props and state. There is no distinction between a “mount” or an “update” when rendering.You should think of effects in a similar way. useEffect lets you synchronize things outside of the React tree according to our props and state.1234567function Greeting(&#123; name &#125;) &#123; useEffect(() =&gt; &#123; document.title = &apos;Hello, &apos; + name; &#125;); return ( &lt;h1 class&gt; Hello, &#123;name&#125; &lt;/h1&gt; );&#125;This is subtly different from the familiar mount/update/unmount mental model. It is important really to internalize this. If you’re trying to write an effect that behaves differently depending on whether the component renders for the first time or not, you’re swimming against the tide! We’re failing at synchronizing if our result depends on the “journey” rather than the “destination”.It shouldn’t matter whether we rendered with props A, B, and C, or if we rendered with C immediately. While there may be some temporary differences (e.g. while we’re fetching data), eventually the end result should be the same.Still, of course running all effects on every render might not be efficient. (And in some cases, it would lead to infinite loops.)So how can we fix this?Teaching React to Diff Your EffectsWe’ve already learned that lesson with the DOM itself. Instead of touching it on every re-render, React only updates the parts of the DOM that actually change.When you’re updating123&lt;h1 class&gt; Hello, Dan&lt;/h1&gt;to123&lt;h1 class&gt; Hello, Yuzhi&lt;/h1&gt;React sees two objects:12const oldProps = &#123;className: &apos;Greeting&apos;, children: &apos;Hello, Dan&apos;&#125;;const newProps = &#123;className: &apos;Greeting&apos;, children: &apos;Hello, Yuzhi&apos;&#125;;It goes over each of their props and determine that children have changed and need a DOM update, but className did not. So it can just do:1domNode.innerText = &apos;Hello, Yuzhi&apos;;Could we do something like this with effects too? It would be nice to avoid re-running them when applying the effect is unnecessary.For example, maybe our component re-renders because of a state change:12345678910111213function Greeting(&#123; name &#125;) &#123; const [counter, setCounter] = useState(0); useEffect(() =&gt; &#123; document.title = &apos;Hello, &apos; + name; &#125;); return ( &lt;h1 class&gt; Hello, &#123;name&#125; &lt;button onClick=&#123;() =&gt; setCounter(count + 1)&#125;&gt; Increment &lt;/button&gt; &lt;/h1&gt; );&#125;But our effect doesn’t use the counter state. Our effect synchronizes the document.title with the name prop, but the name prop is the same. Re-assigning document.title on every counter change seems non-ideal.OK, so can React just… diff effects?12let oldEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;let newEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;Not really. React can’t guess what the function does without calling it. (The source doesn’t really contain specific values, it just closes over the name prop.)This is why if you want to avoid re-running effects unnecessarily, you can provide a dependency array (also known as “deps”) argument to useEffect:123useEffect(() =&gt; &#123; document.title = &apos;Hello, &apos; + name;&#125;, [name]);It’s like if we told React: “Hey, I know you can’t see inside this function, but I promise it only uses name and nothing else from the render scope.”If each of these values is the same between the current and the previous time this effect ran, there’s nothing to synchronize so React can skip the effect:12345const oldEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;const oldDeps = [&apos;Dan&apos;];const newEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;const newDeps = [&apos;Dan&apos;];If even one of the values in the dependency array is different between renders, we know running the effect can’t be skipped. Synchronize all the things!Don’t Lie to React About DependenciesLying to React about dependencies has bad consequences. Intuitively, this makes sense, but I’ve seen pretty much everyone who tries useEffect with a mental model from classes try to cheat the rules. (And I did that too at first!)1234567891011function SearchResults() &#123; async function fetchData() &#123; &#125; useEffect(() =&gt; &#123; fetchData(); &#125;, []); &#125;(The Hooks FAQ explains what to do instead. We’ll come back to this example below.)“But I only want to run it on mount!”, you’ll say. For now, remember: if you specify deps, all values from inside your component that are used by the effect must be there. Including props, state, functions — anything in your component.Sometimes when you do that, it causes a problem. For example, maybe you see an infinite refetching loop, or a socket is recreated too often. The solution to that problem is not to remove a dependency. We’ll look at the solutions soon.But before we jump to solutions, let’s understand the problem better.What Happens When Dependencies LieIf deps contain every value used by the effect, React knows when to re-run it:123useEffect(() =&gt; &#123; document.title = &apos;Hello, &apos; + name;&#125;, [name]);(Dependencies are different, so we re-run the effect.)But if we specified [] for this effect, the new effect function wouldn’t run:123useEffect(() =&gt; &#123; document.title = &apos;Hello, &apos; + name;&#125;, []);(Dependencies are equal, so we skip the effect.)In this case the problem might seem obvious. But the intuition can fool you in other cases where a class solution “jumps out” from your memory.For example, let’s say we’re writing a counter that increments every second. With a class, our intuition is: “Set up the interval once and destroy it once”. Here’s an example of how we can do it. When we mentally translate this code to useEffect, we instinctively add [] to the deps. “I want it to run once”, right?1234567891011function Counter() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, []); return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125;However, this example only increments once. Oops.If your mental model is “dependencies let me specify when I want to re-trigger the effect”, this example might give you an existential crisis. You want to trigger it once because it’s an interval — so why is it causing issues?However, this makes sense if you know that dependencies are our hint to React about everything that the effect uses from the render scope. It uses count but we lied that it doesn’t with []. It’s only a matter of time before this bites us!In the first render, count is 0. Therefore, setCount(count + 1) in the first render’s effect means setCount(0 + 1). Since we never re-run the effect because of [] deps, it will keep calling setCount(0 + 1) every second:123456789101112131415161718192021222324252627function Counter() &#123; useEffect( () =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(0 + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [] ); &#125;function Counter() &#123; useEffect( () =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(1 + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [] ); &#125;We lied to React by saying our effect doesn’t depend on a value from inside our component, when in fact it does!Our effect uses count — a value inside the component (but outside the effect):123456const count = useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, []);Therefore, specifying [] as a dependency will create a bug. React will compare the dependencies, and skip updating this effect:(Dependencies are equal, so we skip the effect.)Issues like this are difficult to think about. Therefore, I encourage you to adopt it as a hard rule to always be honest about the effect dependencies, and specify them all. (We provide a lint rule if you want to enforce this on your team.)Two Ways to Be Honest About DependenciesThere are two strategies to be honest about dependencies. You should generally start with the first one, and then apply the second one if needed.The first strategy is to fix the dependency array to include all the values inside the component that are used inside the effect. Let’s include count as a dep:12345useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, [count]);This makes the dependency array correct. It may not be ideal but that’s the first issue we needed to fix. Now a change to count will re-run the effect, with each next interval referencing count from its render in setCount(count + 1):1234567891011121314151617181920212223242526function Counter() &#123; useEffect( () =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(0 + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [0] ); &#125;function Counter() &#123; useEffect( () =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(1 + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [1] ); &#125;That would fix the problem but our interval would be cleared and set again whenever the count changes. That may be undesirable:(Dependencies are different, so we re-run the effect.)The second strategy is to change our effect code so that it wouldn’t need a value that changes more often than we want. We don’t want to lie about the dependencies — we just want to change our effect to have fewer of them.Let’s look at a few common techniques for removing dependencies.Making Effects Self-SufficientWe want to get rid of the count dependency in our effect.12345useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, [count]);To do this, we need to ask ourselves: what are we using count for? It seems like we only use it for the setCount call. In that case, we don’t actually need count in the scope at all. When we want to update state based on the previous state, we can use the functional updater form of setState:12345useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(c =&gt; c + 1); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, []);I like to think of these cases as “false dependencies”. Yes, count was a necessary dependency because we wrote setCount(count + 1) inside the effect. However, we only truly needed count to transform it into count + 1 and “send it back” to React. But React already knows the current count. All we needed to tell React is to increment the state — whatever it is right now.That’s exactly what setCount(c =&gt; c + 1) does. You can think of it as “sending an instruction” to React about how the state should change. This “updater form” also helps in other cases, like when you batch multiple updates.Note that we actually did the work to remove the dependency. We didn’t cheat. Our effect doesn’t read the counter value from the render scope anymore:(Dependencies are equal, so we skip the effect.)You can try it here.Even though this effect only runs once, the interval callback that belongs to the first render is perfectly capable of sending the c =&gt; c + 1 update instruction every time the interval fires. It doesn’t need to know the current counter state anymore. React already knows it.Functional Updates and Google DocsRemember how we talked about synchronization being the mental model for effects? An interesting aspect of synchronization is that you often want to keep the “messages” between the systems untangled from their state. For example, editing a document in Google Docs doesn’t actually send the whole page to the server. That would be very inefficient. Instead, it sends a representation of what the user tried to do.While our use case is different, a similar philosophy applies to effects. It helps to send only the minimal necessary information from inside the effects into a component. The updater form like setCount(c =&gt; c + 1) conveys strictly less information than setCount(count + 1) because it isn’t “tainted” by the current count. It only expresses the action (“incrementing”). Thinking in React involves finding the minimal state. This is the same principle, but for updates.Encoding the intent (rather than the result) is similar to how Google Docs solves collaborative editing. While this is stretching the analogy, functional updates serve a similar role in React. They ensure updates from multiple sources (event handlers, effect subscriptions, etc) can be correctly applied in a batch and in a predictable way.However, even setCount(c =&gt; c + 1) isn’t that great. It looks a bit weird and it’s very limited in what it can do. For example, if we had two state variables whose values depend on each other, or if we needed to calculate the next state based on a prop, it wouldn’t help us. Luckily, setCount(c =&gt; c + 1) has a more powerful sister pattern. Its name is useReducer.Decoupling Updates from ActionsLet’s modify the previous example to have two state variables: count and step. Our interval will increment the count by the value of the step input:12345678910111213141516function Counter() &#123; const [count, setCount] = useState(0); const [step, setStep] = useState(1); useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(c =&gt; c + step); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [step]); return ( &lt;&gt; &lt;h1&gt;&#123;count&#125;&lt;/h1&gt; &lt;input value=&#123;step&#125; onChange=&#123;e =&gt; setStep(Number(e.target.value))&#125; /&gt; &lt;/&gt; );&#125;(Here’s a demo.)Note that we’re not cheating. Since I started using step inside the effect, I added it to the dependencies. And that’s why the code runs correctly.The current behavior in this example is that changing the step restarts the interval — because it’s one of the dependencies. And in many cases, that is exactly what you want! There’s nothing wrong with tearing down an effect and setting it up anew, and we shouldn’t avoid that unless we have a good reason.However, let’s say we want the interval clock to not reset on changes to the step. How do we remove the step dependency from our effect?When setting a state variable depends on the current value of another state variable, you might want to try replacing them both with useReducer.When you find yourself writing setSomething(something =&gt; ...), it’s a good time to consider using a reducer instead. A reducer lets you decouple expressing the “actions” that happened in your component from how the state updates in response to them.Let’s trade the step dependency for a dispatch dependency in our effect:1234567const [state, dispatch] = useReducer(reducer, initialState);const &#123; count, step &#125; = state;useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; dispatch(&#123; type: &apos;tick&apos; &#125;); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, [dispatch]);(See the demo.)You might ask me: “How is this any better?” The answer is that React guarantees the dispatch function to be constant throughout the component lifetime. So the example above doesn’t ever need to resubscribe the interval.We solved our problem!(You may omit dispatch, setState, and useRef container values from the deps because React guarantees them to be static. But it also doesn’t hurt to specify them.)Instead of reading the state inside an effect, it dispatches an action that encodes the information about what happened. This allows our effect to stay decoupled from the step state. Our effect doesn’t care how we update the state, it just tells us about what happened. And the reducer centralizes the update logic:12345678910111213const initialState = &#123; count: 0, step: 1,&#125;;function reducer(state, action) &#123; const &#123; count, step &#125; = state; if (action.type === &apos;tick&apos;) &#123; return &#123; count: count + step, step &#125;; &#125; else if (action.type === &apos;step&apos;) &#123; return &#123; count, step: action.step &#125;; &#125; else &#123; throw new Error(); &#125;&#125;(Here’s a demo if you missed it earlier).Why useReducer Is the Cheat Mode of HooksWe’ve seen how to remove dependencies when an effect needs to set state based on previous state, or on another state variable. But what if we need props to calculate the next state? For example, maybe our API is &lt;Counter step={1} /&gt;. Surely, in this case we can’t avoid specifying props.step as a dependency?In fact, we can! We can put the reducer itself inside our component to read props:123456789101112131415161718function Counter(&#123; step &#125;) &#123; const [count, dispatch] = useReducer(reducer, 0); function reducer(state, action) &#123; if (action.type === &apos;tick&apos;) &#123; return state + step; &#125; else &#123; throw new Error(); &#125; &#125; useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; dispatch(&#123; type: &apos;tick&apos; &#125;); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [dispatch]); return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125;This pattern disables a few optimizations so try not to use it everywhere, but you can totally access props from a reducer if you need to. (Here’s a demo.)Even in that case, dispatch identity is still guaranteed to be stable between re-renders. So you may omit it from the effect deps if you want. It’s not going to cause the effect to re-run.You may be wondering: how can this possibly work? How can the reducer “know” props when called from inside an effect that belongs to another render? The answer is that when you dispatch, React just remembers the action — but it will call your reducer during the next render. At that point the fresh props will be in scope, and you won’t be inside an effect.This is why I like to think of useReducer as the “cheat mode” of Hooks. It lets me decouple the update logic from describing what happened. This, in turn, helps me remove unnecessary dependencies from my effects and avoid re-running them more often than necessary.Moving Functions Inside EffectsA common mistake is to think functions shouldn’t be dependencies. For example, this seems like it could work:12345678910111213function SearchResults() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); async function fetchData() &#123; const result = await axios( &apos;https://hn.algolia.com/api/v1/search?query=react&apos;, ); setData(result.data); &#125; useEffect(() =&gt; &#123; fetchData(); &#125;, []);(This example is adapted from a great article by Robin Wieruch — check it out!)And to be clear, this code does work. But the problem with simply omitting local functions is that it gets pretty hard to tell whether we’re handling all cases as the component grows!Imagine our code was split like this and each function was five times larger:123456789101112131415161718function SearchResults() &#123; function getFetchUrl() &#123; return &apos;https://hn.algolia.com/api/v1/search?query=react&apos;; &#125; async function fetchData() &#123; const result = await axios(getFetchUrl()); setData(result.data); &#125; useEffect(() =&gt; &#123; fetchData(); &#125;, []); &#125;Now let’s say we later use some state or prop in one of these functions:12345678910111213141516171819function SearchResults() &#123; const [query, setQuery] = useState(&apos;react&apos;); function getFetchUrl() &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125; async function fetchData() &#123; const result = await axios(getFetchUrl()); setData(result.data); &#125; useEffect(() =&gt; &#123; fetchData(); &#125;, []); &#125;If we forget to update the deps of any effects that call these functions (possibly, through other functions!), our effects will fail to synchronize changes from our props and state. This doesn’t sound great.Luckily, there is an easy solution to this problem. If you only use some functions inside an effect, move them directly into that effect:12345678function SearchResults() &#123; useEffect(() =&gt; &#123; function getFetchUrl() &#123; return &apos;https://hn.algolia.com/api/v1/search?query=react&apos;; &#125; async function fetchData() &#123; const result = await axios(getFetchUrl()); setData(result.data); &#125; fetchData(); &#125;, []); &#125;(Here’s a demo.)So what is the benefit? We no longer have to think about the “transitive dependencies”. Our dependencies array isn’t lying anymore: we truly aren’t using anything from the outer scope of the component in our effect.If we later edit getFetchUrl to use the query state, we’re much more likely to notice that we’re editing it inside an effect — and therefore, we need to add query to the effect dependencies:12345678910111213141516function SearchResults() &#123; const [query, setQuery] = useState(&apos;react&apos;); useEffect(() =&gt; &#123; function getFetchUrl() &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125; async function fetchData() &#123; const result = await axios(getFetchUrl()); setData(result.data); &#125; fetchData(); &#125;, [query]); &#125;(Here’s a demo.)By adding this dependency, we’re not just “appeasing React”. It makes sense to refetch the data when the query changes. The design of useEffect forces you to notice the change in our data flow and choose how our effects should synchronize it — instead of ignoring it until our product users hit a bug.Thanks to the exhaustive-deps lint rule from the eslint-plugin-react-hooks plugin, you can analyze the effects as you type in your editor and receive suggestions about which dependencies are missing. In other words, a machine can tell you which data flow changes aren’t handled correctly by a component.Pretty sweet.But I Can’t Put This Function Inside an EffectSometimes you might not want to move a function inside an effect. For example, several effects in the same component may call the same function, and you don’t want to copy and paste its logic. Or maybe it’s a prop.Should you skip a function like this in the effect dependencies? I think not. Again, effects shouldn’t lie about their dependencies. There are usually better solutions. A common misconception is that “a function would never change”. But as we learned throughout this article, this couldn’t be further from truth. Indeed, a function defined inside a component changes on every render!That by itself presents a problem. Say two effects call getFetchUrl:1234567891011121314151617function SearchResults() &#123; function getFetchUrl(query) &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125; useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;react&apos;); &#125;, []); useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;redux&apos;); &#125;, []); &#125;In that case you might not want to move getFetchUrl inside either of the effects since you wouldn’t be able to share the logic.On the other hand, if you’re “honest” about the effect dependencies, you may run into a problem. Since both our effects depend on getFetchUrl (which is different on every render), our dependency arrays are useless:1234567891011121314function SearchResults() &#123; function getFetchUrl(query) &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125; useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;react&apos;); &#125;, [getFetchUrl]); useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;redux&apos;); &#125;, [getFetchUrl]); &#125;A tempting solution to this is to just skip the getFetchUrl function in the deps list. However, I don’t think it’s a good solution. This makes it difficult to notice when we are adding a change to the data flow that needs to be handled by an effect. This leads to bugs like the “never updating interval” we saw earlier.Instead, there are two other solutions that are simpler.First of all, if a function doesn’t use anything from the component scope, you can hoist it outside the component and then freely use it inside your effects:1234567891011121314function getFetchUrl(query) &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;&#125;function SearchResults() &#123; useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;react&apos;); &#125;, []); useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;redux&apos;); &#125;, []); &#125;There’s no need to specify it in deps because it’s not in the render scope and can’t be affected by the data flow. It can’t accidentally depend on props or state.Alternatively, you can wrap it into the useCallback Hook:1234567891011121314function SearchResults() &#123; const getFetchUrl = useCallback((query) =&gt; &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125;, []); useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;react&apos;); &#125;, [getFetchUrl]); useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;redux&apos;); &#125;, [getFetchUrl]); &#125;useCallback is essentially like adding another layer of dependency checks. It’s solving the problem on the other end — rather than avoid a function dependency, we make the function itself only change when necessary.Let’s see why this approach is useful. Previously, our example showed two search results (for &#39;react&#39; and &#39;redux&#39; search queries). But let’s say we want to add an input so that you can search for an arbitrary query. So instead of taking query as an argument, getFetchUrl will now read it from local state.We’ll immediately see that it’s missing a query dependency:123456function SearchResults() &#123; const [query, setQuery] = useState(&apos;react&apos;); const getFetchUrl = useCallback(() =&gt; &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125;, []); &#125;If I fix my useCallback deps to include query, any effect with getFetchUrl in deps will re-run whenever the query changes:1234567891011function SearchResults() &#123; const [query, setQuery] = useState(&apos;react&apos;); const getFetchUrl = useCallback(() =&gt; &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125;, [query]); useEffect(() =&gt; &#123; const url = getFetchUrl(); &#125;, [getFetchUrl]); &#125;Thanks to useCallback, if query is the same, getFetchUrl also stays the same, and our effect doesn’t re-run. But if query changes, getFetchUrl will also change, and we will re-fetch the data. It’s a lot like when you change some cell in an Excel spreadsheet, and the other cells using it recalculate automatically.This is just a consequence of embracing the data flow and the synchronization mindset. The same solution works for function props passed from parents:12345678910111213141516function Parent() &#123; const [query, setQuery] = useState(&apos;react&apos;); const fetchData = useCallback(() =&gt; &#123; const url = &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125;, [query]); return &lt;Child fetchData=&#123;fetchData&#125; /&gt;&#125;function Child(&#123; fetchData &#125;) &#123; let [data, setData] = useState(null); useEffect(() =&gt; &#123; fetchData().then(setData); &#125;, [fetchData]); &#125;Since fetchData only changes inside Parent when its query state changes, our Child won’t refetch the data until it’s actually necessary for the app.Are Functions Part of the Data Flow?Interestingly, this pattern is broken with classes in a way that really shows the difference between the effect and lifecycle paradigms. Consider this translation:1234567891011121314151617class Parent extends Component &#123; state = &#123; query: &apos;react&apos; &#125;; fetchData = () =&gt; &#123; const url = &apos;https://hn.algolia.com/api/v1/search?query=&apos; + this.state.query; &#125;; render() &#123; return &lt;Child fetchData=&#123;this.fetchData&#125; /&gt;; &#125;&#125;class Child extends Component &#123; state = &#123; data: null &#125;; componentDidMount() &#123; this.props.fetchData(); &#125; render() &#123; &#125;&#125;You might be thinking: “Come on Dan, we all know that useEffect is like componentDidMount and componentDidUpdate combined, you can’t keep beating that drum!” Yet this doesn’t work even with componentDidUpdate:1234567891011class Child extends Component &#123; state = &#123; data: null &#125;; componentDidMount() &#123; this.props.fetchData(); &#125; componentDidUpdate(prevProps) &#123; if (this.props.fetchData !== prevProps.fetchData) &#123; this.props.fetchData(); &#125; &#125; render() &#123; &#125;&#125;Of course, fetchData is a class method! (Or, rather, a class property — but that doesn’t change anything.) It’s not going to be different because of a state change. So this.props.fetchData will stay equal to prevProps.fetchData and we’ll never refetch. Let’s just remove this condition then?123componentDidUpdate(prevProps) &#123; this.props.fetchData();&#125;Oh wait, this fetches on every re-render. (Adding an animation above in the tree is a fun way to discover it.) Maybe let’s bind it to a particular query?123render() &#123; return &lt;Child fetchData=&#123;this.fetchData.bind(this, this.state.query)&#125; /&gt;;&#125;But then this.props.fetchData !== prevProps.fetchData is always true, even if the query didn’t change! So we’ll always refetch.The only real solution to this conundrum with classes is to bite the bullet and pass the query itself into the Child component. The Child doesn’t actually end up using the query, but it can trigger a refetch when it changes:12345678910111213141516171819202122232425class Parent extends Component &#123; state = &#123; query: &apos;react&apos; &#125;; fetchData = () =&gt; &#123; const url = &apos;https://hn.algolia.com/api/v1/search?query=&apos; + this.state.query; &#125;; render() &#123; return &lt;Child fetchData=&#123;this.fetchData&#125; query=&#123;this.state.query&#125; /&gt;; &#125;&#125;class Child extends Component &#123; state = &#123; data: null &#125;; componentDidMount() &#123; this.props.fetchData(); &#125; componentDidUpdate(prevProps) &#123; if (this.props.query !== prevProps.query) &#123; this.props.fetchData(); &#125; &#125; render() &#123; &#125;&#125;Over the years of working with classes with React, I’ve gotten so used to passing unnecessary props down and breaking encapsulation of parent components that I only realized a week ago why we had to do it.With classes, function props by themselves aren’t truly a part of the data flow. Methods close over the mutable this variable so we can’t rely on their identity to mean anything. Therefore, even when we only want a function, we have to pass a bunch of other data around in order to be able to “diff” it. We can’t know whether this.props.fetchData passed from the parent depends on some state or not, and whether that state has just changed.With useCallback, functions can fully participate in the data flow. We can say that if the function inputs changed, the function itself has changed, but if not, it stayed the same. Thanks to the granularity provided by useCallback, changes to props like props.fetchData can propagate down automatically.Similarly, useMemo lets us do the same for complex objects:1234567function ColorPicker() &#123; const [color, setColor] = useState(&apos;pink&apos;); const style = useMemo(() =&gt; (&#123; color &#125;), [color]); return &lt;Child style=&#123;style&#125; /&gt;;&#125;I want to emphasize that putting useCallback everywhere is pretty clunky. It’s a nice escape hatch and it’s useful when a function is both passed down and called from inside an effect in some children. Or if you’re trying to prevent breaking memoization of a child component. But Hooks lend themselves better to avoiding passing callbacks down altogether.In the above examples, I’d much prefer if fetchData was either inside my effect (which itself could be extracted to a custom Hook) or a top-level import. I want to keep the effects simple, and callbacks in them don’t help that. (“What if some props.onComplete callback changes while the request was in flight?”) You can simulate the class behavior but that doesn’t solve race conditions.Speaking of Race ConditionsA classic data fetching example with classes might look like this:12345678910111213class Article extends Component &#123; state = &#123; article: null &#125;; componentDidMount() &#123; this.fetchData(this.props.id); &#125; async fetchData(id) &#123; const article = await API.fetchArticle(id); this.setState(&#123; article &#125;); &#125; &#125;As you probably know, this code is buggy. It doesn’t handle updates. So the second classic example you could find online is something like this:12345678910111213class Article extends Component &#123; state = &#123; article: null &#125;; componentDidMount() &#123; this.fetchData(this.props.id); &#125; componentDidUpdate(prevProps) &#123; if (prevProps.id !== this.props.id) &#123; this.fetchData(this.props.id); &#125; &#125; async fetchData(id) &#123; const article = await API.fetchArticle(id); this.setState(&#123; article &#125;); &#125; &#125;This is definitely better! But it’s still buggy. The reason it’s buggy is that the request may come out of order. So if I’m fetching {id: 10}, switch to {id: 20}, but the {id: 20} request comes first, the request that started earlier but finished later would incorrectly overwrite my state.This is called a race condition, and it’s typical in code that mixes async / await (which assumes something waits for the result) with top-down data flow (props or state can change while we’re in the middle of an async function).Effects don’t magically solve this problem, although they’ll warn you if you try to pass an async function to the effect directly. (We’ll need to improve that warning to better explain the problems you might run into.)If the async approach you use supports cancellation, that’s great! You can cancel the async request right in your cleanup function.Alternatively, the easiest stopgap approach is to track it with a boolean:1234567891011121314151617function Article(&#123; id &#125;) &#123; const [article, setArticle] = useState(null); useEffect(() =&gt; &#123; let didCancel = false; async function fetchData() &#123; const article = await API.fetchArticle(id); if (!didCancel) &#123; setArticle(article); &#125; &#125; fetchData(); return () =&gt; &#123; didCancel = true; &#125;; &#125;, [id]); &#125;This article goes into more detail about how you can handle errors and loading states, as well as extract that logic into a custom Hook. I recommend you to check it out if you’re interested to learn more about data fetching with Hooks.Raising the BarWith the class lifecycle mindset, side effects behave differently from the render output. Rendering the UI is driven by props and state, and is guaranteed to be consistent with them, but side effects are not. This is a common source of bugs.With the mindset of useEffect, things are synchronized by default. Side effects become a part of the React data flow. For every useEffect call, once you get it right, your component handles edge cases much better.However, the upfront cost of getting it right is higher. This can be annoying. Writing synchronization code that handles edge cases well is inherently more difficult than firing one-off side effects that aren’t consistent with rendering.This could be worrying if useEffect was meant to be the tool you use most of the time. However, it’s a low-level building block. It’s an early time for Hooks so everybody uses low-level ones all the time, especially in tutorials. But in practice, it’s likely the community will start moving to higher-level Hooks as good APIs gain momentum.I’m seeing different apps create their own Hooks like useFetch that encapsulates some of their app’s auth logic or useTheme which uses theme context. Once you have a toolbox of those, you don’t reach for useEffect that often. But the resilience it brings benefits every Hook built on top of it.So far, useEffect is most commonly used for data fetching. But data fetching isn’t exactly a synchronization problem. This is especially obvious because our deps are often []. What are we even synchronizing?In the longer term, Suspense for Data Fetching will allow third-party libraries to have a first-class way to tell React to suspend rendering until something async (anything: code, data, images) is ready.As Suspense gradually covers more data fetching use cases, I anticipate that useEffect will fade into background as a power user tool for cases when you actually want to synchronize props and state to some side effect. Unlike data fetching, it handles this case naturally because it was designed for it. But until then, custom Hooks like shown here are a good way to reuse data fetching logic.In ClosingNow that you know pretty much everything I know about using effects, check out the TLDR in the beginning. Does it make sense? Did I miss something? (I haven’t run out of paper yet!)I’d love to hear from you on Twitter! Thanks for reading.]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
        <category>React Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React Hooks</tag>
        <tag>useEffect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Complete Guide to useEffect（中文版）]]></title>
    <url>%2Farchives%2F4233.html</url>
    <content type="text"><![CDATA[本文由 简悦 SimpRead 转码， 原文地址 https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/你用 Hooks 写了一些组件，甚或写了一个小型应用。你可能很满意，使用它的 API 很舒服并且在这个过程中获得了一些小技巧。你甚至可能写了一些 custom Hooks 去抽离重复的逻辑（精简掉了 300 行代码），并且得意地展示给你的同事看，“干得漂亮”，他们如是说。但有时候当你使用useEffect你总觉得哪儿有点不对劲。你会嘀咕你可能遗漏了什么。它看起来像 class 的生命周期… 但真的是这样吗？你发觉自己在问类似下面的这些问题：🤔 如何用useEffect模拟componentDidMount生命周期？🤔 如何正确地在useEffect里请求数据？[]又是什么？🤔 我应该把函数当做 effect 的依赖吗？🤔 为什么有时候会出现无限重复请求的问题？🤔 为什么有时候在 effect 里拿到的是旧的 state 或 prop？当我刚开始使用 Hooks 的时候，我也同样被上面这些问题所困扰。甚至当我写最初的文档时，我也并没有扎实地掌握某些细节。我经历了一些 “啊哈” 的开窍时刻，我想把这些分享给你。这篇文章会深入讲解帮你明白上面问题的答案。在看答案之前，我们需要先往后退一步。这篇文章的目的不是给你一个要点清单，而是想帮你真正地领会useEffect。其实我们并没有太多需要学习的，事实上，我们会花很多时间试图忘记某些已经习得的概念（unlearning）。当我不再透过熟悉的 class 生命周期方法去窥视useEffect 这个 Hook 的时候，我才得以融会贯通。“忘记你已经学到的。” — Yoda这篇文章会假设你对 useEffect API 有一定程度的了解。这篇文章真的很长。它更像一本 mini 书，这也是我更喜欢的形式。如果你很匆忙或者并不是太关心本文主题的话，你也可以直接看下面的摘要。如果你对于深入研究感觉不是很适应的话，你或许可以等下面这些解释出现在其他文章中再去了解也行。就像 2013 年 React 刚出世的时候，大家需要时间去理解消化一种不同的心智模型。知识也需要时间去普及。摘要如果你不想阅读整篇文章，可以快速浏览这份摘要。要是某些部分不容易理解，你可以往下滚动寻找相关的内容去阅读。如果你打算阅读整篇文章，你完全可以跳过这部分。我会在文章末尾带上摘要的链接。🤔 Question: 如何用useEffect模拟componentDidMount生命周期？虽然可以使用useEffect(fn, [])，但它们并不完全相等。和componentDidMount不一样，useEffect会_捕获_ props 和 state。所以即便在回调函数里，你拿到的还是初始的 props 和 state。如果你想得到 “最新” 的值，你可以使用 ref。不过，通常会有更简单的实现方式，所以你并不一定要用 ref。记住，effects 的心智模型和componentDidMount以及其他生命周期是不同的，试图找到它们之间完全一致的表达反而更容易使你混淆。想要更有效，你需要 “think in effects”，它的心智模型更接近于实现状态同步，而不是响应生命周期事件。🤔 Question: 如何正确地在useEffect里请求数据？[]又是什么？这篇文章 是很好的入门，介绍了如何在useEffect里做数据请求。请务必读完它！它没有我的这篇这么长。[]表示 effect 没有使用任何 React 数据流里的值，因此该 effect 仅被调用一次是安全的。[]同样也是一类常见问题的来源，也即你以为没使用数据流里的值但其实使用了。你需要学习一些策略（主要是useReducer 和 useCallback）来移除这些 effect 依赖，而不是错误地忽略它们。🤔 Question: 我应该把函数当做 effect 的依赖吗？一般建议把不依赖 props 和 state 的函数提到你的组件外面，并且把那些仅被 effect 使用的函数放到 effect 里面。如果这样做了以后，你的 effect 还是需要用到组件内的函数（包括通过 props 传进来的函数），可以在定义它们的地方用useCallback包一层。为什么要这样做呢？因为这些函数可以访问到 props 和 state，因此它们会参与到数据流中。我们官网的 FAQ 有更详细的答案。🤔 Question: 为什么有时候会出现无限重复请求的问题？这个通常发生于你在 effect 里做数据请求并且没有设置 effect 依赖参数的情况。没有设置依赖，effect 会在每次渲染后执行一次，然后在 effect 中更新了状态引起渲染并再次触发 effect。无限循环的发生也可能是因为你设置的依赖总是会改变。你可以通过一个一个移除的方式排查出哪个依赖导致了问题。但是，移除你使用的依赖（或者盲目地使用[]）通常是一种错误的解决方式。你应该做的是解决问题的根源。举个例子，函数可能会导致这个问题，你可以把它们放到 effect 里，或者提到组件外面，或者用useCallback包一层。useMemo 可以做类似的事情以避免重复生成对象。🤔 为什么有时候在 effect 里拿到的是旧的 state 或 prop 呢？Effect 拿到的总是定义它的那次渲染中的 props 和 state。这能够避免一些 bugs，但在一些场景中又会有些讨人嫌。对于这些场景，你可以明确地使用可变的 ref 保存一些值（上面文章的末尾解释了这一点）。如果你觉得在渲染中拿到了一些旧的 props 和 state，且不是你想要的，你很可能遗漏了一些依赖。可以尝试使用这个 lint 规则来训练你发现这些依赖。可能没过几天，这种能力会变得像是你的第二天性。同样可以看我们官网 FAQ 中的这个回答。我希望这个摘要对你有所帮助！要不，我们开始正文。每一次渲染都有它自己的 Props and State在我们讨论 effects 之前，我们需要先讨论一下渲染（rendering）。我们来看一个计数器组件 Counter，注意高亮的那一行：1234567891011function Counter() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;高亮的代码究竟是什么意思呢？count 会 “监听” 状态的变化并自动更新吗？这么想可能是学习 React 的时候有用的第一直觉，但它并不是精确的心智模型。上面例子中，count仅是一个数字而已。它不是神奇的 “data binding”, “watcher”, “proxy”，或者其他任何东西。它就是一个普通的数字像下面这个一样：123const count = 42;&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;我们的组件第一次渲染的时候，从useState()拿到count的初始值0。当我们调用setCount(1)，React 会再次渲染组件，这一次count是1。如此等等：12345678910111213141516171819function Counter() &#123; const count = 0; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &#125;function Counter() &#123; const count = 1; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &#125;function Counter() &#123; const count = 2; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &#125;当我们更新状态的时候，React 会重新渲染组件。每一次渲染都能拿到独立的count 状态，这个状态值是函数中的一个常量。所以下面的这行代码没有做任何特殊的数据绑定：1&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;它仅仅只是在渲染输出中插入了 count 这个数字。这个数字由 React 提供。当setCount的时候，React 会带着一个不同的count值再次调用组件。然后，React 会更新 DOM 以保持和渲染输出一致。这里关键的点在于任意一次渲染中的count常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的count值独立于其他渲染。（关于这个过程更深入的探讨可以查看我的另一篇文章 React as a UI Runtime。）每一次渲染都有它自己的事件处理函数到目前为止一切都还好。那么事件处理函数呢？看下面的这个例子。它在三秒后会 alert 点击次数count：12345678910111213function Counter() &#123; const [count, setCount] = useState(0); function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + count); &#125;, 3000); &#125; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;button onClick=&#123;handleAlertClick&#125;&gt; Show alert &lt;/button&gt; &lt;/div&gt; );&#125;如果我按照下面的步骤去操作：点击增加 counter 到 3点击一下 “Show alert”点击增加 counter 到 5 并且在定时器回调触发前完成你猜 alert 会弹出什么呢？会是 5 吗？— 这个值是 alert 的时候 counter 的实时状态。或者会是 3 吗？— 这个值是我点击时候的状态。剧透预警来自己 试试吧！如果结果和你预料不一样，你可以想象一个更实际的例子：一个聊天应用在 state 中保存了当前接收者的 ID，以及一个发送按钮。 这篇文章深入探索了个中缘由。正确的答案就是 3。alert 会 “捕获” 我点击按钮时候的状态。（虽然有其他办法可以实现不同的行为，但现在我会专注于这个默认的场景。当我们在构建一种心智模型的时候，在可选的策略中分辨出 “最小阻力路径” 是非常重要的。）但它究竟是如何工作的呢？我们发现count在每一次函数调用中都是一个常量值。值得强调的是 — 我们的组件函数每次渲染都会被调用，但是每一次调用中count值都是常量，并且它被赋予了当前渲染中的状态值。这并不是 React 特有的，普通的函数也有类似的行为：1234567891011121314function sayHi(person) &#123; const name = person.name; setTimeout(() =&gt; &#123; alert(&apos;Hello, &apos; + name); &#125;, 3000);&#125;let someone = &#123;name: &apos;Dan&apos;&#125;;sayHi(someone);someone = &#123;name: &apos;Yuzhi&apos;&#125;;sayHi(someone);someone = &#123;name: &apos;Dominic&apos;&#125;;sayHi(someone);在 这个例子中, 外层的someone会被赋值很多次（就像在 React 中，_当前_的组件状态会改变一样）。然后，在sayHi函数中，局部常量name会和某次调用中的person关联。因为这个常量是局部的，所以每一次调用都是相互独立的。结果就是，当定时器回调触发的时候，每一个 alert 都会弹出它拥有的name。这就解释了我们的事件处理函数如何捕获了点击时候的count值。如果我们应用相同的替换原理，每一次渲染 “看到” 的是它自己的count：12345678910111213141516171819202122232425262728293031function Counter() &#123; const count = 0; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + count); &#125;, 3000); &#125; &#125;function Counter() &#123; const count = 1; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + count); &#125;, 3000); &#125; &#125;function Counter() &#123; const count = 2; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + count); &#125;, 3000); &#125; &#125;所以实际上，每一次渲染都有一个 “新版本” 的handleAlertClick。每一个版本的handleAlertClick“记住” 了它自己的 count：12345678910111213141516171819202122232425262728293031function Counter() &#123; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + 0); &#125;, 3000); &#125; &lt;button onClick=&#123;handleAlertClick&#125; /&gt; &#125;function Counter() &#123; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + 1); &#125;, 3000); &#125; &lt;button onClick=&#123;handleAlertClick&#125; /&gt; &#125;function Counter() &#123; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + 2); &#125;, 3000); &#125; &lt;button onClick=&#123;handleAlertClick&#125; /&gt; &#125;这就是为什么在这个 demo 中中，事件处理函数 “属于” 某一次特定的渲染，当你点击的时候，它会使用那次渲染中counter的状态值。在任意一次渲染中，props 和 state 是始终保持不变的。如果 props 和 state 在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都 “属于” 一次特定的渲染。即便是事件处理中的异步函数调用 “看到” 的也是这次渲染中的count值。备注：上面我将具体的count值直接内联到了handleAlertClick函数中。这种心智上的替换是安全的因为count 值在某次特定渲染中不可能被改变。它被声明成了一个常量并且是一个数字。这样去思考其他类型的值比如对象也同样是安全的，当然需要在我们都同意应该避免直接修改 state 这个前提下。通过调用setSomething(newObj)的方式去生成一个新的对象而不是直接修改它是更好的选择，因为这样能保证之前渲染中的 state 不会被污染。每次渲染都有它自己的 Effects这篇文章是关于 effects 的，但目前我们居然还没有讨论 effects！ 言归正传，由上面的分析得出一个结果，effects 其实并没有什么两样。让我们回到官网文档中的这个例子：12345678910111213function Counter() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;抛一个问题给你：effect 是如何读取到最新的count 状态值的呢？也许，是某种 “data binding” 或“watching”机制使得count能够在 effect 函数内更新？也或许count是一个可变的值，React 会在我们组件内部修改它以使我们的 effect 函数总能拿到最新的值？都不是。我们已经知道count是某个特定渲染中的常量。事件处理函数 “看到” 的是属于它那次特定渲染中的count状态值。对于 effects 也同样如此：并不是count的值在 “不变” 的 effect 中发生了改变，而是 effect 函数本身在每一次渲染中都不相同。每一个 effect 版本 “看到” 的count值都来自于它属于的那次渲染：12345678910111213141516171819202122function Counter() &#123; useEffect( () =&gt; &#123; document.title = `You clicked $&#123;0&#125; times`; &#125; ); &#125;function Counter() &#123; useEffect( () =&gt; &#123; document.title = `You clicked $&#123;1&#125; times`; &#125; ); &#125;function Counter() &#123; useEffect( () =&gt; &#123; document.title = `You clicked $&#123;2&#125; times`; &#125; ); &#125;React 会记住你提供的 effect 函数，并且会在每次更改作用于 DOM 并让浏览器绘制屏幕后去调用它。所以虽然我们说的是一个 effect（这里指更新 document 的 title），但其实每次渲染都是一个不同的函数 — 并且每个 effect 函数 “看到” 的 props 和 state 都来自于它属于的那次特定渲染。概念上，你可以想象 effects 是渲染结果的一部分。严格地说，它们并不是（为了允许 Hook 的组合并且不引入笨拙的语法或者运行时）。但是在我们构建的心智模型上，effect 函数_属于_某个特定的渲染，就像事件处理函数一样。为了确保我们已经有了扎实的理解，我们再回顾一下第一次的渲染过程：React: 给我状态为 0时候的 UI。你的组件:给你需要渲染的内容: &lt;p&gt;You clicked 0 times&lt;/p&gt;。记得在渲染完了之后调用这个 effect: () =&gt; { document.title = &#39;You clicked 0 times&#39; }。React: 没问题。开始更新 UI，喂浏览器，我要给 DOM 添加一些东西。浏览器: 酷，我已经把它绘制到屏幕上了。React: 好的， 我现在开始运行给我的 effect运行 () =&gt; { document.title = &#39;You clicked 0 times&#39; }。现在我们回顾一下我们点击之后发生了什么：你的组件: 喂 React, 把我的状态设置为1。React: 给我状态为 1时候的 UI。你的组件:给你需要渲染的内容: &lt;p&gt;You clicked 1 times&lt;/p&gt;。记得在渲染完了之后调用这个 effect： () =&gt; { document.title = &#39;You clicked 1 times&#39; }。React: 没问题。开始更新 UI，喂浏览器，我修改了 DOM。Browser: 酷，我已经将更改绘制到屏幕上了。React: 好的， 我现在开始运行属于这次渲染的 effect运行 () =&gt; { document.title = &#39;You clicked 1 times&#39; }。每一次渲染都有它自己的… 所有我们现在知道 effects 会在每次渲染后运行，并且概念上它是组件输出的一部分，可以 “看到” 属于某次特定渲染的 props 和 state。我们来做一个思想实验，思考下面的代码：12345678910111213function Counter() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`You clicked $&#123;count&#125; times`); &#125;, 3000); &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;如果我点击了很多次并且在 effect 里设置了延时，打印出来的结果会是什么呢？剧透预警你可能会认为这是一个很绕的题并且结果是反直觉的。完全错了！我们看到的就是顺序的打印输出 — 每一个都属于某次特定的渲染，因此有它该有的count值。你可以自己试一试：你可能会想：“它当然应该是这样的。否则还会怎么样呢？”不过，class 中的this.state并不是这样运作的。你可能会想当然以为下面的 class 实现和上面是相等的：12345componentDidUpdate() &#123; setTimeout(() =&gt; &#123; console.log(`You clicked $&#123;this.state.count&#125; times`); &#125;, 3000);&#125;然而，this.state.count总是指向_最新_的 count 值，而不是属于某次特定渲染的值。所以你会看到每次打印输出都是5：我觉得 Hooks 这么依赖 Javascript 闭包是挺讽刺的一件事。有时候组件的 class 实现方式会受闭包相关的苦（the canonical wrong-value-in-a-timeout confusion），但其实这个例子中真正的混乱来源是可变数据（React 修改了 class 中的this.state使其指向最新状态），并不是闭包本身的错。当封闭的值始终不会变的情况下闭包是非常棒的。这使它们非常容易思考因为你本质上在引用常量。正如我们所讨论的，props 和 state 在某个特定渲染中是不会改变的。顺便说一下，我们可以使用闭包修复上面的 class 版本…逆潮而动到目前为止，我们可以明确地喊出下面重要的事实：每一个组件内的函数（包括事件处理函数，effects，定时器或者 API 调用等等）会捕获某次渲染中定义的 props 和 state。所以下面的两个例子是相等的：1234567function Example(props) &#123; useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(props.counter); &#125;, 1000); &#125;); &#125;1234567function Example(props) &#123; const counter = props.counter; useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(counter); &#125;, 1000); &#125;); &#125;在组件内什么时候去读取 props 或者 state 是无关紧要的。因为它们不会改变。在单次渲染的范围内，props 和 state 始终保持不变。（解构赋值的 props 使得这一点更明显。）当然，有时候你可能_想_在 effect 的回调函数里读取最新的值而不是捕获的值。最简单的实现方法是使用 refs，这篇文章的最后一部分介绍了相关内容。需要注意的是当你想要从_过去渲染中的函数里读取未来的 props 和 state，你是在逆潮而动。虽然它并没有错_（有时候可能也需要这样做），但它因为打破了默认范式会使代码显得不够 “干净”。这是我们有意为之的，因为它能帮助突出哪些代码是脆弱的，是需要依赖时间次序的。在 class 中，如果发生这种情况就没那么显而易见了。下面这个计数器版本 模拟了 class 中的行为：1234567function Example() &#123; const [count, setCount] = useState(0); const latestCount = useRef(count); useEffect(() =&gt; &#123; latestCount.current = count; setTimeout(() =&gt; &#123; console.log(`You clicked $&#123;latestCount.current&#125; times`); &#125;, 3000); &#125;);在 React 中去直接修改值看上去有点怪异。然而，在 class 组件中 React 正是这样去修改this.state的。不像捕获的 props 和 state，你没法保证在任意一个回调函数中读取的latestCount.current是不变的。根据定义，你可以随时修改它。这就是为什么它不是默认行为，而是需要你主动选择这样做。那 Effect 中的清理又是怎样的呢？像 文档中解释的, 有些 effects 可能需要有一个清理步骤。本质上，它的目的是消除副作用（effect)，比如取消订阅。思考下面的代码:123456useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange); &#125;;&#125;);假设第一次渲染的时候props是{id: 10}，第二次渲染的时候是{id: 20}。你_可能_会认为发生了下面的这些事：React 清除了 {id: 10}的 effect。React 渲染{id: 20}的 UI。React 运行{id: 20}的 effect。(事实并不是这样。)如果依赖这种心智模型，你可能会认为清除过程 “看到” 的是旧的 props 因为它是在重新渲染之前运行的，新的 effect“看到”的是新的 props 因为它是在重新渲染之后运行的。这种心智模型直接来源于 class 组件的生命周期。不过它并不精确。让我们来一探究竟。React 只会在浏览器绘制后运行 effects。这使得你的应用更流畅因为大多数 effects 并不会阻塞屏幕的更新。Effect 的清除同样被延迟了。上一次的 effect 会在重新渲染后被清除：React 渲染{id: 20}的 UI。浏览器绘制。我们在屏幕上看到{id: 20}的 UI。React 清除{id: 10}的 effect。React 运行{id: 20}的 effect。你可能会好奇：如果清除上一次的 effect 发生在 props 变成{id: 20}之后，那它为什么还能 “看到” 旧的{id: 10}？你曾经来过这里… 🤔引用上半部分得到的结论:组件内的每一个函数（包括事件处理函数，effects，定时器或者 API 调用等等）会捕获定义它们的那次渲染中的 props 和 state。现在答案显而易见。effect 的清除并不会读取 “最新” 的 props。它只能读取到定义它的那次渲染中的 props 值：1234567891011121314151617181920212223242526function Example() &#123; useEffect( () =&gt; &#123; ChatAPI.subscribeToFriendStatus(10, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(10, handleStatusChange); &#125;; &#125; ); &#125;function Example() &#123; useEffect( () =&gt; &#123; ChatAPI.subscribeToFriendStatus(20, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(20, handleStatusChange); &#125;; &#125; ); &#125;王国会崛起转而复归尘土，太阳会脱落外层变为白矮星，最后的文明也迟早会结束。但是第一次渲染中 effect 的清除函数只能看到{id: 10}这个 props。这正是为什么 React 能做到在绘制后立即处理 effects — 并且默认情况下使你的应用运行更流畅。如果你的代码需要依然可以访问到老的 props。同步， 而非生命周期我最喜欢 React 的一点是它统一描述了初始渲染和之后的更新。这降低了你程序的熵。比如我有个组件像下面这样：1234567function Greeting(&#123; name &#125;) &#123; return ( &lt;h1 class&gt; Hello, &#123;name&#125; &lt;/h1&gt; );&#125;我先渲染&lt;Greeting /&gt;然后渲染&lt;Greeting /&gt;，和我直接渲染&lt;Greeting /&gt;并没有什么区别。在这两种情况中，我最后看到的都是 “Hello, Yuzhi”。人们总是说：“重要的是旅行过程，而不是目的地”。在 React 世界中，恰好相反。重要的是目的，而不是过程。这就是 JQuery 代码中 $.addClass 或 $.removeClass这样的调用（过程）和 React 代码中声明 CSS 类名应该是什么（目的）之间的区别。React 会根据我们当前的 props 和 state 同步到 DOM。“mount”和 “update” 之于渲染并没有什么区别。你应该以相同的方式去思考 effects。useEffect使你能够根据 props 和 state _同步_ React tree 之外的东西。1234567function Greeting(&#123; name &#125;) &#123; useEffect(() =&gt; &#123; document.title = &apos;Hello, &apos; + name; &#125;); return ( &lt;h1 class&gt; Hello, &#123;name&#125; &lt;/h1&gt; );&#125;这就是和大家熟知的 mount/update/unmount 心智模型之间细微的区别。理解和内化这种区别是非常重要的。如果你试图写一个 effect 会根据是否第一次渲染而表现不一致，你正在逆潮而动。如果我们的结果依赖于过程而不是目的，我们会在同步中犯错。先渲染属性 A，B 再渲染 C，和立即渲染 C 并没有什么区别。虽然他们可能短暂地会有点不同（比如请求数据时），但最终的结果是一样的。不过话说回来，在每一次渲染后都去运行所有的 effects 可能并不高效。（并且在某些场景下，它可能会导致无限循环。）所以我们该怎么解决这个问题？告诉 React 去比对你的 Effects其实我们已经从 React 处理 DOM 的方式中学习到了解决办法。React 只会更新 DOM 真正发生改变的部分，而不是每次渲染都大动干戈。当你把123&lt;h1 class&gt; Hello, Dan&lt;/h1&gt;更新到123&lt;h1 class&gt; Hello, Yuzhi&lt;/h1&gt;React 能够看到两个对象:12const oldProps = &#123;className: &apos;Greeting&apos;, children: &apos;Hello, Dan&apos;&#125;;const newProps = &#123;className: &apos;Greeting&apos;, children: &apos;Hello, Yuzhi&apos;&#125;;它会检测每一个 props，并且发现children发生改变需要更新 DOM，但className并没有。所以它只需要这样做：1domNode.innerText = &apos;Hello, Yuzhi&apos;;我们也可以用类似的方式处理 effects 吗？如果能够在不需要的时候避免调用 effect 就太好了。举个例子，我们的组件可能因为状态变更而重新渲染：12345678910111213function Greeting(&#123; name &#125;) &#123; const [counter, setCounter] = useState(0); useEffect(() =&gt; &#123; document.title = &apos;Hello, &apos; + name; &#125;); return ( &lt;h1 class&gt; Hello, &#123;name&#125; &lt;button onClick=&#123;() =&gt; setCounter(counter + 1)&#125;&gt; Increment &lt;/button&gt; &lt;/h1&gt; );&#125;但是我们的 effect 并没有使用counter这个状态。我们的 effect 只会同步name属性给document.title，但name并没有变。在每一次 counter 改变后重新给document.title赋值并不是理想的做法。好了，那 React 可以… 区分 effects 的不同吗？12let oldEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;let newEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;并不能。React 并不能猜测到函数做了什么如果不先调用的话。（源码中并没有包含特殊的值，它仅仅是引用了name属性。）这是为什么你如果想要避免 effects 不必要的重复调用，你可以提供给useEffect一个依赖数组参数 (deps)：123useEffect(() =&gt; &#123; document.title = &apos;Hello, &apos; + name;&#125;, [name]);这好比你告诉 React：“Hey，我知道你看不到这个函数里的东西，但我可以保证只使用了渲染中的name，别无其他。”如果当前渲染中的这些依赖项和上一次运行这个 effect 的时候值一样，因为没有什么需要同步 React 会自动跳过这次 effect：12345const oldEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;const oldDeps = [&apos;Dan&apos;];const newEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;const newDeps = [&apos;Dan&apos;];即使依赖数组中只有一个值在两次渲染中不一样，我们也不能跳过 effect 的运行。要同步所有！关于依赖项不要对 React 撒谎关于依赖项对 React 撒谎会有不好的结果。直觉上，这很好理解，但我曾看到几乎所有依赖 class 心智模型使用useEffect的人都试图违反这个规则。（我刚开始也这么干了！）1234567891011function SearchResults() &#123; async function fetchData() &#123; &#125; useEffect(() =&gt; &#123; fetchData(); &#125;, []); &#125;(官网的 Hooks FAQ 解释了应该怎么做。 我们在下面会重新回顾这个例子。)“但我只是想在挂载的时候运行它！”，你可能会说。现在只需要记住：如果你设置了依赖项，effect 中用到的所有组件内的值都要包含在依赖中。这包括 props，state，函数 — 组件内的任何东西。有时候你是这样做了，但可能会引起一个问题。比如，你可能会遇到无限请求的问题，或者 socket 被频繁创建的问题。解决问题的方法不是移除依赖项。我们会很快了解具体的解决方案。不过在我们深入解决方案之前，我们先尝试更好地理解问题。如果设置了错误的依赖会怎么样呢？如果依赖项包含了所有 effect 中使用到的值，React 就能知道何时需要运行它：123useEffect(() =&gt; &#123; document.title = &apos;Hello, &apos; + name;&#125;, [name]);(依赖发生了变更，所以会重新运行 effect。)但是如果我们将[]设为 effect 的依赖，新的 effect 函数不会运行：123useEffect(() =&gt; &#123; document.title = &apos;Hello, &apos; + name;&#125;, []);(依赖没有变，所以不会再次运行 effect。)在这个例子中，问题看起来显而易见。但在某些情况下如果你脑子里 “跳出”class 组件的解决办法，你的直觉很可能会欺骗你。举个例子，我们来写一个每秒递增的计数器。在 Class 组件中，我们的直觉是：“开启一次定时器，清除也是一次”。这里有一个例子说明怎么实现它。当我们理所当然地把它用useEffect的方式翻译，直觉上我们会设置依赖为[]。“我只想运行一次 effect”，对吗？1234567891011function Counter() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, []); return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125;然而，这个例子只会递增一次。天了噜。如果你的心智模型是 “只有当我想重新触发 effect 的时候才需要去设置依赖”，这个例子可能会让你产生存在危机。你想要触发一次因为它是定时器 — 但为什么会有问题？如果你知道依赖是我们给 React 的暗示，告诉它 effect 所有需要使用的渲染中的值，你就不会吃惊了。effect 中使用了count但我们撒谎说它没有依赖。如果我们这样做迟早会出幺蛾子。在第一次渲染中，count是0。因此，setCount(count + 1)在第一次渲染中等价于setCount(0 + 1)。既然我们设置了[]依赖，effect 不会再重新运行，它后面每一秒都会调用setCount(0 + 1) ：123456789101112131415161718192021222324252627function Counter() &#123; useEffect( () =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(0 + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [] ); &#125;function Counter() &#123; useEffect( () =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(1 + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [] ); &#125;我们对 React 撒谎说我们的 effect 不依赖组件内的任何值，可实际上我们的 effect 有依赖！我们的 effect 依赖count - 它是组件内的值（不过在 effect 外面定义）：123456const count = useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, []);因此，设置[]为依赖会引入一个 bug。React 会对比依赖，并且跳过后面的 effect：(依赖没有变，所以不会再次运行 effect。)类似于这样的问题是很难被想到的。因此，我鼓励你将诚实地告知 effect 依赖作为一条硬性规则，并且要列出所以依赖。（我们提供了一个 lint 规则如果你想在你的团队内做硬性规定。）两种诚实告知依赖的方法有两种诚实告知依赖的策略。你应该从第一种开始，然后在需要的时候应用第二种。第一种策略是在依赖中包含所有 effect 中用到的组件内的值。让我们在依赖中包含count：12345useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, [count]);现在依赖数组正确了。虽然它可能不是太理想但确实解决了上面的问题。现在，每次count修改都会重新运行 effect，并且定时器中的setCount(count + 1)会正确引用某次渲染中的 count值：1234567891011121314151617181920212223242526function Counter() &#123; useEffect( () =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(0 + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [0] ); &#125;function Counter() &#123; useEffect( () =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(1 + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [1] ); &#125;这能解决问题但是我们的定时器会在每一次count改变后清除和重新设定。这应该不是我们想要的结果：(依赖发生了变更，所以会重新运行 effect。)第二种策略是修改 effect 内部的代码以确保它包含的值只会在需要的时候发生变更。我们不想告知错误的依赖 - 我们只是修改 effect 使得依赖更少。让我们来看一些移除依赖的常用技巧。让 Effects 自给自足我们想去掉 effect 的count依赖。12345useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, [count]);为了实现这个目的，我们需要问自己一个问题：我们为什么要用count？可以看到我们只在setCount调用中用到了count。在这个场景中，我们其实并不需要在 effect 中使用count。当我们想要根据前一个状态更新状态的时候，我们可以使用setState的函数形式：12345useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(c =&gt; c + 1); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, []);我喜欢把类似这种情况称为 “错误的依赖”。是的，因为我们在 effect 中写了setCount(count + 1)所以count是一个必需的依赖。但是，我们真正想要的是把count转换为count+1，然后返回给 React。可是 React 其实已经知道当前的count。我们需要告知 React 的仅仅是去递增状态 - 不管它现在具体是什么值。这正是setCount(c =&gt; c + 1)做的事情。你可以认为它是在给 React“发送指令”告知如何更新状态。这种 “更新形式” 在其他情况下也有帮助，比如你需要批量更新。注意我们做到了移除依赖，并且没有撒谎。我们的 effect 不再读取渲染中的count值。(依赖没有变，所以不会再次运行 effect。)你可以自己 试试。尽管 effect 只运行了一次，第一次渲染中的定时器回调函数可以完美地在每次触发的时候给 React 发送c =&gt; c + 1更新指令。它不再需要知道当前的count值。因为 React 已经知道了。函数式更新 和 Google Docs还记得我们说过同步才是理解 effects 的心智模型吗？同步的一个有趣地方在于你通常想要把同步的 “信息” 和状态解耦。举个例子，当你在 Google Docs 编辑文档的时候，Google 并不会把整篇文章发送给服务器。那样做会非常低效。相反的，它只是把你的修改以一种形式发送给服务端。虽然我们 effect 的情况不尽相同，但可以应用类似的思想。只在 effects 中传递最小的信息会很有帮助。类似于setCount(c =&gt; c + 1)这样的更新形式比setCount(count + 1)传递了更少的信息，因为它不再被当前的 count 值 “污染”。它只是表达了一种行为（“递增”）。“Thinking in React” 也讨论了如何找到最小状态。原则是类似的，只不过现在关注的是如何更新。表达_意图_（而不是结果）和 Google Docs 如何处理共同编辑异曲同工。虽然这个类比略微延伸了一点，函数式更新在 React 中扮演了类似的角色。它们确保能以批量地和可预测的方式来处理各种源头（事件处理函数，effect 中的订阅，等等）的状态更新。然而，即使是setCount(c =&gt; c + 1)也并不完美。它看起来有点怪，并且非常受限于它能做的事。举个例子，如果我们有两个互相依赖的状态，或者我们想基于一个 prop 来计算下一次的 state，它并不能做到。幸运的是， setCount(c =&gt; c + 1)有一个更强大的姐妹模式，它的名字叫useReducer。解耦来自 Actions 的更新我们来修改上面的例子让它包含两个状态：count 和 step。我们的定时器会每次在 count 上增加一个step值：12345678910111213141516function Counter() &#123; const [count, setCount] = useState(0); const [step, setStep] = useState(1); useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(c =&gt; c + step); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [step]); return ( &lt;&gt; &lt;h1&gt;&#123;count&#125;&lt;/h1&gt; &lt;input value=&#123;step&#125; onChange=&#123;e =&gt; setStep(Number(e.target.value))&#125; /&gt; &lt;/&gt; );&#125;(这里是 demo.)注意我们没有撒谎。既然我们在 effect 里使用了step，我们就把它加到依赖里。所以这也是为什么代码能运行正确。这个例子目前的行为是修改step会重启定时器 - 因为它是依赖项之一。在大多数场景下，这正是你所需要的。清除上一次的 effect 然后重新运行新的 effect 并没有任何错。除非我们有很好的理由，我们不应该改变这个默认行为。不过，假如我们不想在step改变后重启定时器，我们该如何从 effect 中移除对step的依赖呢？当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用useReducer去替换它们。当你写类似setSomething(something =&gt; ...)这种代码的时候，也许就是考虑使用 reducer 的契机。reducer 可以让你把组件内发生了什么 (actions) 和状态如何响应并更新分开表述。我们用一个dispatch依赖去替换 effect 的step依赖：1234567const [state, dispatch] = useReducer(reducer, initialState);const &#123; count, step &#125; = state;useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; dispatch(&#123; type: &apos;tick&apos; &#125;); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, [dispatch]);(查看 demo。)你可能会问：“这怎么就更好了？” 答案是 React 会保证dispatch在组件的声明周期内保持不变。所以上面例子中不再需要重新订阅定时器。我们解决了问题!（你可以从依赖中去除dispatch, setState, 和useRef包裹的值因为 React 会确保它们是静态的。不过你设置了它们作为依赖也没什么问题。）相比于直接在 effect 里面读取状态，它 dispatch 了一个 action 来描述发生了什么。这使得我们的 effect 和step状态解耦。我们的 effect 不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由 reducer 去统一处理:12345678910111213const initialState = &#123; count: 0, step: 1,&#125;;function reducer(state, action) &#123; const &#123; count, step &#125; = state; if (action.type === &apos;tick&apos;) &#123; return &#123; count: count + step, step &#125;; &#125; else if (action.type === &apos;step&apos;) &#123; return &#123; count, step: action.step &#125;; &#125; else &#123; throw new Error(); &#125;&#125;(这里是 demo 如果你之前错过了。)为什么 useReducer 是 Hooks 的作弊模式我们已经学习到如何移除 effect 的依赖，不管状态更新是依赖上一个状态还是依赖另一个状态。但假如我们需要依赖 props 去计算下一个状态呢？举个例子，也许我们的 API 是&lt;Counter step={1} /&gt;。确定的是，在这种情况下，我们没法避免依赖props.step 。是吗？实际上， 我们可以避免！我们可以把 reducer 函数放到组件内去读取 props：123456789101112131415161718function Counter(&#123; step &#125;) &#123; const [count, dispatch] = useReducer(reducer, 0); function reducer(state, action) &#123; if (action.type === &apos;tick&apos;) &#123; return state + step; &#125; else &#123; throw new Error(); &#125; &#125; useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; dispatch(&#123; type: &apos;tick&apos; &#125;); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [dispatch]); return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125;这种模式会使一些优化失效，所以你应该避免滥用它，不过如果你需要你完全可以在 reducer 里面访问 props。（这里是 demo。）即使是在这个例子中，React 也保证dispatch在每次渲染中都是一样的。 所以你可以在依赖中去掉它。它不会引起 effect 不必要的重复执行。你可能会疑惑：这怎么可能？在之前渲染中调用的 reducer 怎么 “知道” 新的 props？答案是当你dispatch的时候，React 只是记住了 action - 它会在下一次渲染中再次调用 reducer。在那个时候，新的 props 就可以被访问到，而且 reducer 调用也不是在 effect 里。这就是为什么我倾向认为useReducer是 Hooks 的 “作弊模式”。它可以把更新逻辑和描述发生了什么分开。结果是，这可以帮助我移除不必需的依赖，避免不必要的 effect 调用。把函数移到 Effects 里一个典型的误解是认为函数不应该成为依赖。举个例子，下面的代码看上去可以运行正常：12345678910111213function SearchResults() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); async function fetchData() &#123; const result = await axios( &apos;https://hn.algolia.com/api/v1/search?query=react&apos;, ); setData(result.data); &#125; useEffect(() =&gt; &#123; fetchData(); &#125;, []);(这个例子 改编自 Robin Wieruch 这篇很棒的文章 — 点击查看！)需要明确的是，上面的代码可以正常工作。但这样做在组件日渐复杂的迭代过程中我们很难确保它在各种情况下还能正常运行。想象一下我们的代码做下面这样的分离，并且每一个函数的体量是现在的五倍：123456789101112131415161718function SearchResults() &#123; function getFetchUrl() &#123; return &apos;https://hn.algolia.com/api/v1/search?query=react&apos;; &#125; async function fetchData() &#123; const result = await axios(getFetchUrl()); setData(result.data); &#125; useEffect(() =&gt; &#123; fetchData(); &#125;, []); &#125;然后我们在某些函数内使用了某些 state 或者 prop：12345678910111213141516171819function SearchResults() &#123; const [query, setQuery] = useState(&apos;react&apos;); function getFetchUrl() &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125; async function fetchData() &#123; const result = await axios(getFetchUrl()); setData(result.data); &#125; useEffect(() =&gt; &#123; fetchData(); &#125;, []); &#125;如果我们忘记去更新使用这些函数（很可能通过其他函数调用）的 effects 的依赖，我们的 effects 就不会同步 props 和 state 带来的变更。这当然不是我们想要的。幸运的是，对于这个问题有一个简单的解决方案。如果某些函数仅在 effect 中调用，你可以把它们的定义移到 effect 中：12345678function SearchResults() &#123; useEffect(() =&gt; &#123; function getFetchUrl() &#123; return &apos;https://hn.algolia.com/api/v1/search?query=react&apos;; &#125; async function fetchData() &#123; const result = await axios(getFetchUrl()); setData(result.data); &#125; fetchData(); &#125;, []); &#125;(这里是 demo.)这么做有什么好处呢？我们不再需要去考虑这些 “间接依赖”。我们的依赖数组也不再撒谎：在我们的 effect 中确实没有再使用组件范围内的任何东西。如果我们后面修改 getFetchUrl去使用query状态，我们更可能会意识到我们正在 effect 里面编辑它 - 因此，我们需要把query添加到 effect 的依赖里：12345678910111213141516function SearchResults() &#123; const [query, setQuery] = useState(&apos;react&apos;); useEffect(() =&gt; &#123; function getFetchUrl() &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125; async function fetchData() &#123; const result = await axios(getFetchUrl()); setData(result.data); &#125; fetchData(); &#125;, [query]); &#125;(这里是 demo.)添加这个依赖，我们不仅仅是在 “取悦 React”。在 query 改变后去重新请求数据是合理的。useEffect的设计意图就是要强迫你关注数据流的改变，然后决定我们的 effects 该如何和它同步 - 而不是忽视它直到我们的用户遇到了 bug。感谢eslint-plugin-react-hooks 插件的exhaustive-depslint 规则，它会在你编码的时候就分析 effects 并且提供可能遗漏依赖的建议。换句话说，机器会告诉你组件中哪些数据流变更没有被正确地处理。非常棒。但我不能把这个函数放到 Effect 里有时候你可能不想把函数移入 effect 里。比如，组件内有几个 effect 使用了相同的函数，你不想在每个 effect 里复制黏贴一遍这个逻辑。也或许这个函数是一个 prop。在这种情况下你应该忽略对函数的依赖吗？我不这么认为。再次强调，efffects 不应该对它的依赖撒谎。通常我们还有更好的解决办法。一个常见的误解是，“函数从来不会改变”。但是这篇文章你读到现在，你知道这显然不是事实。实际上，在组件内定义的函数每一次渲染都在变。函数每次渲染都会改变这个事实本身就是个问题。 比如有两个 effects 会调用 getFetchUrl:1234567891011121314151617function SearchResults() &#123; function getFetchUrl(query) &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125; useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;react&apos;); &#125;, []); useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;redux&apos;); &#125;, []); &#125;在这个例子中，你可能不想把getFetchUrl 移到 effects 中，因为你想复用逻辑。另一方面，如果你对依赖很 “诚实”，你可能会掉到陷阱里。我们的两个 effects 都依赖getFetchUrl，而它每次渲染都不同，所以我们的依赖数组会变得无用：1234567891011121314function SearchResults() &#123; function getFetchUrl(query) &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125; useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;react&apos;); &#125;, [getFetchUrl]); useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;redux&apos;); &#125;, [getFetchUrl]); &#125;一个可能的解决办法是把getFetchUrl从依赖中去掉。但是，我不认为这是好的解决方式。这会使我们后面对数据流的改变很难被发现从而忘记去处理。这会导致类似于上面 “定时器不更新值” 的问题。相反的，我们有两个更简单的解决办法。第一个， 如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在 effects 中使用：1234567891011121314function getFetchUrl(query) &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;&#125;function SearchResults() &#123; useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;react&apos;); &#125;, []); useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;redux&apos;); &#125;, []); &#125;你不再需要把它设为依赖，因为它们不在渲染范围内，因此不会被数据流影响。它不可能突然意外地依赖于 props 或 state。或者， 你也可以把它包装成 useCallback Hook:1234567891011121314function SearchResults() &#123; const getFetchUrl = useCallback((query) =&gt; &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125;, []); useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;react&apos;); &#125;, [getFetchUrl]); useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;redux&apos;); &#125;, [getFetchUrl]); &#125;useCallback本质上是添加了一层依赖检查。它以另一种方式解决了问题 - 我们使函数本身只在需要的时候才改变，而不是去掉对函数的依赖。我们来看看为什么这种方式是有用的。之前，我们的例子中展示了两种搜索结果（查询条件分别为&#39;react&#39;和&#39;redux&#39;）。但如果我们想添加一个输入框允许你输入任意的查询条件 (query)。不同于传递query参数的方式，现在getFetchUrl会从状态中读取。我们很快发现它遗漏了query依赖：如果我把query添加到useCallback 的依赖中，任何调用了getFetchUrl的 effect 在query改变后都会重新运行：1234567891011function SearchResults() &#123; const [query, setQuery] = useState(&apos;react&apos;); const getFetchUrl = useCallback(() =&gt; &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125;, [query]); useEffect(() =&gt; &#123; const url = getFetchUrl(); &#125;, [getFetchUrl]); &#125;我们要感谢useCallback，因为如果query 保持不变，getFetchUrl也会保持不变，我们的 effect 也不会重新运行。但是如果query修改了，getFetchUrl也会随之改变，因此会重新请求数据。这就像你在 Excel 里修改了一个单元格的值，另一个使用它的单元格会自动重新计算一样。这正是拥抱数据流和同步思维的结果。对于通过属性从父组件传入的函数这个方法也适用：12345678910111213141516function Parent() &#123; const [query, setQuery] = useState(&apos;react&apos;); const fetchData = useCallback(() =&gt; &#123; const url = &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125;, [query]); return &lt;Child fetchData=&#123;fetchData&#125; /&gt;&#125;function Child(&#123; fetchData &#125;) &#123; let [data, setData] = useState(null); useEffect(() =&gt; &#123; fetchData().then(setData); &#125;, [fetchData]); &#125;因为fetchData只有在Parent的query状态变更时才会改变，所以我们的Child只会在需要的时候才去重新请求数据。函数是数据流的一部分吗？有趣的是，这种模式在 class 组件中行不通，并且这种行不通恰到好处地揭示了 effect 和生命周期范式之间的区别。考虑下面的转换：1234567891011121314151617class Parent extends Component &#123; state = &#123; query: &apos;react&apos; &#125;; fetchData = () =&gt; &#123; const url = &apos;https://hn.algolia.com/api/v1/search?query=&apos; + this.state.query; &#125;; render() &#123; return &lt;Child fetchData=&#123;this.fetchData&#125; /&gt;; &#125;&#125;class Child extends Component &#123; state = &#123; data: null &#125;; componentDidMount() &#123; this.props.fetchData(); &#125; render() &#123; &#125;&#125;你可能会想：“少来了 Dan，我们都知道useEffect 就像componentDidMount 和 componentDidUpdate的结合，你不能老是破坏这一条！” 好吧，就算加了componentDidUpdate照样无用：1234567891011class Child extends Component &#123; state = &#123; data: null &#125;; componentDidMount() &#123; this.props.fetchData(); &#125; componentDidUpdate(prevProps) &#123; if (this.props.fetchData !== prevProps.fetchData) &#123; this.props.fetchData(); &#125; &#125; render() &#123; &#125;&#125;当然如此，fetchData是一个 class 方法！（或者你也可以说是 class 属性 - 但这不能改变什么。）它不会因为状态的改变而不同，所以this.props.fetchData和 prevProps.fetchData始终相等，因此不会重新请求。那我们删掉条件判断怎么样？123componentDidUpdate(prevProps) &#123; this.props.fetchData();&#125;等等，这样会在每次渲染后都去请求。(添加一个加载动画可能是一种有趣的发现这种情况的方式。) 也许我们可以绑定一个特定的 query?123render() &#123; return &lt;Child fetchData=&#123;this.fetchData.bind(this, this.state.query)&#125; /&gt;;&#125;但这样一来，this.props.fetchData !== prevProps.fetchData 表达式永远是true，即使query并未改变。这会导致我们总是去请求。想要解决这个 class 组件中的难题，唯一现实可行的办法是硬着头皮把query本身传入 Child 组件。 Child 虽然实际并没有直接_使用_这个query的值，但能在它改变的时候触发一次重新请求：12345678910111213141516171819202122232425class Parent extends Component &#123; state = &#123; query: &apos;react&apos; &#125;; fetchData = () =&gt; &#123; const url = &apos;https://hn.algolia.com/api/v1/search?query=&apos; + this.state.query; &#125;; render() &#123; return &lt;Child fetchData=&#123;this.fetchData&#125; query=&#123;this.state.query&#125; /&gt;; &#125;&#125;class Child extends Component &#123; state = &#123; data: null &#125;; componentDidMount() &#123; this.props.fetchData(); &#125; componentDidUpdate(prevProps) &#123; if (this.props.query !== prevProps.query) &#123; this.props.fetchData(); &#125; &#125; render() &#123; &#125;&#125;在使用 React 的 class 组件这么多年后，我已经如此习惯于把不必要的 props 传递下去并且破坏父组件的封装以至于我在一周之前才意识到我为什么一定要这样做。在 class 组件中，函数属性本身并不是数据流的一部分。组件的方法中包含了可变的this变量导致我们不能确定无疑地认为它是不变的。因此，即使我们只需要一个函数，我们也必须把一堆数据传递下去仅仅是为了做 “diff”。我们无法知道传入的this.props.fetchData 是否依赖状态，并且不知道它依赖的状态是否改变了。使用useCallback，函数完全可以参与到数据流中。我们可以说如果一个函数的输入改变了，这个函数就改变了。如果没有，函数也不会改变。感谢周到的useCallback，属性比如props.fetchData的改变也会自动传递下去。类似的，useMemo可以让我们对复杂对象做类似的事情。1234567function ColorPicker() &#123; const [color, setColor] = useState(&apos;pink&apos;); const style = useMemo(() =&gt; (&#123; color &#125;), [color]); return &lt;Child style=&#123;style&#125; /&gt;;&#125;我想强调的是，到处使用useCallback是件挺笨拙的事。当我们需要将函数传递下去并且函数会在子组件的 effect 中被调用的时候，useCallback 是很好的技巧且非常有用。或者你想试图减少对子组件的记忆负担，也不妨一试。但总的来说 Hooks 本身能更好地避免传递回调函数。在上面的例子中，我更倾向于把fetchData放在我的 effect 里（它可以抽离成一个自定义 Hook）或者是从顶层引入。我想让 effects 保持简单，而在里面调用回调会让事情变得复杂。（“如果某个props.onComplete回调改变了而请求还在进行中会怎么样？”）你可以模拟 class 的行为但那样并不能解决竞态的问题。说说竞态下面是一个典型的在 class 组件里发请求的例子：12345678910111213class Article extends Component &#123; state = &#123; article: null &#125;; componentDidMount() &#123; this.fetchData(this.props.id); &#125; async fetchData(id) &#123; const article = await API.fetchArticle(id); this.setState(&#123; article &#125;); &#125; &#125;你很可能已经知道，上面的代码埋伏了一些问题。它并没有处理更新的情况。所以第二个你能够在网上找到的经典例子是下面这样的：12345678910111213class Article extends Component &#123; state = &#123; article: null &#125;; componentDidMount() &#123; this.fetchData(this.props.id); &#125; componentDidUpdate(prevProps) &#123; if (prevProps.id !== this.props.id) &#123; this.fetchData(this.props.id); &#125; &#125; async fetchData(id) &#123; const article = await API.fetchArticle(id); this.setState(&#123; article &#125;); &#125; &#125;这显然好多了！但依旧有问题。有问题的原因是请求结果返回的顺序不能保证一致。比如我先请求 {id: 10}，然后更新到{id: 20}，但{id: 20}的请求更先返回。请求更早但返回更晚的情况会错误地覆盖状态值。这被叫做竞态，这在混合了async / await（假设在等待结果返回）和自顶向下数据流的代码中非常典型（props 和 state 可能会在 async 函数调用过程中发生改变）。Effects 并没有神奇地解决这个问题，尽管它会警告你如果你直接传了一个async 函数给 effect。（我们会改善这个警告来更好地解释你可能会遇到的这些问题。）如果你使用的异步方式支持取消，那太棒了。你可以直接在清除函数中取消异步请求。或者，最简单的权宜之计是用一个布尔值来跟踪它：1234567891011121314151617function Article(&#123; id &#125;) &#123; const [article, setArticle] = useState(null); useEffect(() =&gt; &#123; let didCancel = false; async function fetchData() &#123; const article = await API.fetchArticle(id); if (!didCancel) &#123; setArticle(article); &#125; &#125; fetchData(); return () =&gt; &#123; didCancel = true; &#125;; &#125;, [id]); &#125;这篇文章讨论了更多关于如何处理错误和加载状态，以及抽离逻辑到自定义的 Hook。我推荐你认真阅读一下如果你想学习更多关于如何在 Hooks 里请求数据的内容。提高水准在 class 组件生命周期的思维模型中，副作用的行为和渲染输出是不同的。UI 渲染是被 props 和 state 驱动的，并且能确保步调一致，但副作用并不是这样。这是一类常见问题的来源。而在useEffect的思维模型中，默认都是同步的。副作用变成了 React 数据流的一部分。对于每一个useEffect调用，一旦你处理正确，你的组件能够更好地处理边缘情况。然而，用好useEffect的前期学习成本更高。这可能让人气恼。用同步的代码去处理边缘情况天然就比触发一次不用和渲染结果步调一致的副作用更难。这难免让人担忧如果useEffect是你现在使用最多的工具。不过，目前大抵还处理低水平使用阶段。因为 Hooks 太新了所以大家都还在低水平地使用它，尤其是在一些教程示例中。但在实践中，社区很可能即将开始高水平地使用 Hooks，因为好的 API 会有更好的动量和冲劲。我看到不同的应用在创造他们自己的 Hooks，比如封装了应用鉴权逻辑的useFetch或者使用 theme context 的useTheme 。你一旦有了包含这些的工具箱，你就不会那么频繁地直接使用useEffect。但每一个基于它的 Hook 都能从它的适应能力中得到益处。目前为止，useEffect主要用于数据请求。但是数据请求准确说并不是一个同步问题。因为我们的依赖经常是[]所以这一点尤其明显。那我们究竟在同步什么？长远来看， Suspense 用于数据请求 会允许第三方库通过第一等的途径告诉 React 暂停渲染直到某些异步事物（任何东西：代码，数据，图片）已经准备就绪。当 Suspense 逐渐地覆盖到更多的数据请求使用场景，我预料useEffect 会退居幕后作为一个强大的工具，用于同步 props 和 state 到某些副作用。不像数据请求，它可以很好地处理这些场景因为它就是为此而设计的。不过在那之前，自定义的 Hooks 比如这儿提到的是复用数据请求逻辑很好的方式。在结束前现在你差不多知道了我关于如何使用 effects 的所有知识，可以检查一下开头的 TLDR。你现在觉得它说得有道理吗？我有遗漏什么吗？（我的纸还没有写完！）我很想在 Twitter 上听听你的想法。谢谢阅读。]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
        <category>React Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React Hooks</tag>
        <tag>useEffect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[What are React Hooks]]></title>
    <url>%2Farchives%2Fef81.html</url>
    <content type="text"><![CDATA[本文由 简悦 SimpRead 转码， 原文地址 https://www.robinwieruch.de/react-hooks/October 29, 2018 - Edit this Post on GitHubReact Hooks were introduced at React Conf October 2018 as a way to use state and side-effects in React function components. Whereas function components have been called functional stateless components (FSC) before, they are finally able to use state with React Hooks. Therefore, many people refer to them as function components now.In this walkthrough, I want to explain the motivation behind hooks, what will change in React and why we shouldn’t panic, and how React hooks can be used in function components by showcasing common React Hooks such as the state and effect hooks by example.React Hooks were invented by the React team to introduce state management and side-effects in function components. It’s their way of making it more effortless to use only React function components without the need to refactor a React function component to a React class component for using lifecycle methods, in order to use have side-effects, or local state. React Hooks enable us to write React applications with only function components.Unnecessary Component Refactorings: Previously, only React class components were used for local state management and lifecycle methods. The latter have been essential for introducing side-effects, such as listeners or data fetching, in React class components.12345678910111213141516171819202122232425262728import React from &apos;react&apos;;class Counter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0, &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; &gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default Counter;Only if you didn’t need state or lifecycle methods, React functional stateless components could be used. And because React function components are more lightweight (and elegant), people already used plenty of function components. This came with the drawback of refactoring components from React function components to React class components every time state or lifecycle methods were needed (and vice versa).1234567891011121314151617import React, &#123; useState &#125; from &apos;react&apos;;// how to use the state hook in a React function componentfunction Counter() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;export default Counter;With Hooks there is no need for this refactoring. Side-effects and state are finally available in React function components. That’s why a rebranding from functional stateless components to function components would be reasonable.Side-effect Logic: In React class components, side-effects were mostly introduced in lifecycle methods (e.g. componentDidMount, componentDidUpdate, componentWillUnmount). A side-effect could be fetching data in React or interacting with the Browser API. Usually these side-effects came with a setup and clean up phase. For instance, if you would miss to remove your listener, you could run into React performance issues.12345678910111213141516171819202122232425262728293031// side-effects in a React class componentclass MyComponent extends Component &#123; // setup phase componentDidMount() &#123; // add listener for feature 1 // add listener for feature 2 &#125; // clean up phase componentWillUnmount() &#123; // remove listener for feature 1 // remove listener for feature 2 &#125; ...&#125;// side-effects in React function component with React Hooksfunction MyComponent() &#123; useEffect(() =&gt; &#123; // add listener for feature 1 (setup) // return function to remove listener for feature 1 (clean up) &#125;); useEffect(() =&gt; &#123; // add listener for feature 2 (setup) // return function to remove listener for feature 2 (clean up) &#125;); ...&#125;Now, if you would introduce more than one of these side-effects in a React class component’s lifecycle methods, all side-effects would be grouped by lifecycle method but not by side-effect. That’s what React Hooks are going to change by encapsulating a side-effect in one hook whereas every hook has its own side-effect with a setup and clean up phase. You will see later in a tutorial how this works for real by adding and removing listeners in a React Hook.React’s Abstraction Hell: Abstraction and thus reusability were introduced with Higher-Order Components and Render Prop Components in React. There is also React’s Context with its Provider and Consumer Components that introduce another level of abstraction. All of these advanced patterns in React are using so called wrapping components. The implementation of the following components shouldn’t be foreign to developers who are creating larger React applications.12345678910111213141516171819import &#123; compose &#125; from &apos;recompose&apos;;import &#123; withRouter &#125; from &apos;react-router-dom&apos;;function App(&#123; history, state, dispatch &#125;) &#123; return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;Content theme=&#123;theme&#125;&gt; ... &lt;/Content&gt; &#125; &lt;/ThemeContext.Consumer&gt; );&#125;export default compose( withRouter, withReducer(reducer, initialState))(App);Sophie Alpert coined it “the wrapper hell” in React. You are not only seeing it in the implementation, but also when inspecting your components in the browser. There are dozens of wrapped components due to Render Prop Components (including Consumer components from React’s Context) and Higher-Order Components. It becomes an unreadable component tree, because all the abstracted logic is covered up in other React components. The actual visible components are hard to track down in the browser’s DOM. So what if these additional components were not needed because the logic is only encapsulated in functions as side-effects instead? Then you would remove all these wrapping components and flatten your component tree’s structure:12345678910111213function App() &#123; const theme = useTheme(); const history = useRouter(); const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;Content theme=&#123;theme&#125;&gt; ... &lt;/Content&gt; );&#125;export default App;That’s what React Hooks are bringing on the table. All side-effects are sitting directly in the component without introducing other components as container for business logic. The container disappears and the logic just sits in React Hooks that are only functions. Andrew Clark already left a statement in favor of React Hooks in his popular Higher-Order Component library called recompose.JavaScript Class Confusion: JavaScript mixes two worlds pretty well: Object-oriented programming (OOP) and functional programming. React introduces many developers to both worlds. On the one side, React (and Redux) introduced people to functional programming (FP) with function compositions, general programming concepts with functions (e.g. higher-order functions, JavaScript built-in methods like map, reduce, filter) and other terms such as immutability and side-effects. React itself didn’t really introduce these things, because they are features of the language or the programming paradigm itself, but they are heavily used in React whereas every React developer becomes automatically a better JavaScript developer.On the other side, React uses JavaScript classes as one way to define React components. A class is only the declaration whereas the actual usage of the component is the instantiation of it. It creates a class instance whereas the this object of the class instance is used to interact with class methods (e.g. setState, forceUpdate, other custom class methods). However, classes come with a steeper learning curve for React beginners who are not coming from an OOP background. That’s why class bindings, the this object and inheritance can be confusing. I have a few chapters in my React book focusing only on this aspect of React which is always the most confusing thing about React for beginners.123456789101112131415161718192021222324252627282930313233343536373839404142// I THOUGHT WE ARE USING A CLASS. WHY IS IT EXTENDING FROM SOMETHING?class Counter extends Component &#123; // WAIT ... THIS WORKS??? state = &#123; value: 0 &#125;; // I THOUGH IT&apos;S THIS WAY, BUT WHY DO I NEED PROPS HERE? // constructor(props) &#123; // SUPER??? // super(props); // // this.state = &#123; // value: 0, // &#125;; // &#125; // WHY DO I HAVE TO USE AN ARROW FUNCTION??? onIncrement = () =&gt; &#123; this.setState(state =&gt; (&#123; value: state.value + 1 &#125;)); &#125;; // SHOULDN&apos;T IT BE this.onDecrement = this.onDecrement.bind(this); in the constructor??? // WHAT&apos;S this.onDecrement = this.onDecrement.bind(this); DOING ANYWAY? onDecrement = () =&gt; &#123; this.setState(state =&gt; (&#123; value: state.value - 1 &#125;)); &#125;; render() &#123; return ( &lt;div&gt; &#123;this.state.value&#125; &#123;/* WHY IS EVERYTHING AVAILABLE ON &quot;THIS&quot;??? */&#125; &lt;button onClick=&#123;this.onIncrement&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;this.onDecrement&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;Now, many people argue React shouldn’t take JavaScript classes away because people don’t understand them. After all, they belong to the language. However, one of the hypotheses of introducing the Hooks API is a smoother learning curve for React beginners when writing their React components without JavaScript classes in the first place.Every time a new feature is introduced, people are concerned about it. There is one side of the group that is ecstatic about the change, and the other side that fears the change. I heard the most common concerns for React Hooks are:Everything changes! Subtle panic mode …React is becoming bloated like Angular!It’s useless, classes worked fine.It’s magic!Let me address these concerns here:Everything changes: React Hooks will change how we write React applications in the future. However, at the moment, nothing changes. You can still write class components with local state and lifecycle methods and deploy advanced patterns such as Higher-Order Components or Render Prop Components. Nobody takes these learnings away from you. See how I upgraded all my open source projects from older versions to React 16.6. and none of of these projects had problems. They are using HOCs, Render Props and I believe even the old context API (correct me if am wrong). Everything I have learned all these years still works. The React team makes sure that React stays backward compatible. It will be the same with React 16.7.React is becoming bloated like Angular: React was always seen as a library with a slim API. That’s true and shall be true in the future. However, in order to adjust things that were the status quo of building component-based applications a few years ago, and not to be overtaken by other libraries who adapt to the new status quo, React introduces changes in favor of older APIs. If React would start out fresh this year, maybe there would be only function components and hooks. But React was released a couple of years ago and needs to adapt to keep up with the status quo or to invent a status quo. Maybe there will follow deprecations of React class components and lifecycle methods in a few years in favor of React function components and hooks, but at the moment, the React team keeps React class components in their repertoire of tools. After all, the React team utilizes hooks as an invention to run a marathon with React an not to win a sprint. Obviously, React Hooks add yet another API to React, but it is in favor to simplify React’s API in the future. I like this transition more than having a React 2 where everything is different.It’s useless, classes worked fine: Imagine you would start from zero to learn React and you would be introduced to React with Hooks. Maybe create-react-app wouldn’t start out with a React class component but with a React function component. Everything you need to learn for your components would be React Hooks. They manage state and side-effects, so you would only need to know about the state and the effect hook. It’s everything a React class component did for you before. It will be simpler for React beginners to learn React without all the other overhead that comes with JavaScript classes (inheritance, this, bindings, super, …). Imagine React Hooks as a new way of how to write React components - It’s a new mindset. I am a skeptical person myself, but once I wrote a couple of simpler scenarios with React Hooks, I was convinced that this is the simplest way to write but also to learn React. As someone who is doing lots of React workshops, I argue that it takes away all the frustration classes bring on the table for React beginners.It’s magic: React is known to be down to earth with JavaScript. Writing React applications makes you a better JavaScript developer - that’s one of the best things about React when someone asks me: “Why should I learn React?”. Whether there comes another library in the future or not, everyone is prepared by honing their JavaScript skills and general programming skills when using React. It’s one of the things that made Redux, often used in React, popular: There is no magic, it is plain JavaScript. Now these React Hooks come along the way, introduce something stateful in a previously often pure function component, a couple of not easily to accept rules, and many don’t understand what’s going on under the hood. But think about it this way: A function component in React is not a mere function. You still have to import React as library to your source code file. It does something with your function, because the function becomes a function component in React land. This function component comes with hidden implementations that were there all the time. How else would it have been possible to use functions as function components as we did it before React Hooks were introduced? And people accepted it too, even though it’s kinda magic. Now, the only thing changed (and maybe it has already been this way before) is that these function components come with an extra hidden object that keeps track of hooks. To quote Dan Abramov from his article about hooks: “Perhaps you’re wondering where React keeps the state for Hooks. The answer is it’s kept in the exact same place where React keeps state for classes. React has an internal update queue which is the source of truth for any state, no matter how you define your components.”.Finally, think about it this way: Component-based solutions such as Angular, Vue, and React are pushing the boundaries of web development with every release. They build up on top of technologies that were invented more than two decades ago. They adapt them to make web development effortless in 2018 and not 1998. They optimize them like crazy to meet the needs in the here and now. We are building web applications with components and not with HTML templates anymore. We are not there yet, but I imagine a future where we sit together and invent a component-based standard for the browser. Angular, Vue and React are only the spearhead of this movement.In the following, I want to dive into a few popular React Hooks by example to get you up to speed. All examples can be found in this GitHub repository.You have seen the useState Hook before in a code snippet for a typical counter example. It is used to manage local state in function components. Let’s use the hook in a more elaborate example where we are going to manage an array of items. In another article of mine, you can learn more about managing arrays as state in React, but this time we are doing it with React hooks. Let’s get started:12345678910111213141516171819202122232425262728293031import React, &#123; useState &#125; from &apos;react&apos;;const INITIAL_LIST = [ &#123; id: &apos;0&apos;, title: &apos;React with RxJS for State Management Tutorial&apos;, url: &apos;https://www.robinwieruch.de/react-rxjs-state-management-tutorial/&apos;, &#125;, &#123; id: &apos;1&apos;, title: &apos;A complete React with Apollo and GraphQL Tutorial&apos;, url: &apos;https://www.robinwieruch.de/react-graphql-apollo-tutorial&apos;, &#125;,];function App() &#123; const [list, setList] = useState(INITIAL_LIST); return ( &lt;ul&gt; &#123;list.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;export default App;The useState hook accepts an initial state as argument and returns, by using array destructuring, two variables that can be named however you want to name them. Whereas the first variable is the actual state, the second variable is a function to update the state by providing a new state.The goal of this scenario is to remove an item from the list. In order to accomplish it, every item in the rendered list has a button with a click handler. The click handler can be inlined in the function component, because it will make use of list and setList later. Hence you don’t need to pass these variables to the handler, because they are already available from the outer scope of the component.123456789101112131415161718192021function App() &#123; const [list, setList] = useState(INITIAL_LIST); function onRemoveItem() &#123; // remove item from &quot;list&quot; // set the new list in state with &quot;setList&quot; &#125; return ( &lt;ul&gt; &#123;list.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;button type=&quot;button&quot; onClick=&#123;onRemoveItem&#125;&gt; Remove &lt;/button&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;Somehow we need to know about the item that should be removed from the list. Using a higher-order function, we can pass the identifier of the item to the handler function. Otherwise we wouldn’t be able to identify the item that should be removed from the list.123456789101112131415161718192021function App() &#123; const [list, setList] = useState(INITIAL_LIST); function onRemoveItem(id) &#123; // remove item from &quot;list&quot; // set the new list in state with &quot;setList&quot; &#125; return ( &lt;ul&gt; &#123;list.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; onRemoveItem(item.id)&#125;&gt; Remove &lt;/button&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;Finally, use the identifier to filter the list with a built-in array method. It returns a new list which is used to set the new state of the list.123456789101112131415161718192021function App() &#123; const [list, setList] = useState(INITIAL_LIST); function onRemoveItem(id) &#123; const newList = list.filter(item =&gt; item.id !== id); setList(newList); &#125; return ( &lt;ul&gt; &#123;list.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; onRemoveItem(item.id)&#125;&gt; Remove &lt;/button&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;That should do the job. You are able to remove an item from the list based on the identifier you pass to the handler. The handler then filters the list and sets the new state of the list with the setList function.The useState hook gives you everything you need to manage state in a function component: initial state, the latest state, and a state update function. Everything else is JavaScript again. Furthermore, you don’t need to bother about the state object with its shallow merge as before in a class component. Instead, you encapsulate one domain (e.g. list) with useState, but if you would need another state (e.g. counter), then just encapsulate this domain with another useState. You can read more about the useState hook in React’s documentation.Let’s head over to the next hook called useEffect. As mentioned before, function components should be able to manage state and side-effects with hooks. Managing state was showcased with the useState hook. Now comes the useEffect hook into play for side-effects which are usually used for interactions with the Browser/DOM API or external API like data fetching. Let’s see how the useEffect hook can be used for interaction with the Browser API by implementing a simple stopwatch. You can see how it is done in a React class component in this GitHub repository.1234567891011121314151617181920212223import React, &#123; useState &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); return ( &lt;div&gt; &#123;!isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt; Start &lt;/button&gt; )&#125; &#123;isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt; Stop &lt;/button&gt; )&#125; &lt;/div&gt; );&#125;export default App;There is no stopwatch yet. But at least there are is a conditional rendering to show either a “Start” or “Stop” button. The state for the boolean flag is managed by the useState hook.Let’s introduce our side-effect with useEffect that registers an interval. The function used for the interval emits a console logging every second to your developer tools of your browser.123456789101112131415161718192021222324252627import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); &#125;); return ( &lt;div&gt; &#123;!isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt; Start &lt;/button&gt; )&#125; &#123;isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt; Stop &lt;/button&gt; )&#125; &lt;/div&gt; );&#125;export default App;In order to remove the interval when the component unmounts (but also after every other render update), you can return a function in useEffect for anything to be called for the clean up. For instance, there shouldn’t be any memory leak left behind when the component isn’t there anymore.123456789101112131415import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); return () =&gt; clearInterval(interval); &#125;); ...&#125;export default App;Now, you want to setup the side-effect when mounting the component and the clean up the side-effect when unmounting the component. If you would log how many times the function within the effect is called, you would see that it sets a new interval every time the state of the component changes (e.g. click on “Start”/“Stop” button).12345678910111213141516import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; console.log(&apos;effect runs&apos;); const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); return () =&gt; clearInterval(interval); &#125;); ...&#125;export default App;In order to only run the effect on mount and unmount of the component, you can pass it an empty array as second argument.123456789101112131415import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); return () =&gt; clearInterval(interval); &#125;, []); ...&#125;export default App;However, since the interval is cleaned up after every render too, we need to set the interval in our update cycle too. But we can tell the effect to run only when the isOn variable changes. Only when one of the variables in the array changes, the effect will run during the update cycle. If you keep the array empty, the effect will only run on mount and unmount, because there is no variable to be checked for running the side-effect again.123456789101112131415import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); return () =&gt; clearInterval(interval); &#125;, [isOn]); ...&#125;export default App;The interval is running whether the isOn boolean is true or false. It would be great to only run it when the stopwatch is activated.12345678910111213141516171819import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; let interval; if (isOn) &#123; interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); &#125; return () =&gt; clearInterval(interval); &#125;, [isOn]); ...&#125;export default App;Now introduce another state in your function component to keep track of the timer of the stopwatch. It is used to update the timer, but only when the stopwatch is activated.123456789101112131415161718192021222324252627282930313233343536373839import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); const [timer, setTimer] = useState(0); useEffect(() =&gt; &#123; let interval; if (isOn) &#123; interval = setInterval( () =&gt; setTimer(timer + 1), 1000, ); &#125; return () =&gt; clearInterval(interval); &#125;, [isOn]); return ( &lt;div&gt; &#123;timer&#125; &#123;!isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt; Start &lt;/button&gt; )&#125; &#123;isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt; Stop &lt;/button&gt; )&#125; &lt;/div&gt; );&#125;export default App;There is still one mistake in the code. When the interval is running, it updates the timer every second by increasing it by one. However, it always relies on a stale state for the timer. Only when the inOn boolean flag changes the state is fine. In order to receive always the latest state for the timer when the interval is running, you can use a function instead for the state update function which always has the latest state.1234567891011121314151617181920212223import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); const [timer, setTimer] = useState(0); useEffect(() =&gt; &#123; let interval; if (isOn) &#123; interval = setInterval( () =&gt; setTimer(timer =&gt; timer + 1), 1000, ); &#125; return () =&gt; clearInterval(interval); &#125;, [isOn]); ...&#125;export default App;An alternative would have been to run the effect also when the timer changes. Then the effect would receive the latest timer state.1234567891011121314151617181920212223import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); const [timer, setTimer] = useState(0); useEffect(() =&gt; &#123; let interval; if (isOn) &#123; interval = setInterval( () =&gt; setTimer(timer + 1), 1000, ); &#125; return () =&gt; clearInterval(interval); &#125;, [isOn, timer]); ...&#125;export default App;That’s the implementation for the stopwatch that uses the Browser API If you want to continue, you can extend the example by providing a “Reset” button too.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); const [timer, setTimer] = useState(0); useEffect(() =&gt; &#123; let interval; if (isOn) &#123; interval = setInterval( () =&gt; setTimer(timer =&gt; timer + 1), 1000, ); &#125; return () =&gt; clearInterval(interval); &#125;, [isOn]); const onReset = () =&gt; &#123; setIsOn(false); setTimer(0); &#125;; return ( &lt;div&gt; &#123;timer&#125; &#123;!isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt; Start &lt;/button&gt; )&#125; &#123;isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt; Stop &lt;/button&gt; )&#125; &lt;button type=&quot;button&quot; disabled=&#123;timer === 0&#125; onClick=&#123;onReset&#125;&gt; Reset &lt;/button&gt; &lt;/div&gt; );&#125;export default App;That’s it. The useEffect hook is used for side-effects in React function components that are used for interacting with the Browser/DOM API or other third-party APIs (e.g. data fetching). You can read more about the useEffect hook in React’s documentation.Last but not least, after you have learned about the two most popular hooks that introduce state and side-effects in function components, there is one last thing I want to show you: custom hooks. That’s right, you can implement your own custom React Hooks that can be reused in your application or by others. Let’s see how they work with an example application which is able to detect whether your device is online or offline.12345678910111213import React, &#123; useState &#125; from &apos;react&apos;;function App() &#123; const [isOffline, setIsOffline] = useState(false); if (isOffline) &#123; return &lt;div&gt;Sorry, you are offline ...&lt;/div&gt;; &#125; return &lt;div&gt;You are online!&lt;/div&gt;;&#125;export default App;Again, introduce the useEffect hook for the side-effect. In this case, the effect adds and removes listeners that check if the device is online or offline. Both listeners are setup only once on mount and cleaned up once on unmount (empty array as second argument). Whenever one of the listeners is called, it sets the state for the isOffline boolean.12345678910111213141516171819202122232425262728293031import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOffline, setIsOffline] = useState(false); function onOffline() &#123; setIsOffline(true); &#125; function onOnline() &#123; setIsOffline(false); &#125; useEffect(() =&gt; &#123; window.addEventListener(&apos;offline&apos;, onOffline); window.addEventListener(&apos;online&apos;, onOnline); return () =&gt; &#123; window.removeEventListener(&apos;offline&apos;, onOffline); window.removeEventListener(&apos;online&apos;, onOnline); &#125;; &#125;, []); if (isOffline) &#123; return &lt;div&gt;Sorry, you are offline ...&lt;/div&gt;; &#125; return &lt;div&gt;You are online!&lt;/div&gt;;&#125;export default App;Everything is nicely encapsulated in one effect now. It’s a great functionality which should be reuse somewhere else too. That’s why we can extract the functionality as its a custom hook which follows the same naming convention as the other hooks.12345678910111213141516171819202122232425262728293031323334353637import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function useOffline() &#123; const [isOffline, setIsOffline] = useState(false); function onOffline() &#123; setIsOffline(true); &#125; function onOnline() &#123; setIsOffline(false); &#125; useEffect(() =&gt; &#123; window.addEventListener(&apos;offline&apos;, onOffline); window.addEventListener(&apos;online&apos;, onOnline); return () =&gt; &#123; window.removeEventListener(&apos;offline&apos;, onOffline); window.removeEventListener(&apos;online&apos;, onOnline); &#125;; &#125;, []); return isOffline;&#125;function App() &#123; const isOffline = useOffline(); if (isOffline) &#123; return &lt;div&gt;Sorry, you are offline ...&lt;/div&gt;; &#125; return &lt;div&gt;You are online!&lt;/div&gt;;&#125;export default App;Extracting the custom hook as function was not the only thing. You also have to return the isOffline state from the custom hook in order to use it in your application to show a message to users who are offline. Otherwise, it should render the normal application. That’s it for the custom hook that detects whether you are online or offline. You can read more about custom hooks in React’s documentation.React Hooks being reusable is the best thing about them, because there is the potential to grow an ecosystem of custom React Hooks that can be installed from npm for any React application. And not only for React applications. Evan You, creator of Vue, is hooked (!) by them as well. Maybe we will see a bridge between both ecosystems where it is possible to share hooks between Vue and React.If you want to dive deeper into the state and effect hooks, you can check out the following React hook tutorials:How to useReducer Hook?Migration from Class Components to HooksComparison useState vs useReducerModern State Management with HooksHow to fetch data with React HooksCheckout the official FAQ and Rules for hooks in React’s documentation to learn more about their fine-grained behaviour. In addition, you can checkout all officially available React Hooks too.For everyone who is still concerned about React Hooks: Give them a shot yourself. Implement a couple of React function components with state and side-effects. I had to do it myself to understand how they work and to feel comfortable with them. And I must say it feels pretty great to use them.The Road to learn ReactBuild a Hacker News App along the way. No setup configuration. No tooling. No Redux. Plain React in 200+ pages of learning material. Learn React like 50.000+ readers.Get the Book for freeNever miss an article about web development, JavaScript and self-growth.Take PartJoin 30.000+ DevelopersLearn Web Development with JavaScriptTips and TricksAccess Tutorials, eBooks and CoursesPersonal Development as a Software Engineer]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
        <category>React Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端相关文章收藏]]></title>
    <url>%2Farchives%2Ff37d.html</url>
    <content type="text"><![CDATA[前端架构支付宝前端应用架构的发展和选择]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>文章收藏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器重置密码]]></title>
    <url>%2Farchives%2Ffe92.html</url>
    <content type="text"><![CDATA[有时候会忘记服务器密码，但是可以通过官网面板等方式连上时，可使用下面的命令修改root密码：整段赋值下面的命令（”新密码”处 替换为要修改的密码）：1234echo root:新密码 |sudo chpasswd rootsudo sed -i &apos;s/^.*PermitRootLogin.*/PermitRootLogin yes/g&apos; /etc/ssh/sshd_config;sudo sed -i &apos;s/^.*PasswordAuthentication.*/PasswordAuthentication yes/g&apos; /etc/ssh/sshd_config;sudo reboot重启后用root账户登录即可。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Linux</tag>
        <tag>重置密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解密传统组件间通信与React组件间通信]]></title>
    <url>%2Farchives%2Fac71.html</url>
    <content type="text"><![CDATA[在React中最小的逻辑单元是组件，组件之间如果有耦合关系就会进行通信，本文将会介绍React中的组件通信的不同方式通过归纳范，可以将任意组件间的通信归类为四种类型的组件间通信，分别是父子组件，爷孙组件，兄弟组件和任意组件，需要注意的是前三个也可以算作任意组件的范畴，所以最后一个是万能方法父子组件父子组件间的通信分为父组件向子组件通信和子组件向父组件通信两种情况，下面先来介绍父组件向子组件通信，传统做法分为两种情况，分别是初始化时的参数传递和实例阶段的方法调用，例子如下12345678910111213141516171819202122232425262728class Child &#123; constructor(name) &#123; // 获取dom引用 this.$div = document.querySelector('#wp'); // 初始化时传入name this.updateName(name); &#125; updateName(name) &#123; // 对外提供更新的api this.name = name; // 更新dom this.$div.innerHTML = name; &#125;&#125;class Parent &#123; constructor() &#123; // 初始化阶段 this.child = new Child('yan'); setTimeout(() =&gt; &#123; // 实例化阶段 this.child.updateName('hou'); &#125;, 2000); &#125;&#125;在React中将两个情况统一处理，全部通过属性来完成，之所以能够这样是因为React在属性更新时会自动重新渲染子组件，下面的例子中，2秒后子组件会自动重新渲染，并获取新的属性值1234567891011121314151617181920class Child extends Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt; &#125;&#125;class Parent extends Component &#123; constructor() &#123; // 初始化阶段 this.state = &#123;name: 'yan'&#125;; setTimeout(() =&gt; &#123; // 实例化阶段 this.setState(&#123;name: 'hou'&#125;) &#125;, 2000); &#125; render() &#123; return &lt;Child name=&#123;this.state.name&#125; /&gt; &#125;&#125;下面来看一下子组件如何向父组件通信，传统做法有两种，一种是回调函数，另一种是为子组件部署消息接口先来看回调函数的例子，回调函数的优点是非常简单，缺点就是必须在初始化的时候传入，并且不可撤回，并且只能传入一个函数123456789101112131415class Child &#123; constructor(cb) &#123; // 调用父组件传入的回调函数，发送消息 setTimeout(() =&gt; &#123; cb() &#125;, 2000); &#125;&#125;class Parent &#123; constructor() &#123; // 初始化阶段，传入回调函数 this.child = new Child(function () &#123; console.log('child update') &#125;); &#125;&#125;下面来看看消息接口方法，首先需要一个可以发布和订阅消息的基类，比如下面实现了一个简单的EventEimtter，实际生产中可以直接使用别人写好的类库，比如@jsmini/event，子组件继承消息基类，就有了发布消息的能力，然后父组件订阅子组件的消息，即可实现子组件向父组件通信的功能消息接口的优点就是可以随处订阅，并且可以多次订阅，还可以取消订阅，缺点是略显麻烦，需要引入消息基类123456789101112131415161718192021222324252627282930313233// 消息接口，订阅发布模式，类似绑定事件，触发事件class EventEimtter &#123; constructor() &#123; this.eventMap = &#123;&#125;; &#125; sub(name, cb) &#123; const eventList = this.eventMap[name] = this.eventMap[name] || &#123;&#125;; eventList.push(cb); &#125; pub(name, ...data) &#123; (this.eventMap[name] || []).forEach(cb =&gt; cb(...data)); &#125;&#125;class Child extends EventEimtter &#123; constructor() &#123; super(); // 通过消息接口发布消息 setTimeout(() =&gt; &#123; this.pub('update') &#125;, 2000); &#125;&#125;class Parent &#123; constructor() &#123; // 初始化阶段，传入回调函数 this.child = new Child(); // 订阅子组件的消息 this.child.sub('update', function () &#123; console.log('child update') &#125;); &#125;&#125;Backbone.js就同时支持回调函数和消息接口方式，但React中选择了比较简单的回调函数模式，下面来看一下React的例子1234567891011121314class Child extends Component &#123; constructor(props) &#123; setTimeout(() =&gt; &#123; this.props.cb() &#125;, 2000); &#125; render() &#123; return &lt;div&gt;&lt;/div&gt; &#125;&#125;class Parent extends Component &#123; render() &#123; return &lt;Child cb=&#123;() =&gt; &#123;console.log('update')&#125;&#125; /&gt; &#125;&#125;爷孙组件父子组件其实可以算是爷孙组件的一种特例，这里的爷孙组件不光指爷爷和孙子，而是泛指祖先与后代组件通信，可能隔着很多层级，我们已经解决了父子组件通信的问题，根据化归法，很容易得出爷孙组件的答案，那就是层层传递属性么，把爷孙组件通信分解为多个父子组件通信的问题层层传递的优点是非常简单，用已有知识就能解决，问题是会浪费很多代码，非常繁琐，中间作为桥梁的组件会引入很多不属于自己的属性在React中，通过context可以让祖先组件直接把属性传递到后代组件，有点类似星际旅行中的虫洞一样，通过context这个特殊的桥梁，可以跨越任意层次向后代组件传递消息怎么在需要通信的组件之间开启这个虫洞呢？需要双向声明，也就是在祖先组件声明属性，并在后代组件上再次声明属性，然后在祖先组件上放上属性就可以了，就可以在后代组件读取属性了，下面看一个例子123456789101112131415161718192021222324import PropTypes from 'prop-types';class Child extends Component &#123; // 后代组件声明需要读取context上的数据 static contextTypes = &#123; text: PropTypes.string &#125; render() &#123; // 通过this.context 读取context上的数据 return &lt;div&gt;&#123;this.context.text&#125;&lt;/div&gt; &#125;&#125;class Ancestor extends Component &#123; // 祖先组件声明需要放入context上的数据 static childContextTypes = &#123; text: PropTypes.string &#125; // 祖先组件往context放入数据 getChildContext() &#123; return &#123;text: 'yanhaijing'&#125; &#125;&#125;context的优点是可以省去层层传递的麻烦，并且通过双向声明控制了数据的可见性，对于层数很多时，不失为一种方案；但缺点也很明显，就像全局变量一样，如果不加节制很容易造成混乱，而且也容易出现重名覆盖的问题个人的建议是对一些所有组件共享的只读信息可以采用context来传递，比如登录的用户信息等小贴士：React Router路由就是通过context来传递路由属性的兄弟组件如果两个组件是兄弟关系，可以通过父组件作为桥梁，来让两个组件之间通信，这其实就是主模块模式下面的例子中，两个子组件通过父组件来实现显示数字同步的功能123456789101112131415class Parent extends Component &#123; constructor() &#123; this.onChange = function (num) &#123; this.setState(&#123;num&#125;) &#125;.bind(this); &#125; render() &#123; return ( &lt;div&gt; &lt;Child1 num=&#123;this.state.num&#125; onChange=&#123;this.onChange&#125;&gt; &lt;Child2 num=&#123;this.state.num&#125; onChange=&#123;this.onChange&#125;&gt; &lt;/div&gt; ); &#125;&#125;主模块模式的优点就是解耦，把两个子组件之间的耦合关系，解耦成子组件和父组件之间的耦合，把分散的东西收集在一起好处非常明显，能带来更好的可维护性和可扩展性任意组件任意组件包括上面的三种关系组件，上面三种关系应该优先使用上面介绍的方法，对于任意的两个组件间通信，总共有三种办法，分别是共同祖先法，消息中间件和状态管理基于我们上面介绍的爷孙组件和兄弟组件，只要找到两个组件的共同祖先，就可以将任意组件之间的通信，转化为任意组件和共同祖先之间的通信，这个方法的好处就是非常简单，已知知识就能搞定，缺点就是上面两种模式缺点的叠加，除了临时方案，不建议使用这种方法另一种比较常用的方法是消息中间件，就是引入一个全局消息工具，两个组件通过这个全局工具进行通信，这样两个组件间的通信，就通过全局消息媒介完成了还记得上面介绍的消息基类吗？下面的例子中，组件1和组件2通过全局event进行通信12345678910111213141516171819202122232425262728293031class EventEimtter &#123; constructor() &#123; this.eventMap = &#123;&#125;; &#125; sub(name, cb) &#123; const eventList = this.eventMap[name] = this.eventMap[name] || &#123;&#125;; eventList.push(cb); &#125; pub(name, ...data) &#123; (this.eventMap[name] || []).forEach(cb =&gt; cb(...data)); &#125;&#125;// 全局消息工具const event = new EventEimtter;// 一个组件class Element1 extends Component &#123; constructor() &#123; // 订阅消息 event.sub('element2update', () =&gt; &#123;console.log('element2 update')&#125;); &#125;&#125;// 另一个组件。class Element2 extends Component &#123; constructor() &#123; // 发布消息 setTimeout(function () &#123; event.pub('element2update') &#125;, 2000) &#125;&#125;消息中间件的模式非常简单，利用了观察者模式，将两个组件之间的耦合解耦成了组件和消息中心+消息名称的耦合，但为了解耦却引入全局消息中心和消息名称，消息中心对组件的侵入性很强，和第三方组件通信不能使用这种方式小型项目比较适合使用这种方式，但随着项目规模的扩大，达到中等项目以后，消息名字爆炸式增长，消息名字的维护成了棘手的问题，重名概率极大，没有人敢随便删除消息信息，消息的发布者找不到消息订阅者的信息等其实上面的问题也不是没有解决办法，重名的问题可以通过制定规范，消息命名空间等方式来极大降低冲突，其他问题可以通过把消息名字统一维护到一个文件，通过对消息的中心化管理，可以让很多问题都很容易解决如果你的项目非常大，上面两种方案都不合适，那你可能需要一个状态管理工具，通过状态管理工具把组件之间的关系，和关系的处理逻辑从组建中抽象出来，并集中化到统一的地方来处理，Redux就是一个非常不错的状态管理工具除了Redux，还有Mobx，Rematch，reselect等工具，本文不展开介绍，有机会后面单独成文，这些都是用来解决不同问题的，只要根据自己的场景选择合适的工具就好了总结组件间的关系千变万化，都可以用上面介绍的方法解决，对于不同规模的项目，应该选择适合自己的技术方案，上面介绍的不同方式解耦的程度是不一样的，关于不同耦合关系的好坏，可以看我之前的文章《图解7种耦合关系》]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解7种耦合关系]]></title>
    <url>%2Farchives%2F7e29.html</url>
    <content type="text"><![CDATA[深入讲讲模块之间的耦合关系这个事情。本文将用图文详细讲解七种耦合的不同之处。高内聚与低耦合高内聚与低耦合是每个软件开发者追求的目标，那么内聚和耦合分别是什么意思呢？内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。耦合不同模块之间的关系就是耦合，根据耦合程度可以分为7种，耦合度依次变低。内容耦合公共耦合外部耦合控制耦合标记耦合数据耦合非直接耦合下面我们来说说每种耦合是什么，开始之前先来说下要实现的功能。m1和m2是两个独立的模块，其中m2种会显示m1的输入，m1会显示m2的输入。很显然，m1和m2两个模块之间会有一些联系（耦合），你也可以想想如何实现这个功能，下面用7种不同的方式来实现这个功能。注：项目的代码我放到了github，项目的demo，可以在这里查看。内容耦合内容耦合是最紧的耦合程度，一个模块直接访问另一模块的内容，则称这两个模块为内容耦合。为了实现功能，我们将m1的输入放到m2.m1input上，将m2的输入放到m1.m2input上。// m1.js root.m2.m1input = this.value; m2.update(); // m2.js root.m1.m2input = this.value; m1.update(); PS:不知道谁会这么写代码，除了我为了做演示之外。。。查看完整代码和demo。公共耦合一组模块都访问同一个全局数据结构，则称之为公共耦合。在这种case中，m1和m2将自己的输入放到全局的data上。// m1.js root.data.m1input = this.value; m2.update(); // m2.js root.data.m2input = this.value; m1.update(); 查看完整代码和demo。外部耦合一组模块都访问同一全局简单变量，而且不通过参数表传递该全局变量的信息，则称之为外部耦合。外部耦合和公共耦合很像，区别就是一个是简单变量，一个是复杂数据结构。在这种case中，m1和m2都将自己的输入放到全局上。// m1.js root.m1input = this.value; m2.update(); // m2.js root.m2input = this.value; m1.update(); 查看完整代码和demo。控制耦合模块之间传递的不是数据信息，而是控制信息例如标志、开关量等，一个模块控制了另一个模块的功能。从控制耦合开始，模块的数据就放在自己内部了，不同模块之间通过接口互相调用。在这个case中，得增加一个需求，就是当m1的输入为空时，隐藏m2的显示信息。// m1.js root.m1input = this.value; m2.update(); m2.toggle(!!this.value); // 传递flag 上面的代码中m1直接控制了m2的显示和隐藏。查看完整代码和demo。标记耦合调用模块和被调用模块之间传递数据结构而不是简单数据，同时也称作特征耦合。在这个case中，m1传给m2的是一个对象。// m1.js me.m1input = this.value; m2.update(me); // 传递引用 // m2.js me.m2input = this.value; m1.update(me); 查看完整代码和demo。数据耦合调用模块和被调用模块之间只传递简单的数据项参数。相当于高级语言中的值传递。在这个case中，m1传给m2的是一个简单数据结构。// m1.js me.m1input = this.value; m2.update(me.m1input); // 传递值 // m2.js me.m2input = this.value; m1.update(me.m2input); 查看完整代码和demo。非直接耦合两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。耦合度最弱，模块独立性最强。子模块无需知道对方的存在，子模块之间的联系，全部变成子模块和主模块之间的联系。在这个case种，增加一个index.js作为主模块。// index.js var m1 = root.m1; var m2 = root.m2; m1.init(function (str) { m2.update(str); }); m2.init(function (str) { m1.update(str); }); // m1.js me.m1input = this.value; inputcb(me.m1input); // inputcb是回调函数 // m2.js me.m2input = this.value; inputcb(me.m2input); 查看完整代码和demo。内聚其实关于内聚也分为很多种，如下所示，如果你感兴趣可以自己研究研究，我们下次再来分享内聚的问题。偶然内聚逻辑内聚时间内聚通信内聚顺序内聚功能内聚总结希望你看完上面的文章，搞懂了耦合的种类，也希望你以后能使用非直接耦合这种方式来写代码，祝好。]]></content>
      <categories>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鸡汤]]></title>
    <url>%2Farchives%2F201.html</url>
    <content type="text"><![CDATA[这是篇有密码的博客 c412f6b8aabc1c782cd41fa8b902a21d1796600928ce6b1c3a25b75f6a07ca6274c08a7f4c7697e988225692db0b452481c5b7af64963fe9c5d94782d809d1b1c732e74c0d68733bb0eb8c4b1311c36c233ad644b52e782ae7c0600e10ce00671e688c63b7774cecb3e8a45362bad7e628dd987a2c8927837b0f2045a957cc076a794fec723880484e383efc26009b7812ccb20bc3062723d4f162a9b5fbca4e21e7641848846a466936572ff43b183049a3535504c165496d9574ecb755ed9660526af58298222b1452dc28264b7568eafa606ecfb16bc584a3ec17e2634649110bc8ad92e743043071ea837876b0b7f0c8070048f97620541b0c595a28ba24e7bcc6d1148d104a04f787f430aac0390885fd9aaa169614b486b5c51e5b4fe7ae2800458c665ac5573747da1acd61c1be75de9ed9e2e992b725ceb6f5854be7c68a6fe0b0bd30a13e120a57ebec88fa4e7f0668c8230ba3e32a4a2cab380861a5cfd504c9160546a15163dad9ad1bb3620504e0e1c1e03eb117e70db50432ba327c3a821bbc50a1e20de3f959d5ed4e02d1d48fc03489986b2353df715456a063327601e640e4903cb8c94985e9d65773a023b8aedfd2f9cd952df50f5ba231c37c82a109bc446f693cb4ebe46222d4aea2f89114a35d80101e90ff1cb2d7c1ab253d6e6e2a5dec9d88c79752815cfea20c7a95512357d7b2dee73fab83d5a90395dd66c97d14ca470144221dd3ccb0e981c71f096dd5a82d98dcdc1c0d9bbe5059ea4b91512aa3d26a719ed39044800fe85a6d5544c92fa3a7e213d16fbe31e35b8f94f028bd2510185b058206578a195266c5db504755e5b4371fba90d058fb4edfd7479353e7cb0c285497b590d7ac37ec9788a96e625f58b01bd00b0e392de3147c7cf91110a093fe807cd5fc0bd764b4cd9fa6929d84964574ac5a6c3d5a2858f32e70ef27dd9bb24646ba8fcb74a2459a589c776c84431ae6e5ac4eafab126948b0fe2f4f959bab5d90935af7734643e206f921a9e497efe5236a7f8162bbf56228712296a87517294fe376daf174e75a328193d5051250d4ed819206d3efd9cf5d7e8d8e2ea50402c60b1e44b5771e94bbe037ab6af0d39ed5312a06bc930f04ec6bab59607e9b88746e7da19383f80aa9e4132dd6060c05f20a4e3705bf5c9993abc9f91f44ae53743059b8e7fb1125d321eeed975d69823e3367934947e508d416f282deb1533004bb5dd721e85abdb0843c87d4e1dd8fdf7cb1b191281982f04cda5c44d0d9c44184c17c9e8ba425eed6259129e261a6e15cb3a5294ea137d2db774aeae284c04b3fa11404e46a1d60f87ea888a372624df6e17e7fe4846d8d97aa4c5a6c179a9ccc274a331abe9336583648667d510e6533984e2b6ee2afe8a9d9edcfeeaa1abb5d4c1de0865c27e45fa84ed238eee0c85c4a7e282cf6d9075084b2958f159efbce0ea188b4f8f95570c405a4030357c8c6a4cb3cc094c0637fe87ce768606b39ce2d121a9e28a49b4237a91fcde0ac3154cfe410c51ccb6d5731cba482d1de3c102359a0ff5c096679b02d1f1220860795f3887b5fbf2a3f59287f44c05e3c943a52906ba3cd594142357906f18c579aa818e879e0a09f15265dc617e980324b00e09a09033445289f496dbe9d331b570b8f772d3edc73f7c8ebedae02e7cb732588c66c15106b9868121ec73ae9ef491b1118b126f3d54c0d2a0ac9a5689f9574dbc4ea69262f929ba7b15e701e5fd9a54c57ff19c44f0e0202d085090416815f474d510894c9bcfdec4f2ee19cd640dd507f1b086ee6b7433fc5da4dd2a505f3287c17de927236f1d6d3d9afeaa7dd58a5f65f99de74e8288a3ac249fee3140c5f6f8defd0ea695c5990e6fe27466b54d396360f40f3d75e623399b4c4e835dd8b369693a621d21f36e5ccfdca7853f90f4f8d4e7c9b258b8062bc2b15f4a17b0776bf4af875885f0482a4839238cad0829e6248468cf5a30a63e6f70b851cbaad4700889711cc274154085614cce9ba1d6aede846506d43263f41e7b5da895c60199dd8696f11267767b5a932928c33fbbee0b86720f25e44b6173d286ed691298b41eb3777959f1bfb183360ddd87c0d7ac0846adea911f40c4c36db5bf490fd0c35606397a45cdcfb203aa7fdc5ae58b91d9cac539c5ed03d8fc66f2e8d78b1cd1cc0990835177d64d206c3ebff7b5c9d763ced7b8540d5b2e84a81b4e434f6192ac9f24f1305350d2bf9c1fbeed68da1e4b986b93ee875cee1531bbb60c37f7d85b05203271fbaad58bf97596b8e09857da41a9fd37798dda901ae84ccad960d00d73553be3a6cd147858904cd040ed84161413ac239c2a3c47d7407975d2c896b7d22b340e407bb72e421c77bb1695e7d529139393efc39660f2e06876a8240a561b5c86d5c203ea9243b8dbc63bce6346740c150de41edda0a6cb41006fd35ec9290cd17de5a81533f7120951b6e844ccb09bef537749dcaf8c4bf7807f813f624243d0f6e56b8dfb466ebae18fd13cc66419eeebffc7c6f6150dbecb4f77584fbe5bcaae132804cf3a83efd45ddb0e676d3216e90d4b9e702e057f649a1cefd10e53c8eeb6a0b66dc95eb8fafd69a6956c115e6f86e8491eac08d8a0f07f58a30adc1b4fa691c9f04373c0695b79254837d7dfc12bf0ad7b684643586f4557f2f7d317a2ac748e803262a54143da8a67c5959d46a22cf2c981d0acc08c4840fb0bc7a8f501ff96ffd8015277a893f99024cc091f64bc2233d270e6903a53a6b20edf2b1ed264329299d4224c4e520f97172e5d2384d97c8d0d71240857d860b8d0b434644af7f08c0a68438bf652f7dfc0313fe95b5ec8e26211ad7631d5e0e23fbadfc40fcde1e243882c0e96b3c4fbee2dcb692b156fe68abada0135ffc8ff48b278c0427db073b14a3a7600ffc1dcf30d7df68c43867dceea38d8c5e502a7b8d66d317d6c7cad5e201040bc177e7196304223799e6ab93da05cfa19d09729418eac2ad0096eb6471c027e84cbafc338fed0abbe9cf57f1f39cda1bfcff19b22249fe4e3e8974095c80610ee7cd3d888e31596fb3c05fe6b06ff4b6971ae06461ed537f2658df0d840569685b05f650a51e3fd080b3a1a4efe2a2d306fb19b9d2ba5b82bc3293e7c4c3807ec8c9af2842cd8194979a175f25f015b00b60264180d995bc9ef0d45780d30a90ff0dc7a9802f9ebba534d6a94e30cab627bd1dcf3b137d3194094c1599f78ab8a9fb2d5c7d9d0026854c74d49990c136ba07aa76bf833dc9ad22759707275636dfdbd1decb92e642bd3970b2b6bf0f5bcd3b1077d3ec4ab9321cab6117c8fc126871555f5433f0dcbdd35ba2cc315dc843a76c9472381c3ca838f7ef0dd64e3725000570acc41873d4ebc545af9cc6f51489]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 技术栈]]></title>
    <url>%2Farchives%2F4a9b.html</url>
    <content type="text"><![CDATA[React 技术栈React 是目前最热门的前端框架。Facebook 公司2013年推出现在最好的社区支持和生态圈大量的第三方工具React 的优点组件模式：代码复用和团队分工虚拟 DOM：性能优势移动端支持：跨终端React 的缺点学习曲线较陡峭全新的一套概念，与其他所有框架截然不同只有采用它的整个技术栈，才能发挥最大威力总结：React 非常先进和强大，但是学习和实现成本都不低JSX 语法React 使用 JSX 语法，JavaScript 代码中可以写 HTML 代码。1let myTitle = &lt;h1&gt;Hello, world!&lt;/h1&gt;;JSX 语法解释（1）JSX 语法的最外层，只能有一个节点。12// 错误let myTitle = &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;;（2）JSX 语法中可以插入 JavaScript 代码，使用大括号。1let myTitle = &lt;p&gt;&#123;'Hello ' + 'World'&#125;&lt;/p&gt;Babel 转码器JavaScript 引擎（包括浏览器和 Node）都不认识 JSX，需要首先使用 Babel 转码，然后才能运行。123456&lt;script src="react.js"&gt;&lt;/script&gt;&lt;script src="react-dom.js"&gt;&lt;/script&gt;&lt;script src="babel.min.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt; // ** Our code goes here! **&lt;/script&gt;React 需要加载两个库：React 和 React-DOM，前者是 React 的核心库，后者是 React 的 DOM 适配库。Babel 用来在浏览器转换 JSX 语法，如果服务器已经转好了，浏览器就不需要加载这个库。课堂练习：JSX 语法浏览器打开demos/jsx-demo/index.html，按照《操作说明》，完成练习。1234ReactDOM.render( &lt;span&gt;Hello World!&lt;/span&gt;, document.getElementById('example'));示例：React 组件React 允许用户定义自己的组件，插入网页。浏览器打开demos/react-component-demo/index1.html，按照《操作说明》，仔细查看源码。12345678910class MyTitle extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello World&lt;/h1&gt;; &#125;&#125;;ReactDOM.render( &lt;MyTitle/&gt;, document.getElementById('example'));课堂练习：组件的参数组件可以从外部传入参数，内部使用this.props获取参数。打开demos/react-component-demo/index2.html，按照《操作说明》，完成练习。123456789class MyTitle extends React.Component &#123; render() &#123; return &lt;h1 style=&#123;&#123;color: this.props.color&#125;&#125; &gt;Hello World&lt;/h1&gt;; &#125;&#125;;&lt;MyTitle color="red" /&gt;,示例：组件的状态组件往往会有内部状态，使用this.state表示。浏览器打开demos/react-component-demo/index3.html，按照《操作说明》，仔细查看源码。课堂练习：React 组件实战浏览器打开demos/react-component-demo/index4.html，按照《操作说明》，完成练习。组件的生命周期React 为组件的不同生命阶段，提供了近十个钩子方法。componentWillMount()：组件加载前调用componentDidMount()：组件加载后调用componentWillUpdate(): 组件更新前调用componentDidUpdate(): 组件更新后调用componentWillUnmount()：组件卸载前调用componentWillReceiveProps()：组件接受新的参数时调用我们可以利用这些钩子，自动完成一些操作。课堂练习：组件的生命周期组件可以通过 Ajax 请求，从服务器获取数据。Ajax 请求一般在componentDidMount方法里面发出。123456componentDidMount() &#123; const url = '...'; $.getJSON(url) .done() .fail();&#125;打开demos/react-lifecycle-demo/index.html，按照《操作说明》，完成练习。React 组件库React 的一大优势，就是网上有很多已经写好的组件库，可以使用。React-Bootstrap：https://react-bootstrap.github.io/示例：ReChartsReCharts 是一个 React 图表组件库。http://recharts.org/浏览器打开demos/recharts-demo/index.html，按照《操作说明》，仔细查看源码，体会 JSX 语法对表达复杂组件的优势。1234567&lt;LineChart width=&#123;1000&#125; height=&#123;400&#125; data=&#123;data&#125;&gt; &lt;XAxis dataKey="name"/&gt; &lt;YAxis/&gt; &lt;CartesianGrid stroke="#eee" strokeDasharray="5 5"/&gt; &lt;Line type="monotone" dataKey="uv" stroke="#8884d8" /&gt; &lt;Line type="monotone" dataKey="pv" stroke="#82ca9d" /&gt;&lt;/LineChart&gt;React 的核心思想View 是 State 的输出。1view = f(state)上式中，f表示函数关系。只要 State 发生变化，View 也要随之变化。React 的本质是将图形界面（GUI）函数化。12345678const person = &#123; name: "michel", age: 31&#125;const App = (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body)React 没有解决的问题React 本身只是一个 DOM 的抽象层，使用组件构建虚拟 DOM。如果开发大应用，还需要解决两个问题。架构：大型应用程序应该如何组织代码？通信：组件之间如何通信？架构问题React 只是视图层的解决方案，可以用于任何一种架构。MVCMVVMObserverReactive…到底哪一种架构最合适 React ？通信问题组件会发生三种通信。向子组件发消息向父组件发消息向其他组件发消息React 只提供了一种通信手段：传参。对于大应用，很不方便。状态的同步通信的本质是状态的同步。React 同步状态的基本方法：找到通信双方最近的共同父组件，通过它的state，使得子组件的状态保持同步。Flux 架构Facebook 提出 Flux 架构的概念，被认为是 React 应用的标准架构。最大特点：数据单向流动。与 MVVM 的数据双向绑定，形成鲜明对比。Flux 的核心思想不同组件的state，存放在一个外部的、公共的 Store 上面。组件订阅 Store 的不同部分。组件发送（dispatch）动作（action），引发 Store 的更新。Flux 只是一个概念，有30多种实现。目前最流行的两个 React 架构React 架构的最重要作用：管理 Store 与 View 之间的关系。MobX：响应式（Reactive）管理，state 是可变对象，适合中小型项目Redux：函数式（Functional）管理，state 是不可变对象，适合大型项目MobX 架构MobX 的核心是观察者模式。Store 是被观察者（observable）组件是观察者（observer）一旦Store有变化，会立刻被组件观察到，从而引发重新渲染。MobX 的最简单例子1234567891011const &#123;observable&#125; = mobx;const &#123;observer&#125; = mobxReact;const person = observable(&#123;name: "张三", age: 31&#125;);const App = observer( (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;);ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body);person.name = "李四";代码：demos/mobx-demo/browser-demo目录示例：MobX进入demos/mobx-demo目录，按照《操作说明》，理解 MobX 框架。UI 层是观察者，Store 是被观察者。Store 所有的属性，分成两大类：直接被观察的属性和自动计算出来的属性。123456class Store &#123; @observable name = 'Bartek'; @computed get decorated() &#123; return `$&#123;this.name&#125; is awesome!`; &#125;&#125;UI 会观察到 Store 的变化，自动重新渲染。Redux 架构Redux 的核心概念所有的状态存放在Store。组件每次重新渲染，都必须由状态变化引起。用户在 UI 上发出action。reducer函数接收action，然后根据当前的state，计算出新的state。Redux 应用的架构Redux 层保存所有状态，React 组件拿到状态以后，渲染出 HTML 代码。示例：Redux进入demos/redux-demo目录，按照《操作说明》，理解 Redux 框架。Redux 将组件分成 UI 组件和容器组件两类。UI 组件是纯组件，不包含 state 和生命周期方法，不涉及组件的行为，只涉及组件的外观。1234567&lt;div className="index"&gt; &lt;p&gt;&#123;this.props.text&#125;&lt;/p&gt; &lt;input defaultValue=&#123;this.props.name&#125; onChange=&#123;this.props.onChange&#125; /&gt;&lt;/div&gt;容器组件正好相反。不涉及组件的外观，只涉及组件的行为。负责订阅 Store，将 Store 的数据处理以后，再通过参数传给 UI 组件。用户给出配置以后，由 Redux 生成。12345// MyComponent 是纯的 UI 组件const App = connect( mapStateToProps, mapDispatchToProps)(MyComponent);mapStateToProps: 定义 UI 组件参数与 State 之间的映射mapDispatchToProps：定义 UI 组件与 Action 之间的映射拆分 UI 组件和容器组件的好处UI 组件与后台数据无关，可以由设计师负责容器组件只负责数据和行为，一旦 Store 的数据结构变化，只要调整容器组件即可表现层和功能层脱钩，有利于代码重用，也有利于看清应用的数据结构和业务逻辑Reducer 函数reducer是一个纯函数，用来接收action，算出新的state。123456789101112function reducer(state = &#123; text: '你好，访问者', name: '访问者'&#125;, action) &#123; switch (action.type) &#123; case 'change': return &#123; name: action.payload, text: '你好，' + action.payload &#125;; &#125;&#125;Store由 Redux 提供的createStore方法生成，该方法接受reducer作为参数。为了把Store传入组件，必须使用 Redux 提供的Provider组件在应用的最外面，包裹一层。12345678const store = createStore(reducer);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.body.appendChild(document.createElement('div')));]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 设计思想]]></title>
    <url>%2Farchives%2F7615.html</url>
    <content type="text"><![CDATA[React 设计思想译者序：本文是 React 核心开发者、有 React API 终结者之称的 Sebastian Markbåge 撰写，阐述了他设计 React 的初衷。阅读此文，你能站在更高的高度思考 React 的过去、现在和未来。原文地址：https://github.com/reactjs/react-basic我写此文是想正式地阐述我心中 React 的心智模型。目的是解释为什么我们会这样设计 React，同时你也可以根据这些论点反推出 React。不可否认，此文中的部分论据或前提尚存争议，而且部分示例的设计可能存在 bug 或疏忽。这只是正式确定它的最初阶段。如果你有更好的完善它的想法可以随时提交 pull request。本文不会介绍框架细节中的奇技淫巧，相信这样能提纲挈领，让你看清 React 由简单到复杂的设计过程。React.js 的真实实现中充满了具体问题的解决方案，渐进式的解法，算法优化，历史遗留代码，debug 工具以及其他一些可以让它真的具有高可用性的内容。这些代码可能并不稳定，因为未来浏览器的变化和功能权重的变化随时面临改变。所以具体的代码很难彻底解释清楚。我偏向于选择一种我能完全 hold 住的简洁的心智模型来作介绍。变换（Transformation）设计 React 的核心前提是认为 UI 只是把数据通过映射关系变换成另一种形式的数据。同样的输入必会有同样的输出。这恰好就是纯函数。123function NameBox(name) &#123; return &#123; fontWeight: 'bold', labelContent: name &#125;;&#125;12&apos;Sebastian Markbåge&apos; -&gt;&#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125;;抽象（Abstraction）你不可能仅用一个函数就能实现复杂的 UI。重要的是，你需要把 UI 抽象成多个隐藏内部细节，又可复用的函数。通过在一个函数中调用另一个函数来实现复杂的 UI，这就是抽象。123456789function FancyUserBox(user) &#123; return &#123; borderStyle: '1px solid blue', childContent: [ 'Name: ', NameBox(user.firstName + ' ' + user.lastName) ] &#125;;&#125;12345678&#123; firstName: &apos;Sebastian&apos;, lastName: &apos;Markbåge&apos; &#125; -&gt;&#123; borderStyle: &apos;1px solid blue&apos;, childContent: [ &apos;Name: &apos;, &#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125; ]&#125;;组合（Composition）为了真正达到重用的特性，只重用叶子然后每次都为他们创建一个新的容器是不够的。你还需要可以包含其他抽象的容器再次进行组合。我理解的“组合”就是将两个或者多个不同的抽象合并为一个。12345678910111213function FancyBox(children) &#123; return &#123; borderStyle: '1px solid blue', children: children &#125;;&#125;function UserBox(user) &#123; return FancyBox([ 'Name: ', NameBox(user.firstName + ' ' + user.lastName) ]);&#125;状态（State）UI 不单单是对服务器端或业务逻辑状态的复制。实际上还有很多状态是针对具体的渲染目标。举个例子，在一个 text field 中打字。它不一定要复制到其他页面或者你的手机设备。滚动位置这个状态是一个典型的你几乎不会复制到多个渲染目标的。我们倾向于使用不可变的数据模型。我们把可以改变 state 的函数串联起来作为原点放置在顶层。1234567891011121314151617181920212223function FancyNameBox(user, likes, onClick) &#123; return FancyBox([ 'Name: ', NameBox(user.firstName + ' ' + user.lastName), 'Likes: ', LikeBox(likes), LikeButton(onClick) ]);&#125;// 实现细节var likes = 0;function addOneMoreLike() &#123; likes++; rerender();&#125;// 初始化FancyNameBox( &#123; firstName: 'Sebastian', lastName: 'Markbåge' &#125;, likes, addOneMoreLike);注意：本例更新状态时会带来副作用（addOneMoreLike 函数中）。我实际的想法是当一个“update”传入时我们返回下一个版本的状态，但那样会比较复杂。此示例待更新Memoization对于纯函数，使用相同的参数一次次调用未免太浪费资源。我们可以创建一个函数的 memorized 版本，用来追踪最后一个参数和结果。这样如果我们继续使用同样的值，就不需要反复执行它了。1234567891011121314151617181920212223function memoize(fn) &#123; var cachedArg; var cachedResult; return function(arg) &#123; if (cachedArg === arg) &#123; return cachedResult; &#125; cachedArg = arg; cachedResult = fn(arg); return cachedResult; &#125;;&#125;var MemoizedNameBox = memoize(NameBox);function NameAndAgeBox(user, currentTime) &#123; return FancyBox([ 'Name: ', MemoizedNameBox(user.firstName + ' ' + user.lastName), 'Age in milliseconds: ', currentTime - user.dateOfBirth ]);&#125;列表（Lists）大部分 UI 都是展示列表数据中不同 item 的列表结构。这是一个天然的层级。为了管理列表中的每一个 item 的 state ，我们可以创造一个 Map 容纳具体 item 的 state。123456789101112131415function UserList(users, likesPerUser, updateUserLikes) &#123; return users.map(user =&gt; FancyNameBox( user, likesPerUser.get(user.id), () =&gt; updateUserLikes(user.id, likesPerUser.get(user.id) + 1) ));&#125;var likesPerUser = new Map();function updateUserLikes(id, likeCount) &#123; likesPerUser.set(id, likeCount); rerender();&#125;UserList(data.users, likesPerUser, updateUserLikes);注意：现在我们向 FancyNameBox 传了多个不同的参数。这打破了我们的 memoization 因为我们每次只能存储一个值。更多相关内容在下面。连续性（Continuations）不幸的是，自从 UI 中有太多的列表，明确的管理就需要大量的重复性样板代码。我们可以通过推迟一些函数的执行，进而把一些模板移出业务逻辑。比如，使用“柯里化”（JavaScript 中的 bind）。然后我们可以从核心的函数外面传递 state，这样就没有样板代码了。下面这样并没有减少样板代码，但至少把它从关键业务逻辑中剥离。123456789101112function FancyUserList(users) &#123; return FancyBox( UserList.bind(null, users) );&#125;const box = FancyUserList(data.users);const resolvedChildren = box.children(likesPerUser, updateUserLikes);const resolvedBox = &#123; ...box, children: resolvedChildren&#125;;State Map之前我们知道可以使用组合避免重复执行相同的东西这样一种重复模式。我们可以把执行和传递 state 逻辑挪动到被复用很多的低层级的函数中去。12345678910111213141516171819202122232425262728function FancyBoxWithState( children, stateMap, updateState) &#123; return FancyBox( children.map(child =&gt; child.continuation( stateMap.get(child.key), updateState )) );&#125;function UserList(users) &#123; return users.map(user =&gt; &#123; continuation: FancyNameBox.bind(null, user), key: user.id &#125;);&#125;function FancyUserList(users) &#123; return FancyBoxWithState.bind(null, UserList(users) );&#125;const continuation = FancyUserList(data.users);continuation(likesPerUser, updateUserLikes);Memoization Map一旦我们想在一个 memoization 列表中 memoize 多个 item 就会变得很困难。因为你需要制定复杂的缓存算法来平衡调用频率和内存占有率。还好 UI 在同一个位置会相对的稳定。相同的位置一般每次都会接受相同的参数。这样以来，使用一个集合来做 memoization 是一个非常好用的策略。我们可以用对待 state 同样的方式，在组合的函数中传递一个 memoization 缓存。12345678910111213141516171819202122232425262728function memoize(fn) &#123; return function(arg, memoizationCache) &#123; if (memoizationCache.arg === arg) &#123; return memoizationCache.result; &#125; const result = fn(arg); memoizationCache.arg = arg; memoizationCache.result = result; return result; &#125;;&#125;function FancyBoxWithState( children, stateMap, updateState, memoizationCache) &#123; return FancyBox( children.map(child =&gt; child.continuation( stateMap.get(child.key), updateState, memoizationCache.get(child.key) )) );&#125;const MemoizedFancyNameBox = memoize(FancyNameBox);代数效应（Algebraic Effects）多层抽象需要共享琐碎数据时，一层层传递数据非常麻烦。如果能有一种方式可以在多层抽象中快捷地传递数据，同时又不需要牵涉到中间层级，那该有多好。React 中我们把它叫做“context”。有时候数据依赖并不是严格按照抽象树自上而下进行。举个例子，在布局算法中，你需要在实现他们的位置之前了解子节点的大小。现在，这个例子有一点超纲。我会使用 代数效应 这个由我发起的 ECMAScript 新特性提议。如果你对函数式编程很熟悉，它们 在避免由 monad 强制引入的仪式一样的编码。123456789101112131415161718192021222324function ThemeBorderColorRequest() &#123; &#125;function FancyBox(children) &#123; const color = raise new ThemeBorderColorRequest(); return &#123; borderWidth: '1px', borderColor: color, children: children &#125;;&#125;function BlueTheme(children) &#123; return try &#123; children(); &#125; catch effect ThemeBorderColorRequest -&gt; [, continuation] &#123; continuation('blue'); &#125;&#125;function App(data) &#123; return BlueTheme( FancyUserList.bind(null, data.users) );&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React中的state和props]]></title>
    <url>%2Farchives%2F992.html</url>
    <content type="text"><![CDATA[整理一下React中关于state和props的知识点。在任何应用中，数据都是必不可少的。我们需要直接的改变页面上一块的区域来使得视图的刷新，或者间接地改变其他地方的数据。React的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在props和state中，这两个属性有啥子区别呢？propsReact的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件。组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是props，所以可以把props理解为从外部传入组件内部的数据。由于React是单向数据流，所以props基本上也就是从服父级组件向子组件传递的数据。用法假设我们现在需要实现一个列表，根据React组件化思想，我们可以把列表中的行当做一个组件，也就是有这样两个组件：&lt;ItemList/&gt;和&lt;Item/&gt;。先看看&lt;ItemList/&gt;123456789import Item from &quot;./item&quot;;export default class ItemList extends React.Component&#123; const itemList = data.map(item =&gt; &lt;Item item=item /&gt;); render()&#123; return ( &#123;itemList&#125; ) &#125;&#125;列表的数据我们就暂时先假设是放在一个data变量中，然后通过map函数返回一个每一项都是&lt;Item item=&#39;数据&#39;/&gt;的数组，也就是说这里其实包含了data.length个&lt;Item/&gt;组件，数据通过在组件上自定义一个参数传递。当然，这里想传递几个自定义参数都可以。在&lt;Item /&gt;中是这样的：1234567export default class Item extends React.Component&#123; render()&#123; return ( &lt;li&gt;&#123;this.props.item&#125;&lt;/li&gt; ) &#125;&#125;在render函数中可以看出，组件内部是使用this.props来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个item属性，所以通过this.props.item来获取即可。只读性props经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的props是只读的，不可改变的。如果props在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的props传入组件中。默认参数在组件中，我们最好为props中的参数设置一个defaultProps，并且制定它的类型。比如，这样：1234567Item.defaultProps = &#123; item: &apos;Hello Props&apos;,&#125;;Item.propTypes = &#123; item: PropTypes.string,&#125;;关于propTypes，可以声明为以下几种类型：1234567optionalArray: PropTypes.array,optionalBool: PropTypes.bool,optionalFunc: PropTypes.func,optionalNumber: PropTypes.number,optionalObject: PropTypes.object,optionalString: PropTypes.string,optionalSymbol: PropTypes.symbol,注意，bool和func是简写。这些知识基础数据类型，还有一些复杂的，附上链接：https://facebook.github.io/react/docs/typechecking-with-proptypes.html总结props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。statestate是什么呢？State is similar to props, but it is private and fully controlled by the component.一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是props，而数据状态就是state。用法12345678910111213export default class ItemList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; itemList:&apos;一些数据&apos;, &#125; &#125; render()&#123; return ( &#123;this.state.itemList&#125; ) &#125;&#125;首先，在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。setStatestate不同于props的一点是，state是可以被改变的。不过，不可以直接通过this.state=的方式来修改，而需要通过this.setState()方法来修改state。比如，我们经常会通过异步操作来获取数据，我们需要在didMount阶段来执行异步操作：1234567componentDidMount()&#123; fetch(&apos;url&apos;) .then(response =&gt; response.json()) .then((data) =&gt; &#123; this.setState(&#123;itemList:item&#125;); &#125;&#125;当数据获取完成后，通过this.setState来修改数据状态。当我们调用this.setState方法时，React会更新组件的数据状态state，并且重新调用render方法，也就是会对组件进行重新渲染。注意：通过this.state=来初始化state，使用this.setState来修改state，constructor是唯一能够初始化的地方。setState接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：123456789101112export default class ItemList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name:&apos;axuebin&apos;, age:25, &#125; &#125; componentDidMount()&#123; this.setState(&#123;age:18&#125;) &#125;&#125;在执行完setState之后的state应该是{name:&#39;axuebin&#39;,age:18}。setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：123this.setState(&#123; name:&apos;xb&apos;&#125;,()=&gt;console.log(&apos;setState finished&apos;))总结state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。区别state是组件自己管理数据，控制自己的状态，可变；props是外部传入的数据参数，不可变；没有state的叫做无状态组件，有state的叫做有状态组件；多用props，少用state。也就是多写无状态组件。]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[useEffect 完整指南]]></title>
    <url>%2Farchives%2F1f7a.html</url>
    <content type="text"><![CDATA[本文由 简悦 SimpRead 转码， 原文地址 https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/你用 Hooks 写了一些组件，甚或写了一个小型应用。你可能很满意，使用它的 API 很舒服并且在这个过程中获得了一些小技巧。你甚至可能写了一些 custom Hooks 去抽离重复的逻辑（精简掉了 300 行代码），并且得意地展示给你的同事看，“干得漂亮”，他们如是说。但有时候当你使用useEffect你总觉得哪儿有点不对劲。你会嘀咕你可能遗漏了什么。它看起来像 class 的生命周期… 但真的是这样吗？你发觉自己在问类似下面的这些问题：🤔 如何用useEffect模拟componentDidMount生命周期？🤔 如何正确地在useEffect里请求数据？[]又是什么？🤔 我应该把函数当做 effect 的依赖吗？🤔 为什么有时候会出现无限重复请求的问题？🤔 为什么有时候在 effect 里拿到的是旧的 state 或 prop？当我刚开始使用 Hooks 的时候，我也同样被上面这些问题所困扰。甚至当我写最初的文档时，我也并没有扎实地掌握某些细节。我经历了一些 “啊哈” 的开窍时刻，我想把这些分享给你。这篇文章会深入讲解帮你明白上面问题的答案。在看答案之前，我们需要先往后退一步。这篇文章的目的不是给你一个要点清单，而是想帮你真正地领会useEffect。其实我们并没有太多需要学习的，事实上，我们会花很多时间试图忘记某些已经习得的概念（unlearning）。当我不再透过熟悉的 class 生命周期方法去窥视useEffect 这个 Hook 的时候，我才得以融会贯通。“忘记你已经学到的。” — Yoda这篇文章会假设你对 useEffect API 有一定程度的了解。这篇文章真的很长。它更像一本 mini 书，这也是我更喜欢的形式。如果你很匆忙或者并不是太关心本文主题的话，你也可以直接看下面的摘要。如果你对于深入研究感觉不是很适应的话，你或许可以等下面这些解释出现在其他文章中再去了解也行。就像 2013 年 React 刚出世的时候，大家需要时间去理解消化一种不同的心智模型。知识也需要时间去普及。摘要如果你不想阅读整篇文章，可以快速浏览这份摘要。要是某些部分不容易理解，你可以往下滚动寻找相关的内容去阅读。如果你打算阅读整篇文章，你完全可以跳过这部分。我会在文章末尾带上摘要的链接。🤔 Question: 如何用useEffect模拟componentDidMount生命周期？虽然可以使用useEffect(fn, [])，但它们并不完全相等。和componentDidMount不一样，useEffect会_捕获_ props 和 state。所以即便在回调函数里，你拿到的还是初始的 props 和 state。如果你想得到 “最新” 的值，你可以使用 ref。不过，通常会有更简单的实现方式，所以你并不一定要用 ref。记住，effects 的心智模型和componentDidMount以及其他生命周期是不同的，试图找到它们之间完全一致的表达反而更容易使你混淆。想要更有效，你需要 “think in effects”，它的心智模型更接近于实现状态同步，而不是响应生命周期事件。🤔 Question: 如何正确地在useEffect里请求数据？[]又是什么？这篇文章 是很好的入门，介绍了如何在useEffect里做数据请求。请务必读完它！它没有我的这篇这么长。[]表示 effect 没有使用任何 React 数据流里的值，因此该 effect 仅被调用一次是安全的。[]同样也是一类常见问题的来源，也即你以为没使用数据流里的值但其实使用了。你需要学习一些策略（主要是useReducer 和 useCallback）来移除这些 effect 依赖，而不是错误地忽略它们。🤔 Question: 我应该把函数当做 effect 的依赖吗？一般建议把不依赖 props 和 state 的函数提到你的组件外面，并且把那些仅被 effect 使用的函数放到 effect 里面。如果这样做了以后，你的 effect 还是需要用到组件内的函数（包括通过 props 传进来的函数），可以在定义它们的地方用useCallback包一层。为什么要这样做呢？因为这些函数可以访问到 props 和 state，因此它们会参与到数据流中。我们官网的 FAQ 有更详细的答案。🤔 Question: 为什么有时候会出现无限重复请求的问题？这个通常发生于你在 effect 里做数据请求并且没有设置 effect 依赖参数的情况。没有设置依赖，effect 会在每次渲染后执行一次，然后在 effect 中更新了状态引起渲染并再次触发 effect。无限循环的发生也可能是因为你设置的依赖总是会改变。你可以通过一个一个移除的方式排查出哪个依赖导致了问题。但是，移除你使用的依赖（或者盲目地使用[]）通常是一种错误的解决方式。你应该做的是解决问题的根源。举个例子，函数可能会导致这个问题，你可以把它们放到 effect 里，或者提到组件外面，或者用useCallback包一层。useMemo 可以做类似的事情以避免重复生成对象。🤔 为什么有时候在 effect 里拿到的是旧的 state 或 prop 呢？Effect 拿到的总是定义它的那次渲染中的 props 和 state。这能够避免一些 bugs，但在一些场景中又会有些讨人嫌。对于这些场景，你可以明确地使用可变的 ref 保存一些值（上面文章的末尾解释了这一点）。如果你觉得在渲染中拿到了一些旧的 props 和 state，且不是你想要的，你很可能遗漏了一些依赖。可以尝试使用这个 lint 规则来训练你发现这些依赖。可能没过几天，这种能力会变得像是你的第二天性。同样可以看我们官网 FAQ 中的这个回答。我希望这个摘要对你有所帮助！要不，我们开始正文。每一次渲染都有它自己的 Props and State在我们讨论 effects 之前，我们需要先讨论一下渲染（rendering）。我们来看一个计数器组件 Counter，注意高亮的那一行：1234567891011function Counter() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;高亮的代码究竟是什么意思呢？count 会 “监听” 状态的变化并自动更新吗？这么想可能是学习 React 的时候有用的第一直觉，但它并不是精确的心智模型。上面例子中，count仅是一个数字而已。它不是神奇的 “data binding”, “watcher”, “proxy”，或者其他任何东西。它就是一个普通的数字像下面这个一样：123const count = 42;&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;我们的组件第一次渲染的时候，从useState()拿到count的初始值0。当我们调用setCount(1)，React 会再次渲染组件，这一次count是1。如此等等：12345678910111213141516171819function Counter() &#123; const count = 0; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &#125;function Counter() &#123; const count = 1; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &#125;function Counter() &#123; const count = 2; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &#125;当我们更新状态的时候，React 会重新渲染组件。每一次渲染都能拿到独立的count 状态，这个状态值是函数中的一个常量。所以下面的这行代码没有做任何特殊的数据绑定：1&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;它仅仅只是在渲染输出中插入了 count 这个数字。这个数字由 React 提供。当setCount的时候，React 会带着一个不同的count值再次调用组件。然后，React 会更新 DOM 以保持和渲染输出一致。这里关键的点在于任意一次渲染中的count常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的count值独立于其他渲染。（关于这个过程更深入的探讨可以查看我的另一篇文章 React as a UI Runtime。）每一次渲染都有它自己的事件处理函数到目前为止一切都还好。那么事件处理函数呢？看下面的这个例子。它在三秒后会 alert 点击次数count：12345678910111213function Counter() &#123; const [count, setCount] = useState(0); function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + count); &#125;, 3000); &#125; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;button onClick=&#123;handleAlertClick&#125;&gt; Show alert &lt;/button&gt; &lt;/div&gt; );&#125;如果我按照下面的步骤去操作：点击增加 counter 到 3点击一下 “Show alert”点击增加 counter 到 5 并且在定时器回调触发前完成你猜 alert 会弹出什么呢？会是 5 吗？— 这个值是 alert 的时候 counter 的实时状态。或者会是 3 吗？— 这个值是我点击时候的状态。剧透预警来自己 试试吧！如果结果和你预料不一样，你可以想象一个更实际的例子：一个聊天应用在 state 中保存了当前接收者的 ID，以及一个发送按钮。 这篇文章深入探索了个中缘由。正确的答案就是 3。alert 会 “捕获” 我点击按钮时候的状态。（虽然有其他办法可以实现不同的行为，但现在我会专注于这个默认的场景。当我们在构建一种心智模型的时候，在可选的策略中分辨出 “最小阻力路径” 是非常重要的。）但它究竟是如何工作的呢？我们发现count在每一次函数调用中都是一个常量值。值得强调的是 — 我们的组件函数每次渲染都会被调用，但是每一次调用中count值都是常量，并且它被赋予了当前渲染中的状态值。这并不是 React 特有的，普通的函数也有类似的行为：1234567891011121314function sayHi(person) &#123; const name = person.name; setTimeout(() =&gt; &#123; alert(&apos;Hello, &apos; + name); &#125;, 3000);&#125;let someone = &#123;name: &apos;Dan&apos;&#125;;sayHi(someone);someone = &#123;name: &apos;Yuzhi&apos;&#125;;sayHi(someone);someone = &#123;name: &apos;Dominic&apos;&#125;;sayHi(someone);在 这个例子中, 外层的someone会被赋值很多次（就像在 React 中，_当前_的组件状态会改变一样）。然后，在sayHi函数中，局部常量name会和某次调用中的person关联。因为这个常量是局部的，所以每一次调用都是相互独立的。结果就是，当定时器回调触发的时候，每一个 alert 都会弹出它拥有的name。这就解释了我们的事件处理函数如何捕获了点击时候的count值。如果我们应用相同的替换原理，每一次渲染 “看到” 的是它自己的count：12345678910111213141516171819202122232425262728293031function Counter() &#123; const count = 0; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + count); &#125;, 3000); &#125; &#125;function Counter() &#123; const count = 1; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + count); &#125;, 3000); &#125; &#125;function Counter() &#123; const count = 2; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + count); &#125;, 3000); &#125; &#125;所以实际上，每一次渲染都有一个 “新版本” 的handleAlertClick。每一个版本的handleAlertClick“记住” 了它自己的 count：12345678910111213141516171819202122232425262728293031function Counter() &#123; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + 0); &#125;, 3000); &#125; &lt;button onClick=&#123;handleAlertClick&#125; /&gt; &#125;function Counter() &#123; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + 1); &#125;, 3000); &#125; &lt;button onClick=&#123;handleAlertClick&#125; /&gt; &#125;function Counter() &#123; function handleAlertClick() &#123; setTimeout(() =&gt; &#123; alert(&apos;You clicked on: &apos; + 2); &#125;, 3000); &#125; &lt;button onClick=&#123;handleAlertClick&#125; /&gt; &#125;这就是为什么在这个 demo 中中，事件处理函数 “属于” 某一次特定的渲染，当你点击的时候，它会使用那次渲染中counter的状态值。在任意一次渲染中，props 和 state 是始终保持不变的。如果 props 和 state 在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都 “属于” 一次特定的渲染。即便是事件处理中的异步函数调用 “看到” 的也是这次渲染中的count值。备注：上面我将具体的count值直接内联到了handleAlertClick函数中。这种心智上的替换是安全的因为count 值在某次特定渲染中不可能被改变。它被声明成了一个常量并且是一个数字。这样去思考其他类型的值比如对象也同样是安全的，当然需要在我们都同意应该避免直接修改 state 这个前提下。通过调用setSomething(newObj)的方式去生成一个新的对象而不是直接修改它是更好的选择，因为这样能保证之前渲染中的 state 不会被污染。每次渲染都有它自己的 Effects这篇文章是关于 effects 的，但目前我们居然还没有讨论 effects！ 言归正传，由上面的分析得出一个结果，effects 其实并没有什么两样。让我们回到官网文档中的这个例子：12345678910111213function Counter() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;抛一个问题给你：effect 是如何读取到最新的count 状态值的呢？也许，是某种 “data binding” 或“watching”机制使得count能够在 effect 函数内更新？也或许count是一个可变的值，React 会在我们组件内部修改它以使我们的 effect 函数总能拿到最新的值？都不是。我们已经知道count是某个特定渲染中的常量。事件处理函数 “看到” 的是属于它那次特定渲染中的count状态值。对于 effects 也同样如此：并不是count的值在 “不变” 的 effect 中发生了改变，而是 effect 函数本身在每一次渲染中都不相同。每一个 effect 版本 “看到” 的count值都来自于它属于的那次渲染：12345678910111213141516171819202122function Counter() &#123; useEffect( () =&gt; &#123; document.title = `You clicked $&#123;0&#125; times`; &#125; ); &#125;function Counter() &#123; useEffect( () =&gt; &#123; document.title = `You clicked $&#123;1&#125; times`; &#125; ); &#125;function Counter() &#123; useEffect( () =&gt; &#123; document.title = `You clicked $&#123;2&#125; times`; &#125; ); &#125;React 会记住你提供的 effect 函数，并且会在每次更改作用于 DOM 并让浏览器绘制屏幕后去调用它。所以虽然我们说的是一个 effect（这里指更新 document 的 title），但其实每次渲染都是一个不同的函数 — 并且每个 effect 函数 “看到” 的 props 和 state 都来自于它属于的那次特定渲染。概念上，你可以想象 effects 是渲染结果的一部分。严格地说，它们并不是（为了允许 Hook 的组合并且不引入笨拙的语法或者运行时）。但是在我们构建的心智模型上，effect 函数_属于_某个特定的渲染，就像事件处理函数一样。为了确保我们已经有了扎实的理解，我们再回顾一下第一次的渲染过程：React: 给我状态为 0时候的 UI。你的组件:给你需要渲染的内容: &lt;p&gt;You clicked 0 times&lt;/p&gt;。记得在渲染完了之后调用这个 effect: () =&gt; { document.title = &#39;You clicked 0 times&#39; }。React: 没问题。开始更新 UI，喂浏览器，我要给 DOM 添加一些东西。浏览器: 酷，我已经把它绘制到屏幕上了。React: 好的， 我现在开始运行给我的 effect运行 () =&gt; { document.title = &#39;You clicked 0 times&#39; }。现在我们回顾一下我们点击之后发生了什么：你的组件: 喂 React, 把我的状态设置为1。React: 给我状态为 1时候的 UI。你的组件:给你需要渲染的内容: &lt;p&gt;You clicked 1 times&lt;/p&gt;。记得在渲染完了之后调用这个 effect： () =&gt; { document.title = &#39;You clicked 1 times&#39; }。React: 没问题。开始更新 UI，喂浏览器，我修改了 DOM。Browser: 酷，我已经将更改绘制到屏幕上了。React: 好的， 我现在开始运行属于这次渲染的 effect运行 () =&gt; { document.title = &#39;You clicked 1 times&#39; }。每一次渲染都有它自己的… 所有我们现在知道 effects 会在每次渲染后运行，并且概念上它是组件输出的一部分，可以 “看到” 属于某次特定渲染的 props 和 state。我们来做一个思想实验，思考下面的代码：12345678910111213function Counter() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`You clicked $&#123;count&#125; times`); &#125;, 3000); &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;如果我点击了很多次并且在 effect 里设置了延时，打印出来的结果会是什么呢？剧透预警你可能会认为这是一个很绕的题并且结果是反直觉的。完全错了！我们看到的就是顺序的打印输出 — 每一个都属于某次特定的渲染，因此有它该有的count值。你可以自己试一试：你可能会想：“它当然应该是这样的。否则还会怎么样呢？”不过，class 中的this.state并不是这样运作的。你可能会想当然以为下面的 class 实现和上面是相等的：12345componentDidUpdate() &#123; setTimeout(() =&gt; &#123; console.log(`You clicked $&#123;this.state.count&#125; times`); &#125;, 3000);&#125;然而，this.state.count总是指向_最新_的 count 值，而不是属于某次特定渲染的值。所以你会看到每次打印输出都是5：我觉得 Hooks 这么依赖 Javascript 闭包是挺讽刺的一件事。有时候组件的 class 实现方式会受闭包相关的苦（the canonical wrong-value-in-a-timeout confusion），但其实这个例子中真正的混乱来源是可变数据（React 修改了 class 中的this.state使其指向最新状态），并不是闭包本身的错。当封闭的值始终不会变的情况下闭包是非常棒的。这使它们非常容易思考因为你本质上在引用常量。正如我们所讨论的，props 和 state 在某个特定渲染中是不会改变的。顺便说一下，我们可以使用闭包修复上面的 class 版本…逆潮而动到目前为止，我们可以明确地喊出下面重要的事实：每一个组件内的函数（包括事件处理函数，effects，定时器或者 API 调用等等）会捕获某次渲染中定义的 props 和 state。所以下面的两个例子是相等的：1234567function Example(props) &#123; useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(props.counter); &#125;, 1000); &#125;); &#125;1234567function Example(props) &#123; const counter = props.counter; useEffect(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(counter); &#125;, 1000); &#125;); &#125;在组件内什么时候去读取 props 或者 state 是无关紧要的。因为它们不会改变。在单次渲染的范围内，props 和 state 始终保持不变。（解构赋值的 props 使得这一点更明显。）当然，有时候你可能_想_在 effect 的回调函数里读取最新的值而不是捕获的值。最简单的实现方法是使用 refs，这篇文章的最后一部分介绍了相关内容。需要注意的是当你想要从_过去渲染中的函数里读取未来的 props 和 state，你是在逆潮而动。虽然它并没有错_（有时候可能也需要这样做），但它因为打破了默认范式会使代码显得不够 “干净”。这是我们有意为之的，因为它能帮助突出哪些代码是脆弱的，是需要依赖时间次序的。在 class 中，如果发生这种情况就没那么显而易见了。下面这个计数器版本 模拟了 class 中的行为：1234567function Example() &#123; const [count, setCount] = useState(0); const latestCount = useRef(count); useEffect(() =&gt; &#123; latestCount.current = count; setTimeout(() =&gt; &#123; console.log(`You clicked $&#123;latestCount.current&#125; times`); &#125;, 3000); &#125;);在 React 中去直接修改值看上去有点怪异。然而，在 class 组件中 React 正是这样去修改this.state的。不像捕获的 props 和 state，你没法保证在任意一个回调函数中读取的latestCount.current是不变的。根据定义，你可以随时修改它。这就是为什么它不是默认行为，而是需要你主动选择这样做。那 Effect 中的清理又是怎样的呢？像 文档中解释的, 有些 effects 可能需要有一个清理步骤。本质上，它的目的是消除副作用（effect)，比如取消订阅。思考下面的代码:123456useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange); &#125;;&#125;);假设第一次渲染的时候props是{id: 10}，第二次渲染的时候是{id: 20}。你_可能_会认为发生了下面的这些事：React 清除了 {id: 10}的 effect。React 渲染{id: 20}的 UI。React 运行{id: 20}的 effect。(事实并不是这样。)如果依赖这种心智模型，你可能会认为清除过程 “看到” 的是旧的 props 因为它是在重新渲染之前运行的，新的 effect“看到”的是新的 props 因为它是在重新渲染之后运行的。这种心智模型直接来源于 class 组件的生命周期。不过它并不精确。让我们来一探究竟。React 只会在浏览器绘制后运行 effects。这使得你的应用更流畅因为大多数 effects 并不会阻塞屏幕的更新。Effect 的清除同样被延迟了。上一次的 effect 会在重新渲染后被清除：React 渲染{id: 20}的 UI。浏览器绘制。我们在屏幕上看到{id: 20}的 UI。React 清除{id: 10}的 effect。React 运行{id: 20}的 effect。你可能会好奇：如果清除上一次的 effect 发生在 props 变成{id: 20}之后，那它为什么还能 “看到” 旧的{id: 10}？你曾经来过这里… 🤔引用上半部分得到的结论:组件内的每一个函数（包括事件处理函数，effects，定时器或者 API 调用等等）会捕获定义它们的那次渲染中的 props 和 state。现在答案显而易见。effect 的清除并不会读取 “最新” 的 props。它只能读取到定义它的那次渲染中的 props 值：1234567891011121314151617181920212223242526function Example() &#123; useEffect( () =&gt; &#123; ChatAPI.subscribeToFriendStatus(10, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(10, handleStatusChange); &#125;; &#125; ); &#125;function Example() &#123; useEffect( () =&gt; &#123; ChatAPI.subscribeToFriendStatus(20, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(20, handleStatusChange); &#125;; &#125; ); &#125;王国会崛起转而复归尘土，太阳会脱落外层变为白矮星，最后的文明也迟早会结束。但是第一次渲染中 effect 的清除函数只能看到{id: 10}这个 props。这正是为什么 React 能做到在绘制后立即处理 effects — 并且默认情况下使你的应用运行更流畅。如果你的代码需要依然可以访问到老的 props。同步， 而非生命周期我最喜欢 React 的一点是它统一描述了初始渲染和之后的更新。这降低了你程序的熵。比如我有个组件像下面这样：1234567function Greeting(&#123; name &#125;) &#123; return ( &lt;h1 class&gt; Hello, &#123;name&#125; &lt;/h1&gt; );&#125;我先渲染&lt;Greeting /&gt;然后渲染&lt;Greeting /&gt;，和我直接渲染&lt;Greeting /&gt;并没有什么区别。在这两种情况中，我最后看到的都是 “Hello, Yuzhi”。人们总是说：“重要的是旅行过程，而不是目的地”。在 React 世界中，恰好相反。重要的是目的，而不是过程。这就是 JQuery 代码中 $.addClass 或 $.removeClass这样的调用（过程）和 React 代码中声明 CSS 类名应该是什么（目的）之间的区别。React 会根据我们当前的 props 和 state 同步到 DOM。“mount”和 “update” 之于渲染并没有什么区别。你应该以相同的方式去思考 effects。useEffect使你能够根据 props 和 state _同步_ React tree 之外的东西。1234567function Greeting(&#123; name &#125;) &#123; useEffect(() =&gt; &#123; document.title = &apos;Hello, &apos; + name; &#125;); return ( &lt;h1 class&gt; Hello, &#123;name&#125; &lt;/h1&gt; );&#125;这就是和大家熟知的 mount/update/unmount 心智模型之间细微的区别。理解和内化这种区别是非常重要的。如果你试图写一个 effect 会根据是否第一次渲染而表现不一致，你正在逆潮而动。如果我们的结果依赖于过程而不是目的，我们会在同步中犯错。先渲染属性 A，B 再渲染 C，和立即渲染 C 并没有什么区别。虽然他们可能短暂地会有点不同（比如请求数据时），但最终的结果是一样的。不过话说回来，在每一次渲染后都去运行所有的 effects 可能并不高效。（并且在某些场景下，它可能会导致无限循环。）所以我们该怎么解决这个问题？告诉 React 去比对你的 Effects其实我们已经从 React 处理 DOM 的方式中学习到了解决办法。React 只会更新 DOM 真正发生改变的部分，而不是每次渲染都大动干戈。当你把123&lt;h1 class&gt; Hello, Dan&lt;/h1&gt;更新到123&lt;h1 class&gt; Hello, Yuzhi&lt;/h1&gt;React 能够看到两个对象:12const oldProps = &#123;className: &apos;Greeting&apos;, children: &apos;Hello, Dan&apos;&#125;;const newProps = &#123;className: &apos;Greeting&apos;, children: &apos;Hello, Yuzhi&apos;&#125;;它会检测每一个 props，并且发现children发生改变需要更新 DOM，但className并没有。所以它只需要这样做：1domNode.innerText = &apos;Hello, Yuzhi&apos;;我们也可以用类似的方式处理 effects 吗？如果能够在不需要的时候避免调用 effect 就太好了。举个例子，我们的组件可能因为状态变更而重新渲染：12345678910111213function Greeting(&#123; name &#125;) &#123; const [counter, setCounter] = useState(0); useEffect(() =&gt; &#123; document.title = &apos;Hello, &apos; + name; &#125;); return ( &lt;h1 class&gt; Hello, &#123;name&#125; &lt;button onClick=&#123;() =&gt; setCounter(counter + 1)&#125;&gt; Increment &lt;/button&gt; &lt;/h1&gt; );&#125;但是我们的 effect 并没有使用counter这个状态。我们的 effect 只会同步name属性给document.title，但name并没有变。在每一次 counter 改变后重新给document.title赋值并不是理想的做法。好了，那 React 可以… 区分 effects 的不同吗？12let oldEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;let newEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;并不能。React 并不能猜测到函数做了什么如果不先调用的话。（源码中并没有包含特殊的值，它仅仅是引用了name属性。）这是为什么你如果想要避免 effects 不必要的重复调用，你可以提供给useEffect一个依赖数组参数 (deps)：123useEffect(() =&gt; &#123; document.title = &apos;Hello, &apos; + name;&#125;, [name]);这好比你告诉 React：“Hey，我知道你看不到这个函数里的东西，但我可以保证只使用了渲染中的name，别无其他。”如果当前渲染中的这些依赖项和上一次运行这个 effect 的时候值一样，因为没有什么需要同步 React 会自动跳过这次 effect：12345const oldEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;const oldDeps = [&apos;Dan&apos;];const newEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;const newDeps = [&apos;Dan&apos;];即使依赖数组中只有一个值在两次渲染中不一样，我们也不能跳过 effect 的运行。要同步所有！关于依赖项不要对 React 撒谎关于依赖项对 React 撒谎会有不好的结果。直觉上，这很好理解，但我曾看到几乎所有依赖 class 心智模型使用useEffect的人都试图违反这个规则。（我刚开始也这么干了！）1234567891011function SearchResults() &#123; async function fetchData() &#123; &#125; useEffect(() =&gt; &#123; fetchData(); &#125;, []); &#125;(官网的 Hooks FAQ 解释了应该怎么做。 我们在下面会重新回顾这个例子。)“但我只是想在挂载的时候运行它！”，你可能会说。现在只需要记住：如果你设置了依赖项，effect 中用到的所有组件内的值都要包含在依赖中。这包括 props，state，函数 — 组件内的任何东西。有时候你是这样做了，但可能会引起一个问题。比如，你可能会遇到无限请求的问题，或者 socket 被频繁创建的问题。解决问题的方法不是移除依赖项。我们会很快了解具体的解决方案。不过在我们深入解决方案之前，我们先尝试更好地理解问题。如果设置了错误的依赖会怎么样呢？如果依赖项包含了所有 effect 中使用到的值，React 就能知道何时需要运行它：123useEffect(() =&gt; &#123; document.title = &apos;Hello, &apos; + name;&#125;, [name]);(依赖发生了变更，所以会重新运行 effect。)但是如果我们将[]设为 effect 的依赖，新的 effect 函数不会运行：123useEffect(() =&gt; &#123; document.title = &apos;Hello, &apos; + name;&#125;, []);(依赖没有变，所以不会再次运行 effect。)在这个例子中，问题看起来显而易见。但在某些情况下如果你脑子里 “跳出”class 组件的解决办法，你的直觉很可能会欺骗你。举个例子，我们来写一个每秒递增的计数器。在 Class 组件中，我们的直觉是：“开启一次定时器，清除也是一次”。这里有一个例子说明怎么实现它。当我们理所当然地把它用useEffect的方式翻译，直觉上我们会设置依赖为[]。“我只想运行一次 effect”，对吗？1234567891011function Counter() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, []); return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125;然而，这个例子只会递增一次。天了噜。如果你的心智模型是 “只有当我想重新触发 effect 的时候才需要去设置依赖”，这个例子可能会让你产生存在危机。你想要触发一次因为它是定时器 — 但为什么会有问题？如果你知道依赖是我们给 React 的暗示，告诉它 effect 所有需要使用的渲染中的值，你就不会吃惊了。effect 中使用了count但我们撒谎说它没有依赖。如果我们这样做迟早会出幺蛾子。在第一次渲染中，count是0。因此，setCount(count + 1)在第一次渲染中等价于setCount(0 + 1)。既然我们设置了[]依赖，effect 不会再重新运行，它后面每一秒都会调用setCount(0 + 1) ：123456789101112131415161718192021222324252627function Counter() &#123; useEffect( () =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(0 + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [] ); &#125;function Counter() &#123; useEffect( () =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(1 + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [] ); &#125;我们对 React 撒谎说我们的 effect 不依赖组件内的任何值，可实际上我们的 effect 有依赖！我们的 effect 依赖count - 它是组件内的值（不过在 effect 外面定义）：123456const count = useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, []);因此，设置[]为依赖会引入一个 bug。React 会对比依赖，并且跳过后面的 effect：(依赖没有变，所以不会再次运行 effect。)类似于这样的问题是很难被想到的。因此，我鼓励你将诚实地告知 effect 依赖作为一条硬性规则，并且要列出所以依赖。（我们提供了一个 lint 规则如果你想在你的团队内做硬性规定。）两种诚实告知依赖的方法有两种诚实告知依赖的策略。你应该从第一种开始，然后在需要的时候应用第二种。第一种策略是在依赖中包含所有 effect 中用到的组件内的值。让我们在依赖中包含count：12345useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, [count]);现在依赖数组正确了。虽然它可能不是太理想但确实解决了上面的问题。现在，每次count修改都会重新运行 effect，并且定时器中的setCount(count + 1)会正确引用某次渲染中的 count值：1234567891011121314151617181920212223242526function Counter() &#123; useEffect( () =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(0 + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [0] ); &#125;function Counter() &#123; useEffect( () =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(1 + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [1] ); &#125;这能解决问题但是我们的定时器会在每一次count改变后清除和重新设定。这应该不是我们想要的结果：(依赖发生了变更，所以会重新运行 effect。)第二种策略是修改 effect 内部的代码以确保它包含的值只会在需要的时候发生变更。我们不想告知错误的依赖 - 我们只是修改 effect 使得依赖更少。让我们来看一些移除依赖的常用技巧。让 Effects 自给自足我们想去掉 effect 的count依赖。12345useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, [count]);为了实现这个目的，我们需要问自己一个问题：我们为什么要用count？可以看到我们只在setCount调用中用到了count。在这个场景中，我们其实并不需要在 effect 中使用count。当我们想要根据前一个状态更新状态的时候，我们可以使用setState的函数形式：12345useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(c =&gt; c + 1); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, []);我喜欢把类似这种情况称为 “错误的依赖”。是的，因为我们在 effect 中写了setCount(count + 1)所以count是一个必需的依赖。但是，我们真正想要的是把count转换为count+1，然后返回给 React。可是 React 其实已经知道当前的count。我们需要告知 React 的仅仅是去递增状态 - 不管它现在具体是什么值。这正是setCount(c =&gt; c + 1)做的事情。你可以认为它是在给 React“发送指令”告知如何更新状态。这种 “更新形式” 在其他情况下也有帮助，比如你需要批量更新。注意我们做到了移除依赖，并且没有撒谎。我们的 effect 不再读取渲染中的count值。(依赖没有变，所以不会再次运行 effect。)你可以自己 试试。尽管 effect 只运行了一次，第一次渲染中的定时器回调函数可以完美地在每次触发的时候给 React 发送c =&gt; c + 1更新指令。它不再需要知道当前的count值。因为 React 已经知道了。函数式更新 和 Google Docs还记得我们说过同步才是理解 effects 的心智模型吗？同步的一个有趣地方在于你通常想要把同步的 “信息” 和状态解耦。举个例子，当你在 Google Docs 编辑文档的时候，Google 并不会把整篇文章发送给服务器。那样做会非常低效。相反的，它只是把你的修改以一种形式发送给服务端。虽然我们 effect 的情况不尽相同，但可以应用类似的思想。只在 effects 中传递最小的信息会很有帮助。类似于setCount(c =&gt; c + 1)这样的更新形式比setCount(count + 1)传递了更少的信息，因为它不再被当前的 count 值 “污染”。它只是表达了一种行为（“递增”）。“Thinking in React” 也讨论了如何找到最小状态。原则是类似的，只不过现在关注的是如何更新。表达_意图_（而不是结果）和 Google Docs 如何处理共同编辑异曲同工。虽然这个类比略微延伸了一点，函数式更新在 React 中扮演了类似的角色。它们确保能以批量地和可预测的方式来处理各种源头（事件处理函数，effect 中的订阅，等等）的状态更新。然而，即使是setCount(c =&gt; c + 1)也并不完美。它看起来有点怪，并且非常受限于它能做的事。举个例子，如果我们有两个互相依赖的状态，或者我们想基于一个 prop 来计算下一次的 state，它并不能做到。幸运的是， setCount(c =&gt; c + 1)有一个更强大的姐妹模式，它的名字叫useReducer。解耦来自 Actions 的更新我们来修改上面的例子让它包含两个状态：count 和 step。我们的定时器会每次在 count 上增加一个step值：12345678910111213141516function Counter() &#123; const [count, setCount] = useState(0); const [step, setStep] = useState(1); useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(c =&gt; c + step); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [step]); return ( &lt;&gt; &lt;h1&gt;&#123;count&#125;&lt;/h1&gt; &lt;input value=&#123;step&#125; onChange=&#123;e =&gt; setStep(Number(e.target.value))&#125; /&gt; &lt;/&gt; );&#125;(这里是 demo.)注意我们没有撒谎。既然我们在 effect 里使用了step，我们就把它加到依赖里。所以这也是为什么代码能运行正确。这个例子目前的行为是修改step会重启定时器 - 因为它是依赖项之一。在大多数场景下，这正是你所需要的。清除上一次的 effect 然后重新运行新的 effect 并没有任何错。除非我们有很好的理由，我们不应该改变这个默认行为。不过，假如我们不想在step改变后重启定时器，我们该如何从 effect 中移除对step的依赖呢？当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用useReducer去替换它们。当你写类似setSomething(something =&gt; ...)这种代码的时候，也许就是考虑使用 reducer 的契机。reducer 可以让你把组件内发生了什么 (actions) 和状态如何响应并更新分开表述。我们用一个dispatch依赖去替换 effect 的step依赖：1234567const [state, dispatch] = useReducer(reducer, initialState);const &#123; count, step &#125; = state;useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; dispatch(&#123; type: &apos;tick&apos; &#125;); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, [dispatch]);(查看 demo。)你可能会问：“这怎么就更好了？” 答案是 React 会保证dispatch在组件的声明周期内保持不变。所以上面例子中不再需要重新订阅定时器。我们解决了问题!（你可以从依赖中去除dispatch, setState, 和useRef包裹的值因为 React 会确保它们是静态的。不过你设置了它们作为依赖也没什么问题。）相比于直接在 effect 里面读取状态，它 dispatch 了一个 action 来描述发生了什么。这使得我们的 effect 和step状态解耦。我们的 effect 不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由 reducer 去统一处理:12345678910111213const initialState = &#123; count: 0, step: 1,&#125;;function reducer(state, action) &#123; const &#123; count, step &#125; = state; if (action.type === &apos;tick&apos;) &#123; return &#123; count: count + step, step &#125;; &#125; else if (action.type === &apos;step&apos;) &#123; return &#123; count, step: action.step &#125;; &#125; else &#123; throw new Error(); &#125;&#125;(这里是 demo 如果你之前错过了。)为什么 useReducer 是 Hooks 的作弊模式我们已经学习到如何移除 effect 的依赖，不管状态更新是依赖上一个状态还是依赖另一个状态。但假如我们需要依赖 props 去计算下一个状态呢？举个例子，也许我们的 API 是&lt;Counter step={1} /&gt;。确定的是，在这种情况下，我们没法避免依赖props.step 。是吗？实际上， 我们可以避免！我们可以把 reducer 函数放到组件内去读取 props：123456789101112131415161718function Counter(&#123; step &#125;) &#123; const [count, dispatch] = useReducer(reducer, 0); function reducer(state, action) &#123; if (action.type === &apos;tick&apos;) &#123; return state + step; &#125; else &#123; throw new Error(); &#125; &#125; useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; dispatch(&#123; type: &apos;tick&apos; &#125;); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [dispatch]); return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125;这种模式会使一些优化失效，所以你应该避免滥用它，不过如果你需要你完全可以在 reducer 里面访问 props。（这里是 demo。）即使是在这个例子中，React 也保证dispatch在每次渲染中都是一样的。 所以你可以在依赖中去掉它。它不会引起 effect 不必要的重复执行。你可能会疑惑：这怎么可能？在之前渲染中调用的 reducer 怎么 “知道” 新的 props？答案是当你dispatch的时候，React 只是记住了 action - 它会在下一次渲染中再次调用 reducer。在那个时候，新的 props 就可以被访问到，而且 reducer 调用也不是在 effect 里。这就是为什么我倾向认为useReducer是 Hooks 的 “作弊模式”。它可以把更新逻辑和描述发生了什么分开。结果是，这可以帮助我移除不必需的依赖，避免不必要的 effect 调用。把函数移到 Effects 里一个典型的误解是认为函数不应该成为依赖。举个例子，下面的代码看上去可以运行正常：12345678910111213function SearchResults() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); async function fetchData() &#123; const result = await axios( &apos;https://hn.algolia.com/api/v1/search?query=react&apos;, ); setData(result.data); &#125; useEffect(() =&gt; &#123; fetchData(); &#125;, []);(这个例子 改编自 Robin Wieruch 这篇很棒的文章 — 点击查看！)需要明确的是，上面的代码可以正常工作。但这样做在组件日渐复杂的迭代过程中我们很难确保它在各种情况下还能正常运行。想象一下我们的代码做下面这样的分离，并且每一个函数的体量是现在的五倍：123456789101112131415161718function SearchResults() &#123; function getFetchUrl() &#123; return &apos;https://hn.algolia.com/api/v1/search?query=react&apos;; &#125; async function fetchData() &#123; const result = await axios(getFetchUrl()); setData(result.data); &#125; useEffect(() =&gt; &#123; fetchData(); &#125;, []); &#125;然后我们在某些函数内使用了某些 state 或者 prop：12345678910111213141516171819function SearchResults() &#123; const [query, setQuery] = useState(&apos;react&apos;); function getFetchUrl() &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125; async function fetchData() &#123; const result = await axios(getFetchUrl()); setData(result.data); &#125; useEffect(() =&gt; &#123; fetchData(); &#125;, []); &#125;如果我们忘记去更新使用这些函数（很可能通过其他函数调用）的 effects 的依赖，我们的 effects 就不会同步 props 和 state 带来的变更。这当然不是我们想要的。幸运的是，对于这个问题有一个简单的解决方案。如果某些函数仅在 effect 中调用，你可以把它们的定义移到 effect 中：12345678function SearchResults() &#123; useEffect(() =&gt; &#123; function getFetchUrl() &#123; return &apos;https://hn.algolia.com/api/v1/search?query=react&apos;; &#125; async function fetchData() &#123; const result = await axios(getFetchUrl()); setData(result.data); &#125; fetchData(); &#125;, []); &#125;(这里是 demo.)这么做有什么好处呢？我们不再需要去考虑这些 “间接依赖”。我们的依赖数组也不再撒谎：在我们的 effect 中确实没有再使用组件范围内的任何东西。如果我们后面修改 getFetchUrl去使用query状态，我们更可能会意识到我们正在 effect 里面编辑它 - 因此，我们需要把query添加到 effect 的依赖里：12345678910111213141516function SearchResults() &#123; const [query, setQuery] = useState(&apos;react&apos;); useEffect(() =&gt; &#123; function getFetchUrl() &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125; async function fetchData() &#123; const result = await axios(getFetchUrl()); setData(result.data); &#125; fetchData(); &#125;, [query]); &#125;(这里是 demo.)添加这个依赖，我们不仅仅是在 “取悦 React”。在 query 改变后去重新请求数据是合理的。useEffect的设计意图就是要强迫你关注数据流的改变，然后决定我们的 effects 该如何和它同步 - 而不是忽视它直到我们的用户遇到了 bug。感谢eslint-plugin-react-hooks 插件的exhaustive-depslint 规则，它会在你编码的时候就分析 effects 并且提供可能遗漏依赖的建议。换句话说，机器会告诉你组件中哪些数据流变更没有被正确地处理。非常棒。但我不能把这个函数放到 Effect 里有时候你可能不想把函数移入 effect 里。比如，组件内有几个 effect 使用了相同的函数，你不想在每个 effect 里复制黏贴一遍这个逻辑。也或许这个函数是一个 prop。在这种情况下你应该忽略对函数的依赖吗？我不这么认为。再次强调，efffects 不应该对它的依赖撒谎。通常我们还有更好的解决办法。一个常见的误解是，“函数从来不会改变”。但是这篇文章你读到现在，你知道这显然不是事实。实际上，在组件内定义的函数每一次渲染都在变。函数每次渲染都会改变这个事实本身就是个问题。 比如有两个 effects 会调用 getFetchUrl:1234567891011121314151617function SearchResults() &#123; function getFetchUrl(query) &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125; useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;react&apos;); &#125;, []); useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;redux&apos;); &#125;, []); &#125;在这个例子中，你可能不想把getFetchUrl 移到 effects 中，因为你想复用逻辑。另一方面，如果你对依赖很 “诚实”，你可能会掉到陷阱里。我们的两个 effects 都依赖getFetchUrl，而它每次渲染都不同，所以我们的依赖数组会变得无用：1234567891011121314function SearchResults() &#123; function getFetchUrl(query) &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125; useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;react&apos;); &#125;, [getFetchUrl]); useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;redux&apos;); &#125;, [getFetchUrl]); &#125;一个可能的解决办法是把getFetchUrl从依赖中去掉。但是，我不认为这是好的解决方式。这会使我们后面对数据流的改变很难被发现从而忘记去处理。这会导致类似于上面 “定时器不更新值” 的问题。相反的，我们有两个更简单的解决办法。第一个， 如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在 effects 中使用：1234567891011121314function getFetchUrl(query) &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;&#125;function SearchResults() &#123; useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;react&apos;); &#125;, []); useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;redux&apos;); &#125;, []); &#125;你不再需要把它设为依赖，因为它们不在渲染范围内，因此不会被数据流影响。它不可能突然意外地依赖于 props 或 state。或者， 你也可以把它包装成 useCallback Hook:1234567891011121314function SearchResults() &#123; const getFetchUrl = useCallback((query) =&gt; &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125;, []); useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;react&apos;); &#125;, [getFetchUrl]); useEffect(() =&gt; &#123; const url = getFetchUrl(&apos;redux&apos;); &#125;, [getFetchUrl]); &#125;useCallback本质上是添加了一层依赖检查。它以另一种方式解决了问题 - 我们使函数本身只在需要的时候才改变，而不是去掉对函数的依赖。我们来看看为什么这种方式是有用的。之前，我们的例子中展示了两种搜索结果（查询条件分别为&#39;react&#39;和&#39;redux&#39;）。但如果我们想添加一个输入框允许你输入任意的查询条件 (query)。不同于传递query参数的方式，现在getFetchUrl会从状态中读取。我们很快发现它遗漏了query依赖：如果我把query添加到useCallback 的依赖中，任何调用了getFetchUrl的 effect 在query改变后都会重新运行：1234567891011function SearchResults() &#123; const [query, setQuery] = useState(&apos;react&apos;); const getFetchUrl = useCallback(() =&gt; &#123; return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125;, [query]); useEffect(() =&gt; &#123; const url = getFetchUrl(); &#125;, [getFetchUrl]); &#125;我们要感谢useCallback，因为如果query 保持不变，getFetchUrl也会保持不变，我们的 effect 也不会重新运行。但是如果query修改了，getFetchUrl也会随之改变，因此会重新请求数据。这就像你在 Excel 里修改了一个单元格的值，另一个使用它的单元格会自动重新计算一样。这正是拥抱数据流和同步思维的结果。对于通过属性从父组件传入的函数这个方法也适用：12345678910111213141516function Parent() &#123; const [query, setQuery] = useState(&apos;react&apos;); const fetchData = useCallback(() =&gt; &#123; const url = &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query; &#125;, [query]); return &lt;Child fetchData=&#123;fetchData&#125; /&gt;&#125;function Child(&#123; fetchData &#125;) &#123; let [data, setData] = useState(null); useEffect(() =&gt; &#123; fetchData().then(setData); &#125;, [fetchData]); &#125;因为fetchData只有在Parent的query状态变更时才会改变，所以我们的Child只会在需要的时候才去重新请求数据。函数是数据流的一部分吗？有趣的是，这种模式在 class 组件中行不通，并且这种行不通恰到好处地揭示了 effect 和生命周期范式之间的区别。考虑下面的转换：1234567891011121314151617class Parent extends Component &#123; state = &#123; query: &apos;react&apos; &#125;; fetchData = () =&gt; &#123; const url = &apos;https://hn.algolia.com/api/v1/search?query=&apos; + this.state.query; &#125;; render() &#123; return &lt;Child fetchData=&#123;this.fetchData&#125; /&gt;; &#125;&#125;class Child extends Component &#123; state = &#123; data: null &#125;; componentDidMount() &#123; this.props.fetchData(); &#125; render() &#123; &#125;&#125;你可能会想：“少来了 Dan，我们都知道useEffect 就像componentDidMount 和 componentDidUpdate的结合，你不能老是破坏这一条！” 好吧，就算加了componentDidUpdate照样无用：1234567891011class Child extends Component &#123; state = &#123; data: null &#125;; componentDidMount() &#123; this.props.fetchData(); &#125; componentDidUpdate(prevProps) &#123; if (this.props.fetchData !== prevProps.fetchData) &#123; this.props.fetchData(); &#125; &#125; render() &#123; &#125;&#125;当然如此，fetchData是一个 class 方法！（或者你也可以说是 class 属性 - 但这不能改变什么。）它不会因为状态的改变而不同，所以this.props.fetchData和 prevProps.fetchData始终相等，因此不会重新请求。那我们删掉条件判断怎么样？123componentDidUpdate(prevProps) &#123; this.props.fetchData();&#125;等等，这样会在每次渲染后都去请求。(添加一个加载动画可能是一种有趣的发现这种情况的方式。) 也许我们可以绑定一个特定的 query?123render() &#123; return &lt;Child fetchData=&#123;this.fetchData.bind(this, this.state.query)&#125; /&gt;;&#125;但这样一来，this.props.fetchData !== prevProps.fetchData 表达式永远是true，即使query并未改变。这会导致我们总是去请求。想要解决这个 class 组件中的难题，唯一现实可行的办法是硬着头皮把query本身传入 Child 组件。 Child 虽然实际并没有直接_使用_这个query的值，但能在它改变的时候触发一次重新请求：12345678910111213141516171819202122232425class Parent extends Component &#123; state = &#123; query: &apos;react&apos; &#125;; fetchData = () =&gt; &#123; const url = &apos;https://hn.algolia.com/api/v1/search?query=&apos; + this.state.query; &#125;; render() &#123; return &lt;Child fetchData=&#123;this.fetchData&#125; query=&#123;this.state.query&#125; /&gt;; &#125;&#125;class Child extends Component &#123; state = &#123; data: null &#125;; componentDidMount() &#123; this.props.fetchData(); &#125; componentDidUpdate(prevProps) &#123; if (this.props.query !== prevProps.query) &#123; this.props.fetchData(); &#125; &#125; render() &#123; &#125;&#125;在使用 React 的 class 组件这么多年后，我已经如此习惯于把不必要的 props 传递下去并且破坏父组件的封装以至于我在一周之前才意识到我为什么一定要这样做。在 class 组件中，函数属性本身并不是数据流的一部分。组件的方法中包含了可变的this变量导致我们不能确定无疑地认为它是不变的。因此，即使我们只需要一个函数，我们也必须把一堆数据传递下去仅仅是为了做 “diff”。我们无法知道传入的this.props.fetchData 是否依赖状态，并且不知道它依赖的状态是否改变了。使用useCallback，函数完全可以参与到数据流中。我们可以说如果一个函数的输入改变了，这个函数就改变了。如果没有，函数也不会改变。感谢周到的useCallback，属性比如props.fetchData的改变也会自动传递下去。类似的，useMemo可以让我们对复杂对象做类似的事情。1234567function ColorPicker() &#123; const [color, setColor] = useState(&apos;pink&apos;); const style = useMemo(() =&gt; (&#123; color &#125;), [color]); return &lt;Child style=&#123;style&#125; /&gt;;&#125;我想强调的是，到处使用useCallback是件挺笨拙的事。当我们需要将函数传递下去并且函数会在子组件的 effect 中被调用的时候，useCallback 是很好的技巧且非常有用。或者你想试图减少对子组件的记忆负担，也不妨一试。但总的来说 Hooks 本身能更好地避免传递回调函数。在上面的例子中，我更倾向于把fetchData放在我的 effect 里（它可以抽离成一个自定义 Hook）或者是从顶层引入。我想让 effects 保持简单，而在里面调用回调会让事情变得复杂。（“如果某个props.onComplete回调改变了而请求还在进行中会怎么样？”）你可以模拟 class 的行为但那样并不能解决竞态的问题。说说竞态下面是一个典型的在 class 组件里发请求的例子：12345678910111213class Article extends Component &#123; state = &#123; article: null &#125;; componentDidMount() &#123; this.fetchData(this.props.id); &#125; async fetchData(id) &#123; const article = await API.fetchArticle(id); this.setState(&#123; article &#125;); &#125; &#125;你很可能已经知道，上面的代码埋伏了一些问题。它并没有处理更新的情况。所以第二个你能够在网上找到的经典例子是下面这样的：12345678910111213class Article extends Component &#123; state = &#123; article: null &#125;; componentDidMount() &#123; this.fetchData(this.props.id); &#125; componentDidUpdate(prevProps) &#123; if (prevProps.id !== this.props.id) &#123; this.fetchData(this.props.id); &#125; &#125; async fetchData(id) &#123; const article = await API.fetchArticle(id); this.setState(&#123; article &#125;); &#125; &#125;这显然好多了！但依旧有问题。有问题的原因是请求结果返回的顺序不能保证一致。比如我先请求 {id: 10}，然后更新到{id: 20}，但{id: 20}的请求更先返回。请求更早但返回更晚的情况会错误地覆盖状态值。这被叫做竞态，这在混合了async / await（假设在等待结果返回）和自顶向下数据流的代码中非常典型（props 和 state 可能会在 async 函数调用过程中发生改变）。Effects 并没有神奇地解决这个问题，尽管它会警告你如果你直接传了一个async 函数给 effect。（我们会改善这个警告来更好地解释你可能会遇到的这些问题。）如果你使用的异步方式支持取消，那太棒了。你可以直接在清除函数中取消异步请求。或者，最简单的权宜之计是用一个布尔值来跟踪它：1234567891011121314151617function Article(&#123; id &#125;) &#123; const [article, setArticle] = useState(null); useEffect(() =&gt; &#123; let didCancel = false; async function fetchData() &#123; const article = await API.fetchArticle(id); if (!didCancel) &#123; setArticle(article); &#125; &#125; fetchData(); return () =&gt; &#123; didCancel = true; &#125;; &#125;, [id]); &#125;这篇文章讨论了更多关于如何处理错误和加载状态，以及抽离逻辑到自定义的 Hook。我推荐你认真阅读一下如果你想学习更多关于如何在 Hooks 里请求数据的内容。提高水准在 class 组件生命周期的思维模型中，副作用的行为和渲染输出是不同的。UI 渲染是被 props 和 state 驱动的，并且能确保步调一致，但副作用并不是这样。这是一类常见问题的来源。而在useEffect的思维模型中，默认都是同步的。副作用变成了 React 数据流的一部分。对于每一个useEffect调用，一旦你处理正确，你的组件能够更好地处理边缘情况。然而，用好useEffect的前期学习成本更高。这可能让人气恼。用同步的代码去处理边缘情况天然就比触发一次不用和渲染结果步调一致的副作用更难。这难免让人担忧如果useEffect是你现在使用最多的工具。不过，目前大抵还处理低水平使用阶段。因为 Hooks 太新了所以大家都还在低水平地使用它，尤其是在一些教程示例中。但在实践中，社区很可能即将开始高水平地使用 Hooks，因为好的 API 会有更好的动量和冲劲。我看到不同的应用在创造他们自己的 Hooks，比如封装了应用鉴权逻辑的useFetch或者使用 theme context 的useTheme 。你一旦有了包含这些的工具箱，你就不会那么频繁地直接使用useEffect。但每一个基于它的 Hook 都能从它的适应能力中得到益处。目前为止，useEffect主要用于数据请求。但是数据请求准确说并不是一个同步问题。因为我们的依赖经常是[]所以这一点尤其明显。那我们究竟在同步什么？长远来看， Suspense 用于数据请求 会允许第三方库通过第一等的途径告诉 React 暂停渲染直到某些异步事物（任何东西：代码，数据，图片）已经准备就绪。当 Suspense 逐渐地覆盖到更多的数据请求使用场景，我预料useEffect 会退居幕后作为一个强大的工具，用于同步 props 和 state 到某些副作用。不像数据请求，它可以很好地处理这些场景因为它就是为此而设计的。不过在那之前，自定义的 Hooks 比如这儿提到的是复用数据请求逻辑很好的方式。在结束前现在你差不多知道了我关于如何使用 effects 的所有知识，可以检查一下开头的 TLDR。你现在觉得它说得有道理吗？我有遗漏什么吗？（我的纸还没有写完！）我很想在 Twitter 上听听你的想法。谢谢阅读。本文作者： Andy本文地址： https://andyxw.com/archives/1f7a.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>前端</tag>
        <tag>React Hooks</tag>
        <tag>useEffect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[What are React Hooks]]></title>
    <url>%2Farchives%2Fef81.html</url>
    <content type="text"><![CDATA[本文由 简悦 SimpRead 转码， 原文地址 https://www.robinwieruch.de/react-hooks/October 29, 2018 - Edit this Post on GitHubReact Hooks were introduced at React Conf October 2018 as a way to use state and side-effects in React function components. Whereas function components have been called functional stateless components (FSC) before, they are finally able to use state with React Hooks. Therefore, many people refer to them as function components now.In this walkthrough, I want to explain the motivation behind hooks, what will change in React and why we shouldn’t panic, and how React hooks can be used in function components by showcasing common React Hooks such as the state and effect hooks by example.React Hooks were invented by the React team to introduce state management and side-effects in function components. It’s their way of making it more effortless to use only React function components without the need to refactor a React function component to a React class component for using lifecycle methods, in order to use have side-effects, or local state. React Hooks enable us to write React applications with only function components.Unnecessary Component Refactorings: Previously, only React class components were used for local state management and lifecycle methods. The latter have been essential for introducing side-effects, such as listeners or data fetching, in React class components.12345678910111213141516171819202122232425262728import React from &apos;react&apos;;class Counter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0, &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; &gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default Counter;Only if you didn’t need state or lifecycle methods, React functional stateless components could be used. And because React function components are more lightweight (and elegant), people already used plenty of function components. This came with the drawback of refactoring components from React function components to React class components every time state or lifecycle methods were needed (and vice versa).1234567891011121314151617import React, &#123; useState &#125; from &apos;react&apos;;// how to use the state hook in a React function componentfunction Counter() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;export default Counter;With Hooks there is no need for this refactoring. Side-effects and state are finally available in React function components. That’s why a rebranding from functional stateless components to function components would be reasonable.Side-effect Logic: In React class components, side-effects were mostly introduced in lifecycle methods (e.g. componentDidMount, componentDidUpdate, componentWillUnmount). A side-effect could be fetching data in React or interacting with the Browser API. Usually these side-effects came with a setup and clean up phase. For instance, if you would miss to remove your listener, you could run into React performance issues.12345678910111213141516171819202122232425262728293031// side-effects in a React class componentclass MyComponent extends Component &#123; // setup phase componentDidMount() &#123; // add listener for feature 1 // add listener for feature 2 &#125; // clean up phase componentWillUnmount() &#123; // remove listener for feature 1 // remove listener for feature 2 &#125; ...&#125;// side-effects in React function component with React Hooksfunction MyComponent() &#123; useEffect(() =&gt; &#123; // add listener for feature 1 (setup) // return function to remove listener for feature 1 (clean up) &#125;); useEffect(() =&gt; &#123; // add listener for feature 2 (setup) // return function to remove listener for feature 2 (clean up) &#125;); ...&#125;Now, if you would introduce more than one of these side-effects in a React class component’s lifecycle methods, all side-effects would be grouped by lifecycle method but not by side-effect. That’s what React Hooks are going to change by encapsulating a side-effect in one hook whereas every hook has its own side-effect with a setup and clean up phase. You will see later in a tutorial how this works for real by adding and removing listeners in a React Hook.React’s Abstraction Hell: Abstraction and thus reusability were introduced with Higher-Order Components and Render Prop Components in React. There is also React’s Context with its Provider and Consumer Components that introduce another level of abstraction. All of these advanced patterns in React are using so called wrapping components. The implementation of the following components shouldn’t be foreign to developers who are creating larger React applications.12345678910111213141516171819import &#123; compose &#125; from &apos;recompose&apos;;import &#123; withRouter &#125; from &apos;react-router-dom&apos;;function App(&#123; history, state, dispatch &#125;) &#123; return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;Content theme=&#123;theme&#125;&gt; ... &lt;/Content&gt; &#125; &lt;/ThemeContext.Consumer&gt; );&#125;export default compose( withRouter, withReducer(reducer, initialState))(App);Sophie Alpert coined it “the wrapper hell” in React. You are not only seeing it in the implementation, but also when inspecting your components in the browser. There are dozens of wrapped components due to Render Prop Components (including Consumer components from React’s Context) and Higher-Order Components. It becomes an unreadable component tree, because all the abstracted logic is covered up in other React components. The actual visible components are hard to track down in the browser’s DOM. So what if these additional components were not needed because the logic is only encapsulated in functions as side-effects instead? Then you would remove all these wrapping components and flatten your component tree’s structure:12345678910111213function App() &#123; const theme = useTheme(); const history = useRouter(); const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;Content theme=&#123;theme&#125;&gt; ... &lt;/Content&gt; );&#125;export default App;That’s what React Hooks are bringing on the table. All side-effects are sitting directly in the component without introducing other components as container for business logic. The container disappears and the logic just sits in React Hooks that are only functions. Andrew Clark already left a statement in favor of React Hooks in his popular Higher-Order Component library called recompose.JavaScript Class Confusion: JavaScript mixes two worlds pretty well: Object-oriented programming (OOP) and functional programming. React introduces many developers to both worlds. On the one side, React (and Redux) introduced people to functional programming (FP) with function compositions, general programming concepts with functions (e.g. higher-order functions, JavaScript built-in methods like map, reduce, filter) and other terms such as immutability and side-effects. React itself didn’t really introduce these things, because they are features of the language or the programming paradigm itself, but they are heavily used in React whereas every React developer becomes automatically a better JavaScript developer.On the other side, React uses JavaScript classes as one way to define React components. A class is only the declaration whereas the actual usage of the component is the instantiation of it. It creates a class instance whereas the this object of the class instance is used to interact with class methods (e.g. setState, forceUpdate, other custom class methods). However, classes come with a steeper learning curve for React beginners who are not coming from an OOP background. That’s why class bindings, the this object and inheritance can be confusing. I have a few chapters in my React book focusing only on this aspect of React which is always the most confusing thing about React for beginners.123456789101112131415161718192021222324252627282930313233343536373839404142// I THOUGHT WE ARE USING A CLASS. WHY IS IT EXTENDING FROM SOMETHING?class Counter extends Component &#123; // WAIT ... THIS WORKS??? state = &#123; value: 0 &#125;; // I THOUGH IT&apos;S THIS WAY, BUT WHY DO I NEED PROPS HERE? // constructor(props) &#123; // SUPER??? // super(props); // // this.state = &#123; // value: 0, // &#125;; // &#125; // WHY DO I HAVE TO USE AN ARROW FUNCTION??? onIncrement = () =&gt; &#123; this.setState(state =&gt; (&#123; value: state.value + 1 &#125;)); &#125;; // SHOULDN&apos;T IT BE this.onDecrement = this.onDecrement.bind(this); in the constructor??? // WHAT&apos;S this.onDecrement = this.onDecrement.bind(this); DOING ANYWAY? onDecrement = () =&gt; &#123; this.setState(state =&gt; (&#123; value: state.value - 1 &#125;)); &#125;; render() &#123; return ( &lt;div&gt; &#123;this.state.value&#125; &#123;/* WHY IS EVERYTHING AVAILABLE ON &quot;THIS&quot;??? */&#125; &lt;button onClick=&#123;this.onIncrement&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;this.onDecrement&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;Now, many people argue React shouldn’t take JavaScript classes away because people don’t understand them. After all, they belong to the language. However, one of the hypotheses of introducing the Hooks API is a smoother learning curve for React beginners when writing their React components without JavaScript classes in the first place.Every time a new feature is introduced, people are concerned about it. There is one side of the group that is ecstatic about the change, and the other side that fears the change. I heard the most common concerns for React Hooks are:Everything changes! Subtle panic mode …React is becoming bloated like Angular!It’s useless, classes worked fine.It’s magic!Let me address these concerns here:Everything changes: React Hooks will change how we write React applications in the future. However, at the moment, nothing changes. You can still write class components with local state and lifecycle methods and deploy advanced patterns such as Higher-Order Components or Render Prop Components. Nobody takes these learnings away from you. See how I upgraded all my open source projects from older versions to React 16.6. and none of of these projects had problems. They are using HOCs, Render Props and I believe even the old context API (correct me if am wrong). Everything I have learned all these years still works. The React team makes sure that React stays backward compatible. It will be the same with React 16.7.React is becoming bloated like Angular: React was always seen as a library with a slim API. That’s true and shall be true in the future. However, in order to adjust things that were the status quo of building component-based applications a few years ago, and not to be overtaken by other libraries who adapt to the new status quo, React introduces changes in favor of older APIs. If React would start out fresh this year, maybe there would be only function components and hooks. But React was released a couple of years ago and needs to adapt to keep up with the status quo or to invent a status quo. Maybe there will follow deprecations of React class components and lifecycle methods in a few years in favor of React function components and hooks, but at the moment, the React team keeps React class components in their repertoire of tools. After all, the React team utilizes hooks as an invention to run a marathon with React an not to win a sprint. Obviously, React Hooks add yet another API to React, but it is in favor to simplify React’s API in the future. I like this transition more than having a React 2 where everything is different.It’s useless, classes worked fine: Imagine you would start from zero to learn React and you would be introduced to React with Hooks. Maybe create-react-app wouldn’t start out with a React class component but with a React function component. Everything you need to learn for your components would be React Hooks. They manage state and side-effects, so you would only need to know about the state and the effect hook. It’s everything a React class component did for you before. It will be simpler for React beginners to learn React without all the other overhead that comes with JavaScript classes (inheritance, this, bindings, super, …). Imagine React Hooks as a new way of how to write React components - It’s a new mindset. I am a skeptical person myself, but once I wrote a couple of simpler scenarios with React Hooks, I was convinced that this is the simplest way to write but also to learn React. As someone who is doing lots of React workshops, I argue that it takes away all the frustration classes bring on the table for React beginners.It’s magic: React is known to be down to earth with JavaScript. Writing React applications makes you a better JavaScript developer - that’s one of the best things about React when someone asks me: “Why should I learn React?”. Whether there comes another library in the future or not, everyone is prepared by honing their JavaScript skills and general programming skills when using React. It’s one of the things that made Redux, often used in React, popular: There is no magic, it is plain JavaScript. Now these React Hooks come along the way, introduce something stateful in a previously often pure function component, a couple of not easily to accept rules, and many don’t understand what’s going on under the hood. But think about it this way: A function component in React is not a mere function. You still have to import React as library to your source code file. It does something with your function, because the function becomes a function component in React land. This function component comes with hidden implementations that were there all the time. How else would it have been possible to use functions as function components as we did it before React Hooks were introduced? And people accepted it too, even though it’s kinda magic. Now, the only thing changed (and maybe it has already been this way before) is that these function components come with an extra hidden object that keeps track of hooks. To quote Dan Abramov from his article about hooks: “Perhaps you’re wondering where React keeps the state for Hooks. The answer is it’s kept in the exact same place where React keeps state for classes. React has an internal update queue which is the source of truth for any state, no matter how you define your components.”.Finally, think about it this way: Component-based solutions such as Angular, Vue, and React are pushing the boundaries of web development with every release. They build up on top of technologies that were invented more than two decades ago. They adapt them to make web development effortless in 2018 and not 1998. They optimize them like crazy to meet the needs in the here and now. We are building web applications with components and not with HTML templates anymore. We are not there yet, but I imagine a future where we sit together and invent a component-based standard for the browser. Angular, Vue and React are only the spearhead of this movement.In the following, I want to dive into a few popular React Hooks by example to get you up to speed. All examples can be found in this GitHub repository.You have seen the useState Hook before in a code snippet for a typical counter example. It is used to manage local state in function components. Let’s use the hook in a more elaborate example where we are going to manage an array of items. In another article of mine, you can learn more about managing arrays as state in React, but this time we are doing it with React hooks. Let’s get started:12345678910111213141516171819202122232425262728293031import React, &#123; useState &#125; from &apos;react&apos;;const INITIAL_LIST = [ &#123; id: &apos;0&apos;, title: &apos;React with RxJS for State Management Tutorial&apos;, url: &apos;https://www.robinwieruch.de/react-rxjs-state-management-tutorial/&apos;, &#125;, &#123; id: &apos;1&apos;, title: &apos;A complete React with Apollo and GraphQL Tutorial&apos;, url: &apos;https://www.robinwieruch.de/react-graphql-apollo-tutorial&apos;, &#125;,];function App() &#123; const [list, setList] = useState(INITIAL_LIST); return ( &lt;ul&gt; &#123;list.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;export default App;The useState hook accepts an initial state as argument and returns, by using array destructuring, two variables that can be named however you want to name them. Whereas the first variable is the actual state, the second variable is a function to update the state by providing a new state.The goal of this scenario is to remove an item from the list. In order to accomplish it, every item in the rendered list has a button with a click handler. The click handler can be inlined in the function component, because it will make use of list and setList later. Hence you don’t need to pass these variables to the handler, because they are already available from the outer scope of the component.123456789101112131415161718192021function App() &#123; const [list, setList] = useState(INITIAL_LIST); function onRemoveItem() &#123; // remove item from &quot;list&quot; // set the new list in state with &quot;setList&quot; &#125; return ( &lt;ul&gt; &#123;list.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;button type=&quot;button&quot; onClick=&#123;onRemoveItem&#125;&gt; Remove &lt;/button&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;Somehow we need to know about the item that should be removed from the list. Using a higher-order function, we can pass the identifier of the item to the handler function. Otherwise we wouldn’t be able to identify the item that should be removed from the list.123456789101112131415161718192021function App() &#123; const [list, setList] = useState(INITIAL_LIST); function onRemoveItem(id) &#123; // remove item from &quot;list&quot; // set the new list in state with &quot;setList&quot; &#125; return ( &lt;ul&gt; &#123;list.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; onRemoveItem(item.id)&#125;&gt; Remove &lt;/button&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;Finally, use the identifier to filter the list with a built-in array method. It returns a new list which is used to set the new state of the list.123456789101112131415161718192021function App() &#123; const [list, setList] = useState(INITIAL_LIST); function onRemoveItem(id) &#123; const newList = list.filter(item =&gt; item.id !== id); setList(newList); &#125; return ( &lt;ul&gt; &#123;list.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; onRemoveItem(item.id)&#125;&gt; Remove &lt;/button&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;That should do the job. You are able to remove an item from the list based on the identifier you pass to the handler. The handler then filters the list and sets the new state of the list with the setList function.The useState hook gives you everything you need to manage state in a function component: initial state, the latest state, and a state update function. Everything else is JavaScript again. Furthermore, you don’t need to bother about the state object with its shallow merge as before in a class component. Instead, you encapsulate one domain (e.g. list) with useState, but if you would need another state (e.g. counter), then just encapsulate this domain with another useState. You can read more about the useState hook in React’s documentation.Let’s head over to the next hook called useEffect. As mentioned before, function components should be able to manage state and side-effects with hooks. Managing state was showcased with the useState hook. Now comes the useEffect hook into play for side-effects which are usually used for interactions with the Browser/DOM API or external API like data fetching. Let’s see how the useEffect hook can be used for interaction with the Browser API by implementing a simple stopwatch. You can see how it is done in a React class component in this GitHub repository.1234567891011121314151617181920212223import React, &#123; useState &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); return ( &lt;div&gt; &#123;!isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt; Start &lt;/button&gt; )&#125; &#123;isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt; Stop &lt;/button&gt; )&#125; &lt;/div&gt; );&#125;export default App;There is no stopwatch yet. But at least there are is a conditional rendering to show either a “Start” or “Stop” button. The state for the boolean flag is managed by the useState hook.Let’s introduce our side-effect with useEffect that registers an interval. The function used for the interval emits a console logging every second to your developer tools of your browser.123456789101112131415161718192021222324252627import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); &#125;); return ( &lt;div&gt; &#123;!isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt; Start &lt;/button&gt; )&#125; &#123;isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt; Stop &lt;/button&gt; )&#125; &lt;/div&gt; );&#125;export default App;In order to remove the interval when the component unmounts (but also after every other render update), you can return a function in useEffect for anything to be called for the clean up. For instance, there shouldn’t be any memory leak left behind when the component isn’t there anymore.123456789101112131415import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); return () =&gt; clearInterval(interval); &#125;); ...&#125;export default App;Now, you want to setup the side-effect when mounting the component and the clean up the side-effect when unmounting the component. If you would log how many times the function within the effect is called, you would see that it sets a new interval every time the state of the component changes (e.g. click on “Start”/“Stop” button).12345678910111213141516import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; console.log(&apos;effect runs&apos;); const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); return () =&gt; clearInterval(interval); &#125;); ...&#125;export default App;In order to only run the effect on mount and unmount of the component, you can pass it an empty array as second argument.123456789101112131415import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); return () =&gt; clearInterval(interval); &#125;, []); ...&#125;export default App;However, since the interval is cleaned up after every render too, we need to set the interval in our update cycle too. But we can tell the effect to run only when the isOn variable changes. Only when one of the variables in the array changes, the effect will run during the update cycle. If you keep the array empty, the effect will only run on mount and unmount, because there is no variable to be checked for running the side-effect again.123456789101112131415import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); return () =&gt; clearInterval(interval); &#125;, [isOn]); ...&#125;export default App;The interval is running whether the isOn boolean is true or false. It would be great to only run it when the stopwatch is activated.12345678910111213141516171819import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; let interval; if (isOn) &#123; interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); &#125; return () =&gt; clearInterval(interval); &#125;, [isOn]); ...&#125;export default App;Now introduce another state in your function component to keep track of the timer of the stopwatch. It is used to update the timer, but only when the stopwatch is activated.123456789101112131415161718192021222324252627282930313233343536373839import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); const [timer, setTimer] = useState(0); useEffect(() =&gt; &#123; let interval; if (isOn) &#123; interval = setInterval( () =&gt; setTimer(timer + 1), 1000, ); &#125; return () =&gt; clearInterval(interval); &#125;, [isOn]); return ( &lt;div&gt; &#123;timer&#125; &#123;!isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt; Start &lt;/button&gt; )&#125; &#123;isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt; Stop &lt;/button&gt; )&#125; &lt;/div&gt; );&#125;export default App;There is still one mistake in the code. When the interval is running, it updates the timer every second by increasing it by one. However, it always relies on a stale state for the timer. Only when the inOn boolean flag changes the state is fine. In order to receive always the latest state for the timer when the interval is running, you can use a function instead for the state update function which always has the latest state.1234567891011121314151617181920212223import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); const [timer, setTimer] = useState(0); useEffect(() =&gt; &#123; let interval; if (isOn) &#123; interval = setInterval( () =&gt; setTimer(timer =&gt; timer + 1), 1000, ); &#125; return () =&gt; clearInterval(interval); &#125;, [isOn]); ...&#125;export default App;An alternative would have been to run the effect also when the timer changes. Then the effect would receive the latest timer state.1234567891011121314151617181920212223import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); const [timer, setTimer] = useState(0); useEffect(() =&gt; &#123; let interval; if (isOn) &#123; interval = setInterval( () =&gt; setTimer(timer + 1), 1000, ); &#125; return () =&gt; clearInterval(interval); &#125;, [isOn, timer]); ...&#125;export default App;That’s the implementation for the stopwatch that uses the Browser API If you want to continue, you can extend the example by providing a “Reset” button too.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); const [timer, setTimer] = useState(0); useEffect(() =&gt; &#123; let interval; if (isOn) &#123; interval = setInterval( () =&gt; setTimer(timer =&gt; timer + 1), 1000, ); &#125; return () =&gt; clearInterval(interval); &#125;, [isOn]); const onReset = () =&gt; &#123; setIsOn(false); setTimer(0); &#125;; return ( &lt;div&gt; &#123;timer&#125; &#123;!isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt; Start &lt;/button&gt; )&#125; &#123;isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt; Stop &lt;/button&gt; )&#125; &lt;button type=&quot;button&quot; disabled=&#123;timer === 0&#125; onClick=&#123;onReset&#125;&gt; Reset &lt;/button&gt; &lt;/div&gt; );&#125;export default App;That’s it. The useEffect hook is used for side-effects in React function components that are used for interacting with the Browser/DOM API or other third-party APIs (e.g. data fetching). You can read more about the useEffect hook in React’s documentation.Last but not least, after you have learned about the two most popular hooks that introduce state and side-effects in function components, there is one last thing I want to show you: custom hooks. That’s right, you can implement your own custom React Hooks that can be reused in your application or by others. Let’s see how they work with an example application which is able to detect whether your device is online or offline.12345678910111213import React, &#123; useState &#125; from &apos;react&apos;;function App() &#123; const [isOffline, setIsOffline] = useState(false); if (isOffline) &#123; return &lt;div&gt;Sorry, you are offline ...&lt;/div&gt;; &#125; return &lt;div&gt;You are online!&lt;/div&gt;;&#125;export default App;Again, introduce the useEffect hook for the side-effect. In this case, the effect adds and removes listeners that check if the device is online or offline. Both listeners are setup only once on mount and cleaned up once on unmount (empty array as second argument). Whenever one of the listeners is called, it sets the state for the isOffline boolean.12345678910111213141516171819202122232425262728293031import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOffline, setIsOffline] = useState(false); function onOffline() &#123; setIsOffline(true); &#125; function onOnline() &#123; setIsOffline(false); &#125; useEffect(() =&gt; &#123; window.addEventListener(&apos;offline&apos;, onOffline); window.addEventListener(&apos;online&apos;, onOnline); return () =&gt; &#123; window.removeEventListener(&apos;offline&apos;, onOffline); window.removeEventListener(&apos;online&apos;, onOnline); &#125;; &#125;, []); if (isOffline) &#123; return &lt;div&gt;Sorry, you are offline ...&lt;/div&gt;; &#125; return &lt;div&gt;You are online!&lt;/div&gt;;&#125;export default App;Everything is nicely encapsulated in one effect now. It’s a great functionality which should be reuse somewhere else too. That’s why we can extract the functionality as its a custom hook which follows the same naming convention as the other hooks.12345678910111213141516171819202122232425262728293031323334353637import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function useOffline() &#123; const [isOffline, setIsOffline] = useState(false); function onOffline() &#123; setIsOffline(true); &#125; function onOnline() &#123; setIsOffline(false); &#125; useEffect(() =&gt; &#123; window.addEventListener(&apos;offline&apos;, onOffline); window.addEventListener(&apos;online&apos;, onOnline); return () =&gt; &#123; window.removeEventListener(&apos;offline&apos;, onOffline); window.removeEventListener(&apos;online&apos;, onOnline); &#125;; &#125;, []); return isOffline;&#125;function App() &#123; const isOffline = useOffline(); if (isOffline) &#123; return &lt;div&gt;Sorry, you are offline ...&lt;/div&gt;; &#125; return &lt;div&gt;You are online!&lt;/div&gt;;&#125;export default App;Extracting the custom hook as function was not the only thing. You also have to return the isOffline state from the custom hook in order to use it in your application to show a message to users who are offline. Otherwise, it should render the normal application. That’s it for the custom hook that detects whether you are online or offline. You can read more about custom hooks in React’s documentation.React Hooks being reusable is the best thing about them, because there is the potential to grow an ecosystem of custom React Hooks that can be installed from npm for any React application. And not only for React applications. Evan You, creator of Vue, is hooked (!) by them as well. Maybe we will see a bridge between both ecosystems where it is possible to share hooks between Vue and React.If you want to dive deeper into the state and effect hooks, you can check out the following React hook tutorials:How to useReducer Hook?Migration from Class Components to HooksComparison useState vs useReducerModern State Management with HooksHow to fetch data with React HooksCheckout the official FAQ and Rules for hooks in React’s documentation to learn more about their fine-grained behaviour. In addition, you can checkout all officially available React Hooks too.For everyone who is still concerned about React Hooks: Give them a shot yourself. Implement a couple of React function components with state and side-effects. I had to do it myself to understand how they work and to feel comfortable with them. And I must say it feels pretty great to use them.The Road to learn ReactBuild a Hacker News App along the way. No setup configuration. No tooling. No Redux. Plain React in 200+ pages of learning material. Learn React like 50.000+ readers.Get the Book for freeNever miss an article about web development, JavaScript and self-growth.Take PartJoin 30.000+ DevelopersLearn Web Development with JavaScriptTips and TricksAccess Tutorials, eBooks and CoursesPersonal Development as a Software Engineer本文作者： Andy本文地址： https://andyxw.com/archives/ef81.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>前端</tag>
        <tag>React Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端相关文章收藏]]></title>
    <url>%2Farchives%2Ff37d.html</url>
    <content type="text"><![CDATA[前端架构支付宝前端应用架构的发展和选择本文作者： Andy本文地址： https://andyxw.com/archives/f37d.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>链接</tag>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器重置密码]]></title>
    <url>%2Farchives%2Ffe92.html</url>
    <content type="text"><![CDATA[有时候会忘记服务器密码，但是可以通过官网面板等方式连上时，可使用下面的命令修改root密码：整段赋值下面的命令（”新密码”处 替换为要修改的密码）：1234echo root:新密码 |sudo chpasswd rootsudo sed -i &apos;s/^.*PermitRootLogin.*/PermitRootLogin yes/g&apos; /etc/ssh/sshd_config;sudo sed -i &apos;s/^.*PasswordAuthentication.*/PasswordAuthentication yes/g&apos; /etc/ssh/sshd_config;sudo reboot重启后用root账户登录即可。本文作者： Andy本文地址： https://andyxw.com/archives/fe92.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Linux</tag>
        <tag>重置密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解密传统组件间通信与React组件间通信]]></title>
    <url>%2Farchives%2Fac71.html</url>
    <content type="text"><![CDATA[在React中最小的逻辑单元是组件，组件之间如果有耦合关系就会进行通信，本文将会介绍React中的组件通信的不同方式通过归纳范，可以将任意组件间的通信归类为四种类型的组件间通信，分别是父子组件，爷孙组件，兄弟组件和任意组件，需要注意的是前三个也可以算作任意组件的范畴，所以最后一个是万能方法父子组件父子组件间的通信分为父组件向子组件通信和子组件向父组件通信两种情况，下面先来介绍父组件向子组件通信，传统做法分为两种情况，分别是初始化时的参数传递和实例阶段的方法调用，例子如下12345678910111213141516171819202122232425262728class Child &#123; constructor(name) &#123; // 获取dom引用 this.$div = document.querySelector('#wp'); // 初始化时传入name this.updateName(name); &#125; updateName(name) &#123; // 对外提供更新的api this.name = name; // 更新dom this.$div.innerHTML = name; &#125;&#125;class Parent &#123; constructor() &#123; // 初始化阶段 this.child = new Child('yan'); setTimeout(() =&gt; &#123; // 实例化阶段 this.child.updateName('hou'); &#125;, 2000); &#125;&#125;在React中将两个情况统一处理，全部通过属性来完成，之所以能够这样是因为React在属性更新时会自动重新渲染子组件，下面的例子中，2秒后子组件会自动重新渲染，并获取新的属性值1234567891011121314151617181920class Child extends Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt; &#125;&#125;class Parent extends Component &#123; constructor() &#123; // 初始化阶段 this.state = &#123;name: 'yan'&#125;; setTimeout(() =&gt; &#123; // 实例化阶段 this.setState(&#123;name: 'hou'&#125;) &#125;, 2000); &#125; render() &#123; return &lt;Child name=&#123;this.state.name&#125; /&gt; &#125;&#125;下面来看一下子组件如何向父组件通信，传统做法有两种，一种是回调函数，另一种是为子组件部署消息接口先来看回调函数的例子，回调函数的优点是非常简单，缺点就是必须在初始化的时候传入，并且不可撤回，并且只能传入一个函数123456789101112131415class Child &#123; constructor(cb) &#123; // 调用父组件传入的回调函数，发送消息 setTimeout(() =&gt; &#123; cb() &#125;, 2000); &#125;&#125;class Parent &#123; constructor() &#123; // 初始化阶段，传入回调函数 this.child = new Child(function () &#123; console.log('child update') &#125;); &#125;&#125;下面来看看消息接口方法，首先需要一个可以发布和订阅消息的基类，比如下面实现了一个简单的EventEimtter，实际生产中可以直接使用别人写好的类库，比如@jsmini/event，子组件继承消息基类，就有了发布消息的能力，然后父组件订阅子组件的消息，即可实现子组件向父组件通信的功能消息接口的优点就是可以随处订阅，并且可以多次订阅，还可以取消订阅，缺点是略显麻烦，需要引入消息基类123456789101112131415161718192021222324252627282930313233// 消息接口，订阅发布模式，类似绑定事件，触发事件class EventEimtter &#123; constructor() &#123; this.eventMap = &#123;&#125;; &#125; sub(name, cb) &#123; const eventList = this.eventMap[name] = this.eventMap[name] || &#123;&#125;; eventList.push(cb); &#125; pub(name, ...data) &#123; (this.eventMap[name] || []).forEach(cb =&gt; cb(...data)); &#125;&#125;class Child extends EventEimtter &#123; constructor() &#123; super(); // 通过消息接口发布消息 setTimeout(() =&gt; &#123; this.pub('update') &#125;, 2000); &#125;&#125;class Parent &#123; constructor() &#123; // 初始化阶段，传入回调函数 this.child = new Child(); // 订阅子组件的消息 this.child.sub('update', function () &#123; console.log('child update') &#125;); &#125;&#125;Backbone.js就同时支持回调函数和消息接口方式，但React中选择了比较简单的回调函数模式，下面来看一下React的例子1234567891011121314class Child extends Component &#123; constructor(props) &#123; setTimeout(() =&gt; &#123; this.props.cb() &#125;, 2000); &#125; render() &#123; return &lt;div&gt;&lt;/div&gt; &#125;&#125;class Parent extends Component &#123; render() &#123; return &lt;Child cb=&#123;() =&gt; &#123;console.log('update')&#125;&#125; /&gt; &#125;&#125;爷孙组件父子组件其实可以算是爷孙组件的一种特例，这里的爷孙组件不光指爷爷和孙子，而是泛指祖先与后代组件通信，可能隔着很多层级，我们已经解决了父子组件通信的问题，根据化归法，很容易得出爷孙组件的答案，那就是层层传递属性么，把爷孙组件通信分解为多个父子组件通信的问题层层传递的优点是非常简单，用已有知识就能解决，问题是会浪费很多代码，非常繁琐，中间作为桥梁的组件会引入很多不属于自己的属性在React中，通过context可以让祖先组件直接把属性传递到后代组件，有点类似星际旅行中的虫洞一样，通过context这个特殊的桥梁，可以跨越任意层次向后代组件传递消息怎么在需要通信的组件之间开启这个虫洞呢？需要双向声明，也就是在祖先组件声明属性，并在后代组件上再次声明属性，然后在祖先组件上放上属性就可以了，就可以在后代组件读取属性了，下面看一个例子123456789101112131415161718192021222324import PropTypes from 'prop-types';class Child extends Component &#123; // 后代组件声明需要读取context上的数据 static contextTypes = &#123; text: PropTypes.string &#125; render() &#123; // 通过this.context 读取context上的数据 return &lt;div&gt;&#123;this.context.text&#125;&lt;/div&gt; &#125;&#125;class Ancestor extends Component &#123; // 祖先组件声明需要放入context上的数据 static childContextTypes = &#123; text: PropTypes.string &#125; // 祖先组件往context放入数据 getChildContext() &#123; return &#123;text: 'yanhaijing'&#125; &#125;&#125;context的优点是可以省去层层传递的麻烦，并且通过双向声明控制了数据的可见性，对于层数很多时，不失为一种方案；但缺点也很明显，就像全局变量一样，如果不加节制很容易造成混乱，而且也容易出现重名覆盖的问题个人的建议是对一些所有组件共享的只读信息可以采用context来传递，比如登录的用户信息等小贴士：React Router路由就是通过context来传递路由属性的兄弟组件如果两个组件是兄弟关系，可以通过父组件作为桥梁，来让两个组件之间通信，这其实就是主模块模式下面的例子中，两个子组件通过父组件来实现显示数字同步的功能123456789101112131415class Parent extends Component &#123; constructor() &#123; this.onChange = function (num) &#123; this.setState(&#123;num&#125;) &#125;.bind(this); &#125; render() &#123; return ( &lt;div&gt; &lt;Child1 num=&#123;this.state.num&#125; onChange=&#123;this.onChange&#125;&gt; &lt;Child2 num=&#123;this.state.num&#125; onChange=&#123;this.onChange&#125;&gt; &lt;/div&gt; ); &#125;&#125;主模块模式的优点就是解耦，把两个子组件之间的耦合关系，解耦成子组件和父组件之间的耦合，把分散的东西收集在一起好处非常明显，能带来更好的可维护性和可扩展性任意组件任意组件包括上面的三种关系组件，上面三种关系应该优先使用上面介绍的方法，对于任意的两个组件间通信，总共有三种办法，分别是共同祖先法，消息中间件和状态管理基于我们上面介绍的爷孙组件和兄弟组件，只要找到两个组件的共同祖先，就可以将任意组件之间的通信，转化为任意组件和共同祖先之间的通信，这个方法的好处就是非常简单，已知知识就能搞定，缺点就是上面两种模式缺点的叠加，除了临时方案，不建议使用这种方法另一种比较常用的方法是消息中间件，就是引入一个全局消息工具，两个组件通过这个全局工具进行通信，这样两个组件间的通信，就通过全局消息媒介完成了还记得上面介绍的消息基类吗？下面的例子中，组件1和组件2通过全局event进行通信12345678910111213141516171819202122232425262728293031class EventEimtter &#123; constructor() &#123; this.eventMap = &#123;&#125;; &#125; sub(name, cb) &#123; const eventList = this.eventMap[name] = this.eventMap[name] || &#123;&#125;; eventList.push(cb); &#125; pub(name, ...data) &#123; (this.eventMap[name] || []).forEach(cb =&gt; cb(...data)); &#125;&#125;// 全局消息工具const event = new EventEimtter;// 一个组件class Element1 extends Component &#123; constructor() &#123; // 订阅消息 event.sub('element2update', () =&gt; &#123;console.log('element2 update')&#125;); &#125;&#125;// 另一个组件。class Element2 extends Component &#123; constructor() &#123; // 发布消息 setTimeout(function () &#123; event.pub('element2update') &#125;, 2000) &#125;&#125;消息中间件的模式非常简单，利用了观察者模式，将两个组件之间的耦合解耦成了组件和消息中心+消息名称的耦合，但为了解耦却引入全局消息中心和消息名称，消息中心对组件的侵入性很强，和第三方组件通信不能使用这种方式小型项目比较适合使用这种方式，但随着项目规模的扩大，达到中等项目以后，消息名字爆炸式增长，消息名字的维护成了棘手的问题，重名概率极大，没有人敢随便删除消息信息，消息的发布者找不到消息订阅者的信息等其实上面的问题也不是没有解决办法，重名的问题可以通过制定规范，消息命名空间等方式来极大降低冲突，其他问题可以通过把消息名字统一维护到一个文件，通过对消息的中心化管理，可以让很多问题都很容易解决如果你的项目非常大，上面两种方案都不合适，那你可能需要一个状态管理工具，通过状态管理工具把组件之间的关系，和关系的处理逻辑从组建中抽象出来，并集中化到统一的地方来处理，Redux就是一个非常不错的状态管理工具除了Redux，还有Mobx，Rematch，reselect等工具，本文不展开介绍，有机会后面单独成文，这些都是用来解决不同问题的，只要根据自己的场景选择合适的工具就好了总结组件间的关系千变万化，都可以用上面介绍的方法解决，对于不同规模的项目，应该选择适合自己的技术方案，上面介绍的不同方式解耦的程度是不一样的，关于不同耦合关系的好坏，可以看我之前的文章《图解7种耦合关系》本文作者： Andy本文地址： https://andyxw.com/archives/ac71.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解7种耦合关系]]></title>
    <url>%2Farchives%2F7e29.html</url>
    <content type="text"><![CDATA[深入讲讲模块之间的耦合关系这个事情。本文将用图文详细讲解七种耦合的不同之处。高内聚与低耦合高内聚与低耦合是每个软件开发者追求的目标，那么内聚和耦合分别是什么意思呢？内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。耦合不同模块之间的关系就是耦合，根据耦合程度可以分为7种，耦合度依次变低。内容耦合公共耦合外部耦合控制耦合标记耦合数据耦合非直接耦合下面我们来说说每种耦合是什么，开始之前先来说下要实现的功能。m1和m2是两个独立的模块，其中m2种会显示m1的输入，m1会显示m2的输入。很显然，m1和m2两个模块之间会有一些联系（耦合），你也可以想想如何实现这个功能，下面用7种不同的方式来实现这个功能。注：项目的代码我放到了github，项目的demo，可以在这里查看。内容耦合内容耦合是最紧的耦合程度，一个模块直接访问另一模块的内容，则称这两个模块为内容耦合。为了实现功能，我们将m1的输入放到m2.m1input上，将m2的输入放到m1.m2input上。// m1.js root.m2.m1input = this.value; m2.update(); // m2.js root.m1.m2input = this.value; m1.update(); PS:不知道谁会这么写代码，除了我为了做演示之外。。。查看完整代码和demo。公共耦合一组模块都访问同一个全局数据结构，则称之为公共耦合。在这种case中，m1和m2将自己的输入放到全局的data上。// m1.js root.data.m1input = this.value; m2.update(); // m2.js root.data.m2input = this.value; m1.update(); 查看完整代码和demo。外部耦合一组模块都访问同一全局简单变量，而且不通过参数表传递该全局变量的信息，则称之为外部耦合。外部耦合和公共耦合很像，区别就是一个是简单变量，一个是复杂数据结构。在这种case中，m1和m2都将自己的输入放到全局上。// m1.js root.m1input = this.value; m2.update(); // m2.js root.m2input = this.value; m1.update(); 查看完整代码和demo。控制耦合模块之间传递的不是数据信息，而是控制信息例如标志、开关量等，一个模块控制了另一个模块的功能。从控制耦合开始，模块的数据就放在自己内部了，不同模块之间通过接口互相调用。在这个case中，得增加一个需求，就是当m1的输入为空时，隐藏m2的显示信息。// m1.js root.m1input = this.value; m2.update(); m2.toggle(!!this.value); // 传递flag 上面的代码中m1直接控制了m2的显示和隐藏。查看完整代码和demo。标记耦合调用模块和被调用模块之间传递数据结构而不是简单数据，同时也称作特征耦合。在这个case中，m1传给m2的是一个对象。// m1.js me.m1input = this.value; m2.update(me); // 传递引用 // m2.js me.m2input = this.value; m1.update(me); 查看完整代码和demo。数据耦合调用模块和被调用模块之间只传递简单的数据项参数。相当于高级语言中的值传递。在这个case中，m1传给m2的是一个简单数据结构。// m1.js me.m1input = this.value; m2.update(me.m1input); // 传递值 // m2.js me.m2input = this.value; m1.update(me.m2input); 查看完整代码和demo。非直接耦合两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。耦合度最弱，模块独立性最强。子模块无需知道对方的存在，子模块之间的联系，全部变成子模块和主模块之间的联系。在这个case种，增加一个index.js作为主模块。// index.js var m1 = root.m1; var m2 = root.m2; m1.init(function (str) { m2.update(str); }); m2.init(function (str) { m1.update(str); }); // m1.js me.m1input = this.value; inputcb(me.m1input); // inputcb是回调函数 // m2.js me.m2input = this.value; inputcb(me.m2input); 查看完整代码和demo。内聚其实关于内聚也分为很多种，如下所示，如果你感兴趣可以自己研究研究，我们下次再来分享内聚的问题。偶然内聚逻辑内聚时间内聚通信内聚顺序内聚功能内聚总结希望你看完上面的文章，搞懂了耦合的种类，也希望你以后能使用非直接耦合这种方式来写代码，祝好。本文作者： Andy本文地址： https://andyxw.com/archives/7e29.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鸡汤]]></title>
    <url>%2Farchives%2F201.html</url>
    <content type="text"><![CDATA[这是篇有密码的博客 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 技术栈]]></title>
    <url>%2Farchives%2F4a9b.html</url>
    <content type="text"><![CDATA[React 技术栈React 是目前最热门的前端框架。Facebook 公司2013年推出现在最好的社区支持和生态圈大量的第三方工具React 的优点组件模式：代码复用和团队分工虚拟 DOM：性能优势移动端支持：跨终端React 的缺点学习曲线较陡峭全新的一套概念，与其他所有框架截然不同只有采用它的整个技术栈，才能发挥最大威力总结：React 非常先进和强大，但是学习和实现成本都不低JSX 语法React 使用 JSX 语法，JavaScript 代码中可以写 HTML 代码。1let myTitle = &lt;h1&gt;Hello, world!&lt;/h1&gt;;JSX 语法解释（1）JSX 语法的最外层，只能有一个节点。12// 错误let myTitle = &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;;（2）JSX 语法中可以插入 JavaScript 代码，使用大括号。1let myTitle = &lt;p&gt;&#123;'Hello ' + 'World'&#125;&lt;/p&gt;Babel 转码器JavaScript 引擎（包括浏览器和 Node）都不认识 JSX，需要首先使用 Babel 转码，然后才能运行。123456&lt;script src="react.js"&gt;&lt;/script&gt;&lt;script src="react-dom.js"&gt;&lt;/script&gt;&lt;script src="babel.min.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt; // ** Our code goes here! **&lt;/script&gt;React 需要加载两个库：React 和 React-DOM，前者是 React 的核心库，后者是 React 的 DOM 适配库。Babel 用来在浏览器转换 JSX 语法，如果服务器已经转好了，浏览器就不需要加载这个库。课堂练习：JSX 语法浏览器打开demos/jsx-demo/index.html，按照《操作说明》，完成练习。1234ReactDOM.render( &lt;span&gt;Hello World!&lt;/span&gt;, document.getElementById('example'));示例：React 组件React 允许用户定义自己的组件，插入网页。浏览器打开demos/react-component-demo/index1.html，按照《操作说明》，仔细查看源码。12345678910class MyTitle extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello World&lt;/h1&gt;; &#125;&#125;;ReactDOM.render( &lt;MyTitle/&gt;, document.getElementById('example'));课堂练习：组件的参数组件可以从外部传入参数，内部使用this.props获取参数。打开demos/react-component-demo/index2.html，按照《操作说明》，完成练习。123456789class MyTitle extends React.Component &#123; render() &#123; return &lt;h1 style=&#123;&#123;color: this.props.color&#125;&#125; &gt;Hello World&lt;/h1&gt;; &#125;&#125;;&lt;MyTitle color="red" /&gt;,示例：组件的状态组件往往会有内部状态，使用this.state表示。浏览器打开demos/react-component-demo/index3.html，按照《操作说明》，仔细查看源码。课堂练习：React 组件实战浏览器打开demos/react-component-demo/index4.html，按照《操作说明》，完成练习。组件的生命周期React 为组件的不同生命阶段，提供了近十个钩子方法。componentWillMount()：组件加载前调用componentDidMount()：组件加载后调用componentWillUpdate(): 组件更新前调用componentDidUpdate(): 组件更新后调用componentWillUnmount()：组件卸载前调用componentWillReceiveProps()：组件接受新的参数时调用我们可以利用这些钩子，自动完成一些操作。课堂练习：组件的生命周期组件可以通过 Ajax 请求，从服务器获取数据。Ajax 请求一般在componentDidMount方法里面发出。123456componentDidMount() &#123; const url = '...'; $.getJSON(url) .done() .fail();&#125;打开demos/react-lifecycle-demo/index.html，按照《操作说明》，完成练习。React 组件库React 的一大优势，就是网上有很多已经写好的组件库，可以使用。React-Bootstrap：https://react-bootstrap.github.io/示例：ReChartsReCharts 是一个 React 图表组件库。http://recharts.org/浏览器打开demos/recharts-demo/index.html，按照《操作说明》，仔细查看源码，体会 JSX 语法对表达复杂组件的优势。1234567&lt;LineChart width=&#123;1000&#125; height=&#123;400&#125; data=&#123;data&#125;&gt; &lt;XAxis dataKey="name"/&gt; &lt;YAxis/&gt; &lt;CartesianGrid stroke="#eee" strokeDasharray="5 5"/&gt; &lt;Line type="monotone" dataKey="uv" stroke="#8884d8" /&gt; &lt;Line type="monotone" dataKey="pv" stroke="#82ca9d" /&gt;&lt;/LineChart&gt;React 的核心思想View 是 State 的输出。1view = f(state)上式中，f表示函数关系。只要 State 发生变化，View 也要随之变化。React 的本质是将图形界面（GUI）函数化。12345678const person = &#123; name: "michel", age: 31&#125;const App = (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body)React 没有解决的问题React 本身只是一个 DOM 的抽象层，使用组件构建虚拟 DOM。如果开发大应用，还需要解决两个问题。架构：大型应用程序应该如何组织代码？通信：组件之间如何通信？架构问题React 只是视图层的解决方案，可以用于任何一种架构。MVCMVVMObserverReactive…到底哪一种架构最合适 React ？通信问题组件会发生三种通信。向子组件发消息向父组件发消息向其他组件发消息React 只提供了一种通信手段：传参。对于大应用，很不方便。状态的同步通信的本质是状态的同步。React 同步状态的基本方法：找到通信双方最近的共同父组件，通过它的state，使得子组件的状态保持同步。Flux 架构Facebook 提出 Flux 架构的概念，被认为是 React 应用的标准架构。最大特点：数据单向流动。与 MVVM 的数据双向绑定，形成鲜明对比。Flux 的核心思想不同组件的state，存放在一个外部的、公共的 Store 上面。组件订阅 Store 的不同部分。组件发送（dispatch）动作（action），引发 Store 的更新。Flux 只是一个概念，有30多种实现。目前最流行的两个 React 架构React 架构的最重要作用：管理 Store 与 View 之间的关系。MobX：响应式（Reactive）管理，state 是可变对象，适合中小型项目Redux：函数式（Functional）管理，state 是不可变对象，适合大型项目MobX 架构MobX 的核心是观察者模式。Store 是被观察者（observable）组件是观察者（observer）一旦Store有变化，会立刻被组件观察到，从而引发重新渲染。MobX 的最简单例子1234567891011const &#123;observable&#125; = mobx;const &#123;observer&#125; = mobxReact;const person = observable(&#123;name: "张三", age: 31&#125;);const App = observer( (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;);ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body);person.name = "李四";代码：demos/mobx-demo/browser-demo目录示例：MobX进入demos/mobx-demo目录，按照《操作说明》，理解 MobX 框架。UI 层是观察者，Store 是被观察者。Store 所有的属性，分成两大类：直接被观察的属性和自动计算出来的属性。123456class Store &#123; @observable name = 'Bartek'; @computed get decorated() &#123; return `$&#123;this.name&#125; is awesome!`; &#125;&#125;UI 会观察到 Store 的变化，自动重新渲染。Redux 架构Redux 的核心概念所有的状态存放在Store。组件每次重新渲染，都必须由状态变化引起。用户在 UI 上发出action。reducer函数接收action，然后根据当前的state，计算出新的state。Redux 应用的架构Redux 层保存所有状态，React 组件拿到状态以后，渲染出 HTML 代码。示例：Redux进入demos/redux-demo目录，按照《操作说明》，理解 Redux 框架。Redux 将组件分成 UI 组件和容器组件两类。UI 组件是纯组件，不包含 state 和生命周期方法，不涉及组件的行为，只涉及组件的外观。1234567&lt;div className="index"&gt; &lt;p&gt;&#123;this.props.text&#125;&lt;/p&gt; &lt;input defaultValue=&#123;this.props.name&#125; onChange=&#123;this.props.onChange&#125; /&gt;&lt;/div&gt;容器组件正好相反。不涉及组件的外观，只涉及组件的行为。负责订阅 Store，将 Store 的数据处理以后，再通过参数传给 UI 组件。用户给出配置以后，由 Redux 生成。12345// MyComponent 是纯的 UI 组件const App = connect( mapStateToProps, mapDispatchToProps)(MyComponent);mapStateToProps: 定义 UI 组件参数与 State 之间的映射mapDispatchToProps：定义 UI 组件与 Action 之间的映射拆分 UI 组件和容器组件的好处UI 组件与后台数据无关，可以由设计师负责容器组件只负责数据和行为，一旦 Store 的数据结构变化，只要调整容器组件即可表现层和功能层脱钩，有利于代码重用，也有利于看清应用的数据结构和业务逻辑Reducer 函数reducer是一个纯函数，用来接收action，算出新的state。123456789101112function reducer(state = &#123; text: '你好，访问者', name: '访问者'&#125;, action) &#123; switch (action.type) &#123; case 'change': return &#123; name: action.payload, text: '你好，' + action.payload &#125;; &#125;&#125;Store由 Redux 提供的createStore方法生成，该方法接受reducer作为参数。为了把Store传入组件，必须使用 Redux 提供的Provider组件在应用的最外面，包裹一层。12345678const store = createStore(reducer);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.body.appendChild(document.createElement('div')));本文作者： Andy本文地址： https://andyxw.com/archives/4a9b.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 设计思想]]></title>
    <url>%2Farchives%2F7615.html</url>
    <content type="text"><![CDATA[React 设计思想译者序：本文是 React 核心开发者、有 React API 终结者之称的 Sebastian Markbåge 撰写，阐述了他设计 React 的初衷。阅读此文，你能站在更高的高度思考 React 的过去、现在和未来。原文地址：https://github.com/reactjs/react-basic我写此文是想正式地阐述我心中 React 的心智模型。目的是解释为什么我们会这样设计 React，同时你也可以根据这些论点反推出 React。不可否认，此文中的部分论据或前提尚存争议，而且部分示例的设计可能存在 bug 或疏忽。这只是正式确定它的最初阶段。如果你有更好的完善它的想法可以随时提交 pull request。本文不会介绍框架细节中的奇技淫巧，相信这样能提纲挈领，让你看清 React 由简单到复杂的设计过程。React.js 的真实实现中充满了具体问题的解决方案，渐进式的解法，算法优化，历史遗留代码，debug 工具以及其他一些可以让它真的具有高可用性的内容。这些代码可能并不稳定，因为未来浏览器的变化和功能权重的变化随时面临改变。所以具体的代码很难彻底解释清楚。我偏向于选择一种我能完全 hold 住的简洁的心智模型来作介绍。变换（Transformation）设计 React 的核心前提是认为 UI 只是把数据通过映射关系变换成另一种形式的数据。同样的输入必会有同样的输出。这恰好就是纯函数。123function NameBox(name) &#123; return &#123; fontWeight: 'bold', labelContent: name &#125;;&#125;12&apos;Sebastian Markbåge&apos; -&gt;&#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125;;抽象（Abstraction）你不可能仅用一个函数就能实现复杂的 UI。重要的是，你需要把 UI 抽象成多个隐藏内部细节，又可复用的函数。通过在一个函数中调用另一个函数来实现复杂的 UI，这就是抽象。123456789function FancyUserBox(user) &#123; return &#123; borderStyle: '1px solid blue', childContent: [ 'Name: ', NameBox(user.firstName + ' ' + user.lastName) ] &#125;;&#125;12345678&#123; firstName: &apos;Sebastian&apos;, lastName: &apos;Markbåge&apos; &#125; -&gt;&#123; borderStyle: &apos;1px solid blue&apos;, childContent: [ &apos;Name: &apos;, &#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125; ]&#125;;组合（Composition）为了真正达到重用的特性，只重用叶子然后每次都为他们创建一个新的容器是不够的。你还需要可以包含其他抽象的容器再次进行组合。我理解的“组合”就是将两个或者多个不同的抽象合并为一个。12345678910111213function FancyBox(children) &#123; return &#123; borderStyle: '1px solid blue', children: children &#125;;&#125;function UserBox(user) &#123; return FancyBox([ 'Name: ', NameBox(user.firstName + ' ' + user.lastName) ]);&#125;状态（State）UI 不单单是对服务器端或业务逻辑状态的复制。实际上还有很多状态是针对具体的渲染目标。举个例子，在一个 text field 中打字。它不一定要复制到其他页面或者你的手机设备。滚动位置这个状态是一个典型的你几乎不会复制到多个渲染目标的。我们倾向于使用不可变的数据模型。我们把可以改变 state 的函数串联起来作为原点放置在顶层。1234567891011121314151617181920212223function FancyNameBox(user, likes, onClick) &#123; return FancyBox([ 'Name: ', NameBox(user.firstName + ' ' + user.lastName), 'Likes: ', LikeBox(likes), LikeButton(onClick) ]);&#125;// 实现细节var likes = 0;function addOneMoreLike() &#123; likes++; rerender();&#125;// 初始化FancyNameBox( &#123; firstName: 'Sebastian', lastName: 'Markbåge' &#125;, likes, addOneMoreLike);注意：本例更新状态时会带来副作用（addOneMoreLike 函数中）。我实际的想法是当一个“update”传入时我们返回下一个版本的状态，但那样会比较复杂。此示例待更新Memoization对于纯函数，使用相同的参数一次次调用未免太浪费资源。我们可以创建一个函数的 memorized 版本，用来追踪最后一个参数和结果。这样如果我们继续使用同样的值，就不需要反复执行它了。1234567891011121314151617181920212223function memoize(fn) &#123; var cachedArg; var cachedResult; return function(arg) &#123; if (cachedArg === arg) &#123; return cachedResult; &#125; cachedArg = arg; cachedResult = fn(arg); return cachedResult; &#125;;&#125;var MemoizedNameBox = memoize(NameBox);function NameAndAgeBox(user, currentTime) &#123; return FancyBox([ 'Name: ', MemoizedNameBox(user.firstName + ' ' + user.lastName), 'Age in milliseconds: ', currentTime - user.dateOfBirth ]);&#125;列表（Lists）大部分 UI 都是展示列表数据中不同 item 的列表结构。这是一个天然的层级。为了管理列表中的每一个 item 的 state ，我们可以创造一个 Map 容纳具体 item 的 state。123456789101112131415function UserList(users, likesPerUser, updateUserLikes) &#123; return users.map(user =&gt; FancyNameBox( user, likesPerUser.get(user.id), () =&gt; updateUserLikes(user.id, likesPerUser.get(user.id) + 1) ));&#125;var likesPerUser = new Map();function updateUserLikes(id, likeCount) &#123; likesPerUser.set(id, likeCount); rerender();&#125;UserList(data.users, likesPerUser, updateUserLikes);注意：现在我们向 FancyNameBox 传了多个不同的参数。这打破了我们的 memoization 因为我们每次只能存储一个值。更多相关内容在下面。连续性（Continuations）不幸的是，自从 UI 中有太多的列表，明确的管理就需要大量的重复性样板代码。我们可以通过推迟一些函数的执行，进而把一些模板移出业务逻辑。比如，使用“柯里化”（JavaScript 中的 bind）。然后我们可以从核心的函数外面传递 state，这样就没有样板代码了。下面这样并没有减少样板代码，但至少把它从关键业务逻辑中剥离。123456789101112function FancyUserList(users) &#123; return FancyBox( UserList.bind(null, users) );&#125;const box = FancyUserList(data.users);const resolvedChildren = box.children(likesPerUser, updateUserLikes);const resolvedBox = &#123; ...box, children: resolvedChildren&#125;;State Map之前我们知道可以使用组合避免重复执行相同的东西这样一种重复模式。我们可以把执行和传递 state 逻辑挪动到被复用很多的低层级的函数中去。12345678910111213141516171819202122232425262728function FancyBoxWithState( children, stateMap, updateState) &#123; return FancyBox( children.map(child =&gt; child.continuation( stateMap.get(child.key), updateState )) );&#125;function UserList(users) &#123; return users.map(user =&gt; &#123; continuation: FancyNameBox.bind(null, user), key: user.id &#125;);&#125;function FancyUserList(users) &#123; return FancyBoxWithState.bind(null, UserList(users) );&#125;const continuation = FancyUserList(data.users);continuation(likesPerUser, updateUserLikes);Memoization Map一旦我们想在一个 memoization 列表中 memoize 多个 item 就会变得很困难。因为你需要制定复杂的缓存算法来平衡调用频率和内存占有率。还好 UI 在同一个位置会相对的稳定。相同的位置一般每次都会接受相同的参数。这样以来，使用一个集合来做 memoization 是一个非常好用的策略。我们可以用对待 state 同样的方式，在组合的函数中传递一个 memoization 缓存。12345678910111213141516171819202122232425262728function memoize(fn) &#123; return function(arg, memoizationCache) &#123; if (memoizationCache.arg === arg) &#123; return memoizationCache.result; &#125; const result = fn(arg); memoizationCache.arg = arg; memoizationCache.result = result; return result; &#125;;&#125;function FancyBoxWithState( children, stateMap, updateState, memoizationCache) &#123; return FancyBox( children.map(child =&gt; child.continuation( stateMap.get(child.key), updateState, memoizationCache.get(child.key) )) );&#125;const MemoizedFancyNameBox = memoize(FancyNameBox);代数效应（Algebraic Effects）多层抽象需要共享琐碎数据时，一层层传递数据非常麻烦。如果能有一种方式可以在多层抽象中快捷地传递数据，同时又不需要牵涉到中间层级，那该有多好。React 中我们把它叫做“context”。有时候数据依赖并不是严格按照抽象树自上而下进行。举个例子，在布局算法中，你需要在实现他们的位置之前了解子节点的大小。现在，这个例子有一点超纲。我会使用 代数效应 这个由我发起的 ECMAScript 新特性提议。如果你对函数式编程很熟悉，它们 在避免由 monad 强制引入的仪式一样的编码。123456789101112131415161718192021222324function ThemeBorderColorRequest() &#123; &#125;function FancyBox(children) &#123; const color = raise new ThemeBorderColorRequest(); return &#123; borderWidth: '1px', borderColor: color, children: children &#125;;&#125;function BlueTheme(children) &#123; return try &#123; children(); &#125; catch effect ThemeBorderColorRequest -&gt; [, continuation] &#123; continuation('blue'); &#125;&#125;function App(data) &#123; return BlueTheme( FancyUserList.bind(null, data.users) );&#125;本文作者： Andy本文地址： https://andyxw.com/archives/7615.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React中的state和props]]></title>
    <url>%2Farchives%2F992.html</url>
    <content type="text"><![CDATA[整理一下React中关于state和props的知识点。在任何应用中，数据都是必不可少的。我们需要直接的改变页面上一块的区域来使得视图的刷新，或者间接地改变其他地方的数据。React的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在props和state中，这两个属性有啥子区别呢？propsReact的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件。组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是props，所以可以把props理解为从外部传入组件内部的数据。由于React是单向数据流，所以props基本上也就是从服父级组件向子组件传递的数据。用法假设我们现在需要实现一个列表，根据React组件化思想，我们可以把列表中的行当做一个组件，也就是有这样两个组件：&lt;ItemList/&gt;和&lt;Item/&gt;。先看看&lt;ItemList/&gt;123456789import Item from &quot;./item&quot;;export default class ItemList extends React.Component&#123; const itemList = data.map(item =&gt; &lt;Item item=item /&gt;); render()&#123; return ( &#123;itemList&#125; ) &#125;&#125;列表的数据我们就暂时先假设是放在一个data变量中，然后通过map函数返回一个每一项都是&lt;Item item=&#39;数据&#39;/&gt;的数组，也就是说这里其实包含了data.length个&lt;Item/&gt;组件，数据通过在组件上自定义一个参数传递。当然，这里想传递几个自定义参数都可以。在&lt;Item /&gt;中是这样的：1234567export default class Item extends React.Component&#123; render()&#123; return ( &lt;li&gt;&#123;this.props.item&#125;&lt;/li&gt; ) &#125;&#125;在render函数中可以看出，组件内部是使用this.props来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个item属性，所以通过this.props.item来获取即可。只读性props经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的props是只读的，不可改变的。如果props在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的props传入组件中。默认参数在组件中，我们最好为props中的参数设置一个defaultProps，并且制定它的类型。比如，这样：1234567Item.defaultProps = &#123; item: &apos;Hello Props&apos;,&#125;;Item.propTypes = &#123; item: PropTypes.string,&#125;;关于propTypes，可以声明为以下几种类型：1234567optionalArray: PropTypes.array,optionalBool: PropTypes.bool,optionalFunc: PropTypes.func,optionalNumber: PropTypes.number,optionalObject: PropTypes.object,optionalString: PropTypes.string,optionalSymbol: PropTypes.symbol,注意，bool和func是简写。这些知识基础数据类型，还有一些复杂的，附上链接：https://facebook.github.io/react/docs/typechecking-with-proptypes.html总结props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。statestate是什么呢？State is similar to props, but it is private and fully controlled by the component.一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是props，而数据状态就是state。用法12345678910111213export default class ItemList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; itemList:&apos;一些数据&apos;, &#125; &#125; render()&#123; return ( &#123;this.state.itemList&#125; ) &#125;&#125;首先，在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。setStatestate不同于props的一点是，state是可以被改变的。不过，不可以直接通过this.state=的方式来修改，而需要通过this.setState()方法来修改state。比如，我们经常会通过异步操作来获取数据，我们需要在didMount阶段来执行异步操作：1234567componentDidMount()&#123; fetch(&apos;url&apos;) .then(response =&gt; response.json()) .then((data) =&gt; &#123; this.setState(&#123;itemList:item&#125;); &#125;&#125;当数据获取完成后，通过this.setState来修改数据状态。当我们调用this.setState方法时，React会更新组件的数据状态state，并且重新调用render方法，也就是会对组件进行重新渲染。注意：通过this.state=来初始化state，使用this.setState来修改state，constructor是唯一能够初始化的地方。setState接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：123456789101112export default class ItemList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name:&apos;axuebin&apos;, age:25, &#125; &#125; componentDidMount()&#123; this.setState(&#123;age:18&#125;) &#125;&#125;在执行完setState之后的state应该是{name:&#39;axuebin&#39;,age:18}。setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：123this.setState(&#123; name:&apos;xb&apos;&#125;,()=&gt;console.log(&apos;setState finished&apos;))总结state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。区别state是组件自己管理数据，控制自己的状态，可变；props是外部传入的数据参数，不可变；没有state的叫做无状态组件，有state的叫做有状态组件；多用props，少用state。也就是多写无状态组件。本文作者： Andy本文地址： https://andyxw.com/archives/992.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
</search>

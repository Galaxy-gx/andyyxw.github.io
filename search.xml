<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>鸡汤</title>
      <link href="/archives/201.html"/>
      <url>/archives/201.html</url>
      <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="这是篇有密码的博客" />    <label for="pass">这是篇有密码的博客</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React 技术栈</title>
      <link href="/archives/4a9b.html"/>
      <url>/archives/4a9b.html</url>
      <content type="html"><![CDATA[<!-- build time:Fri Aug 17 2018 16:25:40 GMT+0800 (中国标准时间) --><h1 id="React-技术栈"><a href="#React-技术栈" class="headerlink" title="React 技术栈"></a>React 技术栈</h1><p>React 是目前最热门的前端框架。</p><ul><li>Facebook 公司2013年推出</li><li>现在最好的社区支持和生态圈</li><li>大量的第三方工具</li></ul><p><img src="./images/react-logo.png" alt=""></p><hr><h2 id="React-的优点"><a href="#React-的优点" class="headerlink" title="React 的优点"></a>React 的优点</h2><ul><li>组件模式：代码复用和团队分工</li><li>虚拟 DOM：性能优势</li><li>移动端支持：跨终端</li></ul><hr><h2 id="React-的缺点"><a href="#React-的缺点" class="headerlink" title="React 的缺点"></a>React 的缺点</h2><ul><li>学习曲线较陡峭</li><li>全新的一套概念，与其他所有框架截然不同</li><li>只有采用它的整个技术栈，才能发挥最大威力</li></ul><p>总结：React 非常先进和强大，但是学习和实现成本都不低</p><hr><h2 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h2><p>React 使用 JSX 语法，JavaScript 代码中可以写 HTML 代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTitle = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><hr><h2 id="JSX-语法解释"><a href="#JSX-语法解释" class="headerlink" title="JSX 语法解释"></a>JSX 语法解释</h2><p>（1）JSX 语法的最外层，只能有一个节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">let</span> myTitle = &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;;</span><br></pre></td></tr></table></figure><p>（2）JSX 语法中可以插入 JavaScript 代码，使用大括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTitle = &lt;p&gt;&#123;'Hello ' + 'World'&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="Babel-转码器"><a href="#Babel-转码器" class="headerlink" title="Babel 转码器"></a>Babel 转码器</h2><p>JavaScript 引擎（包括浏览器和 Node）都不认识 JSX，需要首先使用 Babel 转码，然后才能运行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"react.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"babel.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// ** Our code goes here! **</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React 需要加载两个库：React 和 React-DOM，前者是 React 的核心库，后者是 React 的 DOM 适配库。</p><p>Babel 用来在浏览器转换 JSX 语法，如果服务器已经转好了，浏览器就不需要加载这个库。</p><hr><h2 id="课堂练习：JSX-语法"><a href="#课堂练习：JSX-语法" class="headerlink" title="课堂练习：JSX 语法"></a>课堂练习：JSX 语法</h2><p>浏览器打开<code>demos/jsx-demo/index.html</code>，按照<a href="../demos/README.md#jsx">《操作说明》</a>，完成练习。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;span&gt;Hello World!<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h2 id="示例：React-组件"><a href="#示例：React-组件" class="headerlink" title="示例：React 组件"></a>示例：React 组件</h2><p>React 允许用户定义自己的组件，插入网页。</p><p>浏览器打开<code>demos/react-component-demo/index1.html</code>，按照<a href="../demos/README.md#react-组件语法">《操作说明》</a>，仔细查看源码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTitle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;MyTitle/&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h2 id="课堂练习：组件的参数"><a href="#课堂练习：组件的参数" class="headerlink" title="课堂练习：组件的参数"></a>课堂练习：组件的参数</h2><p>组件可以从外部传入参数，内部使用<code>this.props</code>获取参数。</p><p>打开<code>demos/react-component-demo/index2.html</code>，按照<a href="../demos/README.md#react-组件的参数">《操作说明》</a>，完成练习。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTitle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span></span></span></span><br><span class="line"><span class="xml">      style=&#123;&#123;color: this.props.color&#125;&#125;</span></span><br><span class="line"><span class="xml">    &gt;Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;MyTitle color=<span class="string">"red"</span> /&gt;,</span><br></pre></td></tr></table></figure><hr><h2 id="示例：组件的状态"><a href="#示例：组件的状态" class="headerlink" title="示例：组件的状态"></a>示例：组件的状态</h2><p>组件往往会有内部状态，使用<code>this.state</code>表示。</p><p>浏览器打开<code>demos/react-component-demo/index3.html</code>，按照<a href="../demos/README.md#react-组件的状态">《操作说明》</a>，仔细查看源码。</p><p><img src="./images/react-component-state.png" alt=""></p><hr><h2 id="课堂练习：React-组件实战"><a href="#课堂练习：React-组件实战" class="headerlink" title="课堂练习：React 组件实战"></a>课堂练习：React 组件实战</h2><p>浏览器打开<code>demos/react-component-demo/index4.html</code>，按照<a href="../demos/README.md#react-组件实战">《操作说明》</a>，完成练习。</p><hr><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>React 为组件的不同生命阶段，提供了近十个钩子方法。</p><ul><li><code>componentWillMount()</code>：组件加载前调用</li><li><code>componentDidMount()</code>：组件加载后调用</li><li><code>componentWillUpdate()</code>: 组件更新前调用</li><li><code>componentDidUpdate()</code>: 组件更新后调用</li><li><code>componentWillUnmount()</code>：组件卸载前调用</li><li><code>componentWillReceiveProps()</code>：组件接受新的参数时调用</li></ul><p>我们可以利用这些钩子，自动完成一些操作。</p><hr><h2 id="课堂练习：组件的生命周期"><a href="#课堂练习：组件的生命周期" class="headerlink" title="课堂练习：组件的生命周期"></a>课堂练习：组件的生命周期</h2><p>组件可以通过 Ajax 请求，从服务器获取数据。Ajax 请求一般在<code>componentDidMount</code>方法里面发出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">'...'</span>;</span><br><span class="line">  $.getJSON(url)</span><br><span class="line">    .done()</span><br><span class="line">    .fail();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开<code>demos/react-lifecycle-demo/index.html</code>，按照<a href="../demos/README.md#react-组件的生命周期">《操作说明》</a>，完成练习。</p><hr><h2 id="React-组件库"><a href="#React-组件库" class="headerlink" title="React 组件库"></a>React 组件库</h2><p>React 的一大优势，就是网上有很多已经写好的组件库，可以使用。</p><p>React-Bootstrap：<a href="https://react-bootstrap.github.io/" target="_blank" rel="noopener">https://react-bootstrap.github.io/</a></p><p><img src="./images/react-bootstrap.png" alt=""></p><hr><h2 id="示例：ReCharts"><a href="#示例：ReCharts" class="headerlink" title="示例：ReCharts"></a>示例：ReCharts</h2><p>ReCharts 是一个 React 图表组件库。<a href="http://recharts.org/" target="_blank" rel="noopener">http://recharts.org/</a></p><p>浏览器打开<code>demos/recharts-demo/index.html</code>，按照<a href="../demos/README.md#recharts">《操作说明》</a>，仔细查看源码，体会 JSX 语法对表达复杂组件的优势。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LineChart</span> <span class="attr">width</span>=<span class="string">&#123;1000&#125;</span> <span class="attr">height</span>=<span class="string">&#123;400&#125;</span> <span class="attr">data</span>=<span class="string">&#123;data&#125;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">XAxis</span> <span class="attr">dataKey</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">YAxis</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CartesianGrid</span> <span class="attr">stroke</span>=<span class="string">"#eee"</span> <span class="attr">strokeDasharray</span>=<span class="string">"5 5"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Line</span> <span class="attr">type</span>=<span class="string">"monotone"</span> <span class="attr">dataKey</span>=<span class="string">"uv"</span> <span class="attr">stroke</span>=<span class="string">"#8884d8"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Line</span> <span class="attr">type</span>=<span class="string">"monotone"</span> <span class="attr">dataKey</span>=<span class="string">"pv"</span> <span class="attr">stroke</span>=<span class="string">"#82ca9d"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LineChart</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="React-的核心思想"><a href="#React-的核心思想" class="headerlink" title="React 的核心思想"></a>React 的核心思想</h2><p>View 是 State 的输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view = f(state)</span><br></pre></td></tr></table></figure><p>上式中，<code>f</code>表示函数关系。只要 State 发生变化，View 也要随之变化。</p><hr><p>React 的本质是将图形界面（GUI）函数化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"michel"</span>,</span><br><span class="line">  age: <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">&#123; person &#125;</span>) =&gt;</span> &lt;h1&gt;&#123; person.name &#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App person=&#123;person&#125; /</span>&gt;, <span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure><hr><h2 id="React-没有解决的问题"><a href="#React-没有解决的问题" class="headerlink" title="React 没有解决的问题"></a>React 没有解决的问题</h2><p>React 本身只是一个 DOM 的抽象层，使用组件构建虚拟 DOM。</p><p>如果开发大应用，还需要解决两个问题。</p><ul><li>架构：大型应用程序应该如何组织代码？</li><li>通信：组件之间如何通信？</li></ul><hr><h2 id="架构问题"><a href="#架构问题" class="headerlink" title="架构问题"></a>架构问题</h2><p>React 只是视图层的解决方案，可以用于任何一种架构。</p><ul><li>MVC</li><li>MVVM</li><li>Observer</li><li>Reactive</li><li>…</li></ul><p>到底哪一种架构最合适 React ？</p><hr><h2 id="通信问题"><a href="#通信问题" class="headerlink" title="通信问题"></a>通信问题</h2><p>组件会发生三种通信。</p><ul><li>向子组件发消息</li><li>向父组件发消息</li><li>向其他组件发消息</li></ul><p>React 只提供了一种通信手段：传参。对于大应用，很不方便。</p><hr><h2 id="状态的同步"><a href="#状态的同步" class="headerlink" title="状态的同步"></a>状态的同步</h2><p>通信的本质是状态的同步。</p><p>React 同步状态的基本方法：找到通信双方最近的共同父组件，通过它的<code>state</code>，使得子组件的状态保持同步。</p><hr><h2 id="Flux-架构"><a href="#Flux-架构" class="headerlink" title="Flux 架构"></a>Flux 架构</h2><p>Facebook 提出 Flux 架构的概念，被认为是 React 应用的标准架构。</p><p><img src="./images/flow.png" alt=""></p><p>最大特点：数据单向流动。与 MVVM 的数据双向绑定，形成鲜明对比。</p><hr><h2 id="Flux-的核心思想"><a href="#Flux-的核心思想" class="headerlink" title="Flux 的核心思想"></a>Flux 的核心思想</h2><ul><li>不同组件的<code>state</code>，存放在一个外部的、公共的 Store 上面。</li><li>组件订阅 Store 的不同部分。</li><li>组件发送（dispatch）动作（action），引发 Store 的更新。</li></ul><p>Flux 只是一个概念，有30多种实现。</p><hr><h2 id="目前最流行的两个-React-架构"><a href="#目前最流行的两个-React-架构" class="headerlink" title="目前最流行的两个 React 架构"></a>目前最流行的两个 React 架构</h2><p>React 架构的最重要作用：管理 Store 与 View 之间的关系。</p><ul><li>MobX：响应式（Reactive）管理，state 是可变对象，适合中小型项目</li><li>Redux：函数式（Functional）管理，state 是不可变对象，适合大型项目</li></ul><hr><h2 id="MobX-架构"><a href="#MobX-架构" class="headerlink" title="MobX 架构"></a>MobX 架构</h2><p>MobX 的核心是观察者模式。</p><ul><li>Store 是被观察者（observable）</li><li>组件是观察者（observer）</li></ul><p>一旦<code>Store</code>有变化，会立刻被组件观察到，从而引发重新渲染。</p><hr><h2 id="MobX-的最简单例子"><a href="#MobX-的最简单例子" class="headerlink" title="MobX 的最简单例子"></a>MobX 的最简单例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;observable&#125; = mobx;</span><br><span class="line"><span class="keyword">const</span> &#123;observer&#125; = mobxReact;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = observable(&#123;<span class="attr">name</span>: <span class="string">"张三"</span>, <span class="attr">age</span>: <span class="number">31</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = observer(</span><br><span class="line">  (&#123; person &#125;) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123; person.name &#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">person</span>=<span class="string">&#123;person&#125;</span> /&gt;</span>, document.body);</span></span><br><span class="line"><span class="xml">person.name = "李四";</span></span><br></pre></td></tr></table></figure><p>代码：<code>demos/mobx-demo/browser-demo</code>目录</p><hr><h2 id="示例：MobX"><a href="#示例：MobX" class="headerlink" title="示例：MobX"></a>示例：MobX</h2><p>进入<code>demos/mobx-demo</code>目录，按照<a href="../demos/README.md#mobx">《操作说明》</a>，理解 MobX 框架。</p><hr><p>UI 层是观察者，Store 是被观察者。</p><p>Store 所有的属性，分成两大类：直接被观察的属性和自动计算出来的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  @observable name = <span class="string">'Bartek'</span>;</span><br><span class="line">  @computed get decorated() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is awesome!`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UI 会观察到 Store 的变化，自动重新渲染。</p><hr><h2 id="Redux-架构"><a href="#Redux-架构" class="headerlink" title="Redux 架构"></a>Redux 架构</h2><p>Redux 的核心概念</p><ul><li>所有的状态存放在<code>Store</code>。组件每次重新渲染，都必须由状态变化引起。</li><li>用户在 UI 上发出<code>action</code>。</li><li><code>reducer</code>函数接收<code>action</code>，然后根据当前的<code>state</code>，计算出新的<code>state</code>。</li></ul><p><img src="./images/redux-architecture.png" alt=""></p><hr><h2 id="Redux-应用的架构"><a href="#Redux-应用的架构" class="headerlink" title="Redux 应用的架构"></a>Redux 应用的架构</h2><p><img src="./images/architecture-redux.png" alt=""></p><p>Redux 层保存所有状态，React 组件拿到状态以后，渲染出 HTML 代码。</p><hr><h2 id="示例：Redux"><a href="#示例：Redux" class="headerlink" title="示例：Redux"></a>示例：Redux</h2><p>进入<code>demos/redux-demo</code>目录，按照<a href="../demos/README.md#redux">《操作说明》</a>，理解 Redux 框架。</p><hr><ul><li>Redux 将组件分成 UI 组件和容器组件两类。</li><li>UI 组件是纯组件，不包含 state 和生命周期方法，不涉及组件的行为，只涉及组件的外观。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">"index"</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;<span class="keyword">this</span>.props.text&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input</span></span><br><span class="line"><span class="regexp">    defaultValue=&#123;this.props.name&#125;</span></span><br><span class="line"><span class="regexp">    onChange=&#123;this.props.onChange&#125;</span></span><br><span class="line"><span class="regexp">  /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><hr><p>容器组件正好相反。</p><ul><li>不涉及组件的外观，只涉及组件的行为。</li><li>负责订阅 Store，将 Store 的数据处理以后，再通过参数传给 UI 组件。</li><li>用户给出配置以后，由 Redux 生成。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// MyComponent 是纯的 UI 组件</span><br><span class="line">const App = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(MyComponent);</span><br></pre></td></tr></table></figure><ul><li>mapStateToProps: 定义 UI 组件参数与 State 之间的映射</li><li>mapDispatchToProps：定义 UI 组件与 Action 之间的映射</li></ul><hr><h2 id="拆分-UI-组件和容器组件的好处"><a href="#拆分-UI-组件和容器组件的好处" class="headerlink" title="拆分 UI 组件和容器组件的好处"></a>拆分 UI 组件和容器组件的好处</h2><ul><li>UI 组件与后台数据无关，可以由设计师负责</li><li>容器组件只负责数据和行为，一旦 Store 的数据结构变化，只要调整容器组件即可</li><li>表现层和功能层脱钩，有利于代码重用，也有利于看清应用的数据结构和业务逻辑</li></ul><hr><h2 id="Reducer-函数"><a href="#Reducer-函数" class="headerlink" title="Reducer 函数"></a>Reducer 函数</h2><p><code>reducer</code>是一个纯函数，用来接收<code>action</code>，算出新的<code>state</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  text: <span class="string">'你好，访问者'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  name: <span class="string">'访问者'</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'change'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        name: action.payload,</span><br><span class="line">        text: <span class="string">'你好，'</span> + action.payload</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><code>Store</code>由 Redux 提供的<code>createStore</code>方法生成，该方法接受<code>reducer</code>作为参数。</li><li>为了把<code>Store</code>传入组件，必须使用 Redux 提供的<code>Provider</code>组件在应用的最外面，包裹一层。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.body.appendChild(document.createElement('div'))</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React 设计思想</title>
      <link href="/archives/7615.html"/>
      <url>/archives/7615.html</url>
      <content type="html"><![CDATA[<!-- build time:Fri Aug 17 2018 16:25:40 GMT+0800 (中国标准时间) --><h1 id="React-设计思想"><a href="#React-设计思想" class="headerlink" title="React 设计思想"></a>React 设计思想</h1><blockquote><p>译者序：本文是 React 核心开发者、有 React API 终结者之称的 Sebastian Markbåge 撰写，阐述了他设计 React 的初衷。阅读此文，你能站在更高的高度思考 React 的过去、现在和未来。原文地址：<a href="https://github.com/reactjs/react-basic" target="_blank" rel="noopener">https://github.com/reactjs/react-basic</a></p></blockquote><a id="more"></a><p>我写此文是想正式地阐述我心中 React 的<a href="http://baike.baidu.com/view/2333986.htm" target="_blank" rel="noopener">心智模型</a>。目的是解释为什么我们会这样设计 React，同时你也可以根据这些论点反推出 React。</p><p>不可否认，此文中的部分论据或前提尚存争议，而且部分示例的设计可能存在 bug 或疏忽。这只是正式确定它的最初阶段。如果你有更好的完善它的想法可以随时提交 pull request。本文不会介绍框架细节中的奇技淫巧，相信这样能提纲挈领，让你看清 React 由简单到复杂的设计过程。</p><p>React.js 的真实实现中充满了具体问题的解决方案，渐进式的解法，算法优化，历史遗留代码，debug 工具以及其他一些可以让它真的具有高可用性的内容。这些代码可能并不稳定，因为未来浏览器的变化和功能权重的变化随时面临改变。所以具体的代码很难彻底解释清楚。</p><p>我偏向于选择一种我能完全 hold 住的简洁的心智模型来作介绍。</p><h2 id="变换（Transformation）"><a href="#变换（Transformation）" class="headerlink" title="变换（Transformation）"></a>变换（Transformation）</h2><p>设计 React 的核心前提是认为 UI 只是把数据通过映射关系变换成另一种形式的数据。同样的输入必会有同样的输出。这恰好就是纯函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NameBox</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">fontWeight</span>: <span class="string">'bold'</span>, <span class="attr">labelContent</span>: name &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;Sebastian Markbåge&apos; -&gt;</span><br><span class="line">&#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125;;</span><br></pre></td></tr></table></figure><h2 id="抽象（Abstraction）"><a href="#抽象（Abstraction）" class="headerlink" title="抽象（Abstraction）"></a>抽象（Abstraction）</h2><p>你不可能仅用一个函数就能实现复杂的 UI。重要的是，你需要把 UI 抽象成多个隐藏内部细节，又可复用的函数。通过在一个函数中调用另一个函数来实现复杂的 UI，这就是抽象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyUserBox</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    borderStyle: <span class="string">'1px solid blue'</span>,</span><br><span class="line">    childContent: [</span><br><span class="line">      <span class="string">'Name: '</span>,</span><br><span class="line">      NameBox(user.firstName + <span class="string">' '</span> + user.lastName)</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; firstName: &apos;Sebastian&apos;, lastName: &apos;Markbåge&apos; &#125; -&gt;</span><br><span class="line">&#123;</span><br><span class="line">  borderStyle: &apos;1px solid blue&apos;,</span><br><span class="line">  childContent: [</span><br><span class="line">    &apos;Name: &apos;,</span><br><span class="line">    &#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h2><p>为了真正达到重用的特性，只重用叶子然后每次都为他们创建一个新的容器是不够的。你还需要可以包含其他抽象的容器再次进行组合。我理解的“组合”就是将两个或者多个不同的抽象合并为一个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBox</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    borderStyle: <span class="string">'1px solid blue'</span>,</span><br><span class="line">    children: children</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserBox</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox([</span><br><span class="line">    <span class="string">'Name: '</span>,</span><br><span class="line">    NameBox(user.firstName + <span class="string">' '</span> + user.lastName)</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h2><p>UI 不单单是对服务器端或业务逻辑状态的复制。实际上还有很多状态是针对具体的渲染目标。举个例子，在一个 text field 中打字。它不一定要复制到其他页面或者你的手机设备。滚动位置这个状态是一个典型的你几乎不会复制到多个渲染目标的。</p><p>我们倾向于使用不可变的数据模型。我们把可以改变 state 的函数串联起来作为原点放置在顶层。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyNameBox</span>(<span class="params">user, likes, onClick</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox([</span><br><span class="line">    <span class="string">'Name: '</span>, NameBox(user.firstName + <span class="string">' '</span> + user.lastName),</span><br><span class="line">    <span class="string">'Likes: '</span>, LikeBox(likes),</span><br><span class="line">    LikeButton(onClick)</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现细节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> likes = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOneMoreLike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  likes++;</span><br><span class="line">  rerender();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">FancyNameBox(</span><br><span class="line">  &#123; <span class="attr">firstName</span>: <span class="string">'Sebastian'</span>, <span class="attr">lastName</span>: <span class="string">'Markbåge'</span> &#125;,</span><br><span class="line">  likes,</span><br><span class="line">  addOneMoreLike</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><em>注意：本例更新状态时会带来副作用（addOneMoreLike 函数中）。我实际的想法是当一个“update”传入时我们返回下一个版本的状态，但那样会比较复杂。此示例待更新</em></p><h2 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a>Memoization</h2><p>对于纯函数，使用相同的参数一次次调用未免太浪费资源。我们可以创建一个函数的 memorized 版本，用来追踪最后一个参数和结果。这样如果我们继续使用同样的值，就不需要反复执行它了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cachedArg;</span><br><span class="line">  <span class="keyword">var</span> cachedResult;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cachedArg === arg) &#123;</span><br><span class="line">      <span class="keyword">return</span> cachedResult;</span><br><span class="line">    &#125;</span><br><span class="line">    cachedArg = arg;</span><br><span class="line">    cachedResult = fn(arg);</span><br><span class="line">    <span class="keyword">return</span> cachedResult;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> MemoizedNameBox = memoize(NameBox);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NameAndAgeBox</span>(<span class="params">user, currentTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox([</span><br><span class="line">    <span class="string">'Name: '</span>,</span><br><span class="line">    MemoizedNameBox(user.firstName + <span class="string">' '</span> + user.lastName),</span><br><span class="line">    <span class="string">'Age in milliseconds: '</span>,</span><br><span class="line">    currentTime - user.dateOfBirth</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="列表（Lists）"><a href="#列表（Lists）" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h2><p>大部分 UI 都是展示列表数据中不同 item 的列表结构。这是一个天然的层级。</p><p>为了管理列表中的每一个 item 的 state ，我们可以创造一个 Map 容纳具体 item 的 state。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserList</span>(<span class="params">users, likesPerUser, updateUserLikes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> users.map(<span class="function"><span class="params">user</span> =&gt;</span> FancyNameBox(</span><br><span class="line">    user,</span><br><span class="line">    likesPerUser.get(user.id),</span><br><span class="line">    () =&gt; updateUserLikes(user.id, likesPerUser.get(user.id) + <span class="number">1</span>)</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> likesPerUser = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateUserLikes</span>(<span class="params">id, likeCount</span>) </span>&#123;</span><br><span class="line">  likesPerUser.set(id, likeCount);</span><br><span class="line">  rerender();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserList(data.users, likesPerUser, updateUserLikes);</span><br></pre></td></tr></table></figure><p><em>注意：现在我们向 FancyNameBox 传了多个不同的参数。这打破了我们的 memoization 因为我们每次只能存储一个值。更多相关内容在下面。</em></p><h2 id="连续性（Continuations）"><a href="#连续性（Continuations）" class="headerlink" title="连续性（Continuations）"></a>连续性（Continuations）</h2><p>不幸的是，自从 UI 中有太多的列表，明确的管理就需要大量的重复性样板代码。</p><p>我们可以通过推迟一些函数的执行，进而把一些模板移出业务逻辑。比如，使用“柯里化”（JavaScript 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener"><code>bind</code></a>）。然后我们可以从核心的函数外面传递 state，这样就没有样板代码了。</p><p>下面这样并没有减少样板代码，但至少把它从关键业务逻辑中剥离。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyUserList</span>(<span class="params">users</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox(</span><br><span class="line">    UserList.bind(<span class="literal">null</span>, users)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> box = FancyUserList(data.users);</span><br><span class="line"><span class="keyword">const</span> resolvedChildren = box.children(likesPerUser, updateUserLikes);</span><br><span class="line"><span class="keyword">const</span> resolvedBox = &#123;</span><br><span class="line">  ...box,</span><br><span class="line">  children: resolvedChildren</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="State-Map"><a href="#State-Map" class="headerlink" title="State Map"></a>State Map</h2><p>之前我们知道可以使用组合避免重复执行相同的东西这样一种重复模式。我们可以把执行和传递 state 逻辑挪动到被复用很多的低层级的函数中去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBoxWithState</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  stateMap,</span></span></span><br><span class="line"><span class="function"><span class="params">  updateState</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox(</span><br><span class="line">    children.map(<span class="function"><span class="params">child</span> =&gt;</span> child.continuation(</span><br><span class="line">      stateMap.get(child.key),</span><br><span class="line">      updateState</span><br><span class="line">    ))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserList</span>(<span class="params">users</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> users.map(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">    continuation: FancyNameBox.bind(<span class="literal">null</span>, user),</span><br><span class="line">    key: user.id</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyUserList</span>(<span class="params">users</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBoxWithState.bind(<span class="literal">null</span>,</span><br><span class="line">    UserList(users)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> continuation = FancyUserList(data.users);</span><br><span class="line">continuation(likesPerUser, updateUserLikes);</span><br></pre></td></tr></table></figure><h2 id="Memoization-Map"><a href="#Memoization-Map" class="headerlink" title="Memoization Map"></a>Memoization Map</h2><p>一旦我们想在一个 memoization 列表中 memoize 多个 item 就会变得很困难。因为你需要制定复杂的缓存算法来平衡调用频率和内存占有率。</p><p>还好 UI 在同一个位置会相对的稳定。相同的位置一般每次都会接受相同的参数。这样以来，使用一个集合来做 memoization 是一个非常好用的策略。</p><p>我们可以用对待 state 同样的方式，在组合的函数中传递一个 memoization 缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg, memoizationCache</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memoizationCache.arg === arg) &#123;</span><br><span class="line">      <span class="keyword">return</span> memoizationCache.result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = fn(arg);</span><br><span class="line">    memoizationCache.arg = arg;</span><br><span class="line">    memoizationCache.result = result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBoxWithState</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  stateMap,</span></span></span><br><span class="line"><span class="function"><span class="params">  updateState,</span></span></span><br><span class="line"><span class="function"><span class="params">  memoizationCache</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox(</span><br><span class="line">    children.map(<span class="function"><span class="params">child</span> =&gt;</span> child.continuation(</span><br><span class="line">      stateMap.get(child.key),</span><br><span class="line">      updateState,</span><br><span class="line">      memoizationCache.get(child.key)</span><br><span class="line">    ))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MemoizedFancyNameBox = memoize(FancyNameBox);</span><br></pre></td></tr></table></figure><h2 id="代数效应（Algebraic-Effects）"><a href="#代数效应（Algebraic-Effects）" class="headerlink" title="代数效应（Algebraic Effects）"></a>代数效应（Algebraic Effects）</h2><p>多层抽象需要共享琐碎数据时，一层层传递数据非常麻烦。如果能有一种方式可以在多层抽象中快捷地传递数据，同时又不需要牵涉到中间层级，那该有多好。React 中我们把它叫做“context”。</p><p>有时候数据依赖并不是严格按照抽象树自上而下进行。举个例子，在布局算法中，你需要在实现他们的位置之前了解子节点的大小。</p><p>现在，这个例子有一点超纲。我会使用 <a href="http://math.andrej.com/eff/" target="_blank" rel="noopener">代数效应</a> 这个由我发起的 <a href="https://esdiscuss.org/topic/one-shot-delimited-continuations-with-effect-handlers" target="_blank" rel="noopener">ECMAScript 新特性提议</a>。如果你对函数式编程很熟悉，它们 在避免由 monad 强制引入的仪式一样的编码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeBorderColorRequest</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBox</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> color = raise <span class="keyword">new</span> ThemeBorderColorRequest();</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    borderWidth: <span class="string">'1px'</span>,</span><br><span class="line">    borderColor: color,</span><br><span class="line">    children: children</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlueTheme</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">    children();</span><br><span class="line">  &#125; <span class="keyword">catch</span> effect ThemeBorderColorRequest -&gt; [, continuation] &#123;</span><br><span class="line">    continuation(<span class="string">'blue'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BlueTheme(</span><br><span class="line">    FancyUserList.bind(<span class="literal">null</span>, data.users)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React中的state和props</title>
      <link href="/archives/992.html"/>
      <url>/archives/992.html</url>
      <content type="html"><![CDATA[<!-- build time:Fri Aug 17 2018 16:25:40 GMT+0800 (中国标准时间) --><p>整理一下React中关于state和props的知识点。</p><hr><p>在任何应用中，数据都是必不可少的。我们需要直接的改变页面上一块的区域来使得视图的刷新，或者间接地改变其他地方的数据。React的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在<code>props</code>和<code>state</code>中，这两个属性有啥子区别呢？</p><a id="more"></a><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>React的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件。</p><p>组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是<code>props</code>，所以可以把<code>props</code>理解为从外部传入组件内部的数据。由于React是单向数据流，所以<code>props</code>基本上也就是从服父级组件向子组件传递的数据。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>假设我们现在需要实现一个列表，根据React组件化思想，我们可以把列表中的行当做一个组件，也就是有这样两个组件：<code>&lt;ItemList/&gt;</code>和<code>&lt;Item/&gt;</code>。</p><p>先看看<code>&lt;ItemList/&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Item from &quot;./item&quot;;</span><br><span class="line">export default class ItemList extends React.Component&#123;</span><br><span class="line">  const itemList = data.map(item =&gt; &lt;Item item=item /&gt;);</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &#123;itemList&#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>列表的数据我们就暂时先假设是放在一个<code>data</code>变量中，然后通过<code>map</code>函数返回一个每一项都是<code>&lt;Item item=&#39;数据&#39;/&gt;</code>的数组，也就是说这里其实包含了<code>data.length</code>个<code>&lt;Item/&gt;</code>组件，数据通过在组件上自定义一个参数传递。当然，这里想传递几个自定义参数都可以。</p><p>在<code>&lt;Item /&gt;</code>中是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default class Item extends React.Component&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;li&gt;&#123;this.props.item&#125;&lt;/li&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>render</code>函数中可以看出，组件内部是使用<code>this.props</code>来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个<code>item</code>属性，所以通过<code>this.props.item</code>来获取即可。</p><h3 id="只读性"><a href="#只读性" class="headerlink" title="只读性"></a>只读性</h3><p><code>props</code>经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的<code>props</code>是只读的，不可改变的。如果<code>props</code>在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的<code>props</code>传入组件中。</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>在组件中，我们最好为<code>props</code>中的参数设置一个<code>defaultProps</code>，并且制定它的类型。比如，这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Item.defaultProps = &#123;</span><br><span class="line">  item: &apos;Hello Props&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Item.propTypes = &#123;</span><br><span class="line">  item: PropTypes.string,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于<code>propTypes</code>，可以声明为以下几种类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">optionalArray: PropTypes.array,</span><br><span class="line">optionalBool: PropTypes.bool,</span><br><span class="line">optionalFunc: PropTypes.func,</span><br><span class="line">optionalNumber: PropTypes.number,</span><br><span class="line">optionalObject: PropTypes.object,</span><br><span class="line">optionalString: PropTypes.string,</span><br><span class="line">optionalSymbol: PropTypes.symbol,</span><br></pre></td></tr></table></figure><p>注意，<code>bool</code>和<code>func</code>是简写。</p><p>这些知识基础数据类型，还有一些复杂的，附上链接：</p><p><a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">https://facebook.github.io/react/docs/typechecking-with-proptypes.html</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>props</code>是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的<code>props</code>来重新渲染子组件，否则子组件的<code>props</code>以及展现形式不会改变。</p><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p><code>state</code>是什么呢？</p><blockquote><p>State is similar to props, but it is private and fully controlled by the component.</p></blockquote><p>一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是<code>props</code>，而数据状态就是<code>state</code>。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default class ItemList extends React.Component&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      itemList:&apos;一些数据&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &#123;this.state.itemList&#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，在组件初始化的时候，通过<code>this.state</code>给组件设定一个初始的<code>state</code>，在第一次<code>render</code>的时候就会用这个数据来渲染组件。</p><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p><code>state</code>不同于<code>props</code>的一点是，<code>state</code>是可以被改变的。不过，不可以直接通过<code>this.state=</code>的方式来修改，而需要通过<code>this.setState()</code>方法来修改<code>state</code>。</p><p>比如，我们经常会通过异步操作来获取数据，我们需要在<code>didMount</code>阶段来执行异步操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">  fetch(&apos;url&apos;)</span><br><span class="line">    .then(response =&gt; response.json())</span><br><span class="line">    .then((data) =&gt; &#123;</span><br><span class="line">      this.setState(&#123;itemList:item&#125;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数据获取完成后，通过<code>this.setState</code>来修改数据状态。</p><p>当我们调用<code>this.setState</code>方法时，React会更新组件的数据状态<code>state</code>，并且重新调用<code>render</code>方法，也就是会对组件进行重新渲染。</p><p><strong>注意：通过<code>this.state=</code>来初始化<code>state</code>，使用<code>this.setState</code>来修改<code>state</code>，<code>constructor</code>是唯一能够初始化的地方。</strong></p><p><code>setState</code>接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default class ItemList extends React.Component&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      name:&apos;axuebin&apos;,</span><br><span class="line">      age:25,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    this.setState(&#123;age:18&#125;)  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行完<code>setState</code>之后的<code>state</code>应该是<code>{name:&#39;axuebin&#39;,age:18}</code>。</p><p><code>setState</code>还可以接受第二个参数，它是一个函数，会在<code>setState</code>调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">  name:&apos;xb&apos;</span><br><span class="line">&#125;,()=&gt;console.log(&apos;setState finished&apos;))</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>state</code>的主要作用是用于组件保存、控制以及修改自己的状态，它只能在<code>constructor</code>中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的<code>this.setState</code>来修改，修改<code>state</code>属性会导致组件的重新渲染。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li><code>state</code>是组件自己管理数据，控制自己的状态，可变；</li><li><code>props</code>是外部传入的数据参数，不可变；</li><li>没有<code>state</code>的叫做无状态组件，有<code>state</code>的叫做有状态组件；</li><li>多用<code>props</code>，少用<code>state</code>。也就是多写无状态组件。</li></ol><!-- rebuild by neat -->]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>

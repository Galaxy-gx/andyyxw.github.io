<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[What are React Hooks]]></title>
    <url>%2Farchives%2Fef81.html</url>
    <content type="text"><![CDATA[本文由 简悦 SimpRead 转码， 原文地址 https://www.robinwieruch.de/react-hooks/October 29, 2018 - Edit this Post on GitHubReact Hooks were introduced at React Conf October 2018 as a way to use state and side-effects in React function components. Whereas function components have been called functional stateless components (FSC) before, they are finally able to use state with React Hooks. Therefore, many people refer to them as function components now.In this walkthrough, I want to explain the motivation behind hooks, what will change in React and why we shouldn’t panic, and how React hooks can be used in function components by showcasing common React Hooks such as the state and effect hooks by example.React Hooks were invented by the React team to introduce state management and side-effects in function components. It’s their way of making it more effortless to use only React function components without the need to refactor a React function component to a React class component for using lifecycle methods, in order to use have side-effects, or local state. React Hooks enable us to write React applications with only function components.Unnecessary Component Refactorings: Previously, only React class components were used for local state management and lifecycle methods. The latter have been essential for introducing side-effects, such as listeners or data fetching, in React class components.12345678910111213141516171819202122232425262728import React from &apos;react&apos;;class Counter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0, &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; &gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default Counter;Only if you didn’t need state or lifecycle methods, React functional stateless components could be used. And because React function components are more lightweight (and elegant), people already used plenty of function components. This came with the drawback of refactoring components from React function components to React class components every time state or lifecycle methods were needed (and vice versa).1234567891011121314151617import React, &#123; useState &#125; from &apos;react&apos;;// how to use the state hook in a React function componentfunction Counter() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;export default Counter;With Hooks there is no need for this refactoring. Side-effects and state are finally available in React function components. That’s why a rebranding from functional stateless components to function components would be reasonable.Side-effect Logic: In React class components, side-effects were mostly introduced in lifecycle methods (e.g. componentDidMount, componentDidUpdate, componentWillUnmount). A side-effect could be fetching data in React or interacting with the Browser API. Usually these side-effects came with a setup and clean up phase. For instance, if you would miss to remove your listener, you could run into React performance issues.12345678910111213141516171819202122232425262728293031// side-effects in a React class componentclass MyComponent extends Component &#123; // setup phase componentDidMount() &#123; // add listener for feature 1 // add listener for feature 2 &#125; // clean up phase componentWillUnmount() &#123; // remove listener for feature 1 // remove listener for feature 2 &#125; ...&#125;// side-effects in React function component with React Hooksfunction MyComponent() &#123; useEffect(() =&gt; &#123; // add listener for feature 1 (setup) // return function to remove listener for feature 1 (clean up) &#125;); useEffect(() =&gt; &#123; // add listener for feature 2 (setup) // return function to remove listener for feature 2 (clean up) &#125;); ...&#125;Now, if you would introduce more than one of these side-effects in a React class component’s lifecycle methods, all side-effects would be grouped by lifecycle method but not by side-effect. That’s what React Hooks are going to change by encapsulating a side-effect in one hook whereas every hook has its own side-effect with a setup and clean up phase. You will see later in a tutorial how this works for real by adding and removing listeners in a React Hook.React’s Abstraction Hell: Abstraction and thus reusability were introduced with Higher-Order Components and Render Prop Components in React. There is also React’s Context with its Provider and Consumer Components that introduce another level of abstraction. All of these advanced patterns in React are using so called wrapping components. The implementation of the following components shouldn’t be foreign to developers who are creating larger React applications.12345678910111213141516171819import &#123; compose &#125; from &apos;recompose&apos;;import &#123; withRouter &#125; from &apos;react-router-dom&apos;;function App(&#123; history, state, dispatch &#125;) &#123; return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;Content theme=&#123;theme&#125;&gt; ... &lt;/Content&gt; &#125; &lt;/ThemeContext.Consumer&gt; );&#125;export default compose( withRouter, withReducer(reducer, initialState))(App);Sophie Alpert coined it “the wrapper hell” in React. You are not only seeing it in the implementation, but also when inspecting your components in the browser. There are dozens of wrapped components due to Render Prop Components (including Consumer components from React’s Context) and Higher-Order Components. It becomes an unreadable component tree, because all the abstracted logic is covered up in other React components. The actual visible components are hard to track down in the browser’s DOM. So what if these additional components were not needed because the logic is only encapsulated in functions as side-effects instead? Then you would remove all these wrapping components and flatten your component tree’s structure:12345678910111213function App() &#123; const theme = useTheme(); const history = useRouter(); const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;Content theme=&#123;theme&#125;&gt; ... &lt;/Content&gt; );&#125;export default App;That’s what React Hooks are bringing on the table. All side-effects are sitting directly in the component without introducing other components as container for business logic. The container disappears and the logic just sits in React Hooks that are only functions. Andrew Clark already left a statement in favor of React Hooks in his popular Higher-Order Component library called recompose.JavaScript Class Confusion: JavaScript mixes two worlds pretty well: Object-oriented programming (OOP) and functional programming. React introduces many developers to both worlds. On the one side, React (and Redux) introduced people to functional programming (FP) with function compositions, general programming concepts with functions (e.g. higher-order functions, JavaScript built-in methods like map, reduce, filter) and other terms such as immutability and side-effects. React itself didn’t really introduce these things, because they are features of the language or the programming paradigm itself, but they are heavily used in React whereas every React developer becomes automatically a better JavaScript developer.On the other side, React uses JavaScript classes as one way to define React components. A class is only the declaration whereas the actual usage of the component is the instantiation of it. It creates a class instance whereas the this object of the class instance is used to interact with class methods (e.g. setState, forceUpdate, other custom class methods). However, classes come with a steeper learning curve for React beginners who are not coming from an OOP background. That’s why class bindings, the this object and inheritance can be confusing. I have a few chapters in my React book focusing only on this aspect of React which is always the most confusing thing about React for beginners.123456789101112131415161718192021222324252627282930313233343536373839404142// I THOUGHT WE ARE USING A CLASS. WHY IS IT EXTENDING FROM SOMETHING?class Counter extends Component &#123; // WAIT ... THIS WORKS??? state = &#123; value: 0 &#125;; // I THOUGH IT&apos;S THIS WAY, BUT WHY DO I NEED PROPS HERE? // constructor(props) &#123; // SUPER??? // super(props); // // this.state = &#123; // value: 0, // &#125;; // &#125; // WHY DO I HAVE TO USE AN ARROW FUNCTION??? onIncrement = () =&gt; &#123; this.setState(state =&gt; (&#123; value: state.value + 1 &#125;)); &#125;; // SHOULDN&apos;T IT BE this.onDecrement = this.onDecrement.bind(this); in the constructor??? // WHAT&apos;S this.onDecrement = this.onDecrement.bind(this); DOING ANYWAY? onDecrement = () =&gt; &#123; this.setState(state =&gt; (&#123; value: state.value - 1 &#125;)); &#125;; render() &#123; return ( &lt;div&gt; &#123;this.state.value&#125; &#123;/* WHY IS EVERYTHING AVAILABLE ON &quot;THIS&quot;??? */&#125; &lt;button onClick=&#123;this.onIncrement&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;this.onDecrement&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;Now, many people argue React shouldn’t take JavaScript classes away because people don’t understand them. After all, they belong to the language. However, one of the hypotheses of introducing the Hooks API is a smoother learning curve for React beginners when writing their React components without JavaScript classes in the first place.Every time a new feature is introduced, people are concerned about it. There is one side of the group that is ecstatic about the change, and the other side that fears the change. I heard the most common concerns for React Hooks are:Everything changes! Subtle panic mode …React is becoming bloated like Angular!It’s useless, classes worked fine.It’s magic!Let me address these concerns here:Everything changes: React Hooks will change how we write React applications in the future. However, at the moment, nothing changes. You can still write class components with local state and lifecycle methods and deploy advanced patterns such as Higher-Order Components or Render Prop Components. Nobody takes these learnings away from you. See how I upgraded all my open source projects from older versions to React 16.6. and none of of these projects had problems. They are using HOCs, Render Props and I believe even the old context API (correct me if am wrong). Everything I have learned all these years still works. The React team makes sure that React stays backward compatible. It will be the same with React 16.7.React is becoming bloated like Angular: React was always seen as a library with a slim API. That’s true and shall be true in the future. However, in order to adjust things that were the status quo of building component-based applications a few years ago, and not to be overtaken by other libraries who adapt to the new status quo, React introduces changes in favor of older APIs. If React would start out fresh this year, maybe there would be only function components and hooks. But React was released a couple of years ago and needs to adapt to keep up with the status quo or to invent a status quo. Maybe there will follow deprecations of React class components and lifecycle methods in a few years in favor of React function components and hooks, but at the moment, the React team keeps React class components in their repertoire of tools. After all, the React team utilizes hooks as an invention to run a marathon with React an not to win a sprint. Obviously, React Hooks add yet another API to React, but it is in favor to simplify React’s API in the future. I like this transition more than having a React 2 where everything is different.It’s useless, classes worked fine: Imagine you would start from zero to learn React and you would be introduced to React with Hooks. Maybe create-react-app wouldn’t start out with a React class component but with a React function component. Everything you need to learn for your components would be React Hooks. They manage state and side-effects, so you would only need to know about the state and the effect hook. It’s everything a React class component did for you before. It will be simpler for React beginners to learn React without all the other overhead that comes with JavaScript classes (inheritance, this, bindings, super, …). Imagine React Hooks as a new way of how to write React components - It’s a new mindset. I am a skeptical person myself, but once I wrote a couple of simpler scenarios with React Hooks, I was convinced that this is the simplest way to write but also to learn React. As someone who is doing lots of React workshops, I argue that it takes away all the frustration classes bring on the table for React beginners.It’s magic: React is known to be down to earth with JavaScript. Writing React applications makes you a better JavaScript developer - that’s one of the best things about React when someone asks me: “Why should I learn React?”. Whether there comes another library in the future or not, everyone is prepared by honing their JavaScript skills and general programming skills when using React. It’s one of the things that made Redux, often used in React, popular: There is no magic, it is plain JavaScript. Now these React Hooks come along the way, introduce something stateful in a previously often pure function component, a couple of not easily to accept rules, and many don’t understand what’s going on under the hood. But think about it this way: A function component in React is not a mere function. You still have to import React as library to your source code file. It does something with your function, because the function becomes a function component in React land. This function component comes with hidden implementations that were there all the time. How else would it have been possible to use functions as function components as we did it before React Hooks were introduced? And people accepted it too, even though it’s kinda magic. Now, the only thing changed (and maybe it has already been this way before) is that these function components come with an extra hidden object that keeps track of hooks. To quote Dan Abramov from his article about hooks: “Perhaps you’re wondering where React keeps the state for Hooks. The answer is it’s kept in the exact same place where React keeps state for classes. React has an internal update queue which is the source of truth for any state, no matter how you define your components.”.Finally, think about it this way: Component-based solutions such as Angular, Vue, and React are pushing the boundaries of web development with every release. They build up on top of technologies that were invented more than two decades ago. They adapt them to make web development effortless in 2018 and not 1998. They optimize them like crazy to meet the needs in the here and now. We are building web applications with components and not with HTML templates anymore. We are not there yet, but I imagine a future where we sit together and invent a component-based standard for the browser. Angular, Vue and React are only the spearhead of this movement.In the following, I want to dive into a few popular React Hooks by example to get you up to speed. All examples can be found in this GitHub repository.You have seen the useState Hook before in a code snippet for a typical counter example. It is used to manage local state in function components. Let’s use the hook in a more elaborate example where we are going to manage an array of items. In another article of mine, you can learn more about managing arrays as state in React, but this time we are doing it with React hooks. Let’s get started:12345678910111213141516171819202122232425262728293031import React, &#123; useState &#125; from &apos;react&apos;;const INITIAL_LIST = [ &#123; id: &apos;0&apos;, title: &apos;React with RxJS for State Management Tutorial&apos;, url: &apos;https://www.robinwieruch.de/react-rxjs-state-management-tutorial/&apos;, &#125;, &#123; id: &apos;1&apos;, title: &apos;A complete React with Apollo and GraphQL Tutorial&apos;, url: &apos;https://www.robinwieruch.de/react-graphql-apollo-tutorial&apos;, &#125;,];function App() &#123; const [list, setList] = useState(INITIAL_LIST); return ( &lt;ul&gt; &#123;list.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;export default App;The useState hook accepts an initial state as argument and returns, by using array destructuring, two variables that can be named however you want to name them. Whereas the first variable is the actual state, the second variable is a function to update the state by providing a new state.The goal of this scenario is to remove an item from the list. In order to accomplish it, every item in the rendered list has a button with a click handler. The click handler can be inlined in the function component, because it will make use of list and setList later. Hence you don’t need to pass these variables to the handler, because they are already available from the outer scope of the component.123456789101112131415161718192021function App() &#123; const [list, setList] = useState(INITIAL_LIST); function onRemoveItem() &#123; // remove item from &quot;list&quot; // set the new list in state with &quot;setList&quot; &#125; return ( &lt;ul&gt; &#123;list.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;button type=&quot;button&quot; onClick=&#123;onRemoveItem&#125;&gt; Remove &lt;/button&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;Somehow we need to know about the item that should be removed from the list. Using a higher-order function, we can pass the identifier of the item to the handler function. Otherwise we wouldn’t be able to identify the item that should be removed from the list.123456789101112131415161718192021function App() &#123; const [list, setList] = useState(INITIAL_LIST); function onRemoveItem(id) &#123; // remove item from &quot;list&quot; // set the new list in state with &quot;setList&quot; &#125; return ( &lt;ul&gt; &#123;list.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; onRemoveItem(item.id)&#125;&gt; Remove &lt;/button&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;Finally, use the identifier to filter the list with a built-in array method. It returns a new list which is used to set the new state of the list.123456789101112131415161718192021function App() &#123; const [list, setList] = useState(INITIAL_LIST); function onRemoveItem(id) &#123; const newList = list.filter(item =&gt; item.id !== id); setList(newList); &#125; return ( &lt;ul&gt; &#123;list.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; onRemoveItem(item.id)&#125;&gt; Remove &lt;/button&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;That should do the job. You are able to remove an item from the list based on the identifier you pass to the handler. The handler then filters the list and sets the new state of the list with the setList function.The useState hook gives you everything you need to manage state in a function component: initial state, the latest state, and a state update function. Everything else is JavaScript again. Furthermore, you don’t need to bother about the state object with its shallow merge as before in a class component. Instead, you encapsulate one domain (e.g. list) with useState, but if you would need another state (e.g. counter), then just encapsulate this domain with another useState. You can read more about the useState hook in React’s documentation.Let’s head over to the next hook called useEffect. As mentioned before, function components should be able to manage state and side-effects with hooks. Managing state was showcased with the useState hook. Now comes the useEffect hook into play for side-effects which are usually used for interactions with the Browser/DOM API or external API like data fetching. Let’s see how the useEffect hook can be used for interaction with the Browser API by implementing a simple stopwatch. You can see how it is done in a React class component in this GitHub repository.1234567891011121314151617181920212223import React, &#123; useState &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); return ( &lt;div&gt; &#123;!isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt; Start &lt;/button&gt; )&#125; &#123;isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt; Stop &lt;/button&gt; )&#125; &lt;/div&gt; );&#125;export default App;There is no stopwatch yet. But at least there are is a conditional rendering to show either a “Start” or “Stop” button. The state for the boolean flag is managed by the useState hook.Let’s introduce our side-effect with useEffect that registers an interval. The function used for the interval emits a console logging every second to your developer tools of your browser.123456789101112131415161718192021222324252627import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); &#125;); return ( &lt;div&gt; &#123;!isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt; Start &lt;/button&gt; )&#125; &#123;isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt; Stop &lt;/button&gt; )&#125; &lt;/div&gt; );&#125;export default App;In order to remove the interval when the component unmounts (but also after every other render update), you can return a function in useEffect for anything to be called for the clean up. For instance, there shouldn’t be any memory leak left behind when the component isn’t there anymore.123456789101112131415import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); return () =&gt; clearInterval(interval); &#125;); ...&#125;export default App;Now, you want to setup the side-effect when mounting the component and the clean up the side-effect when unmounting the component. If you would log how many times the function within the effect is called, you would see that it sets a new interval every time the state of the component changes (e.g. click on “Start”/“Stop” button).12345678910111213141516import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; console.log(&apos;effect runs&apos;); const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); return () =&gt; clearInterval(interval); &#125;); ...&#125;export default App;In order to only run the effect on mount and unmount of the component, you can pass it an empty array as second argument.123456789101112131415import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); return () =&gt; clearInterval(interval); &#125;, []); ...&#125;export default App;However, since the interval is cleaned up after every render too, we need to set the interval in our update cycle too. But we can tell the effect to run only when the isOn variable changes. Only when one of the variables in the array changes, the effect will run during the update cycle. If you keep the array empty, the effect will only run on mount and unmount, because there is no variable to be checked for running the side-effect again.123456789101112131415import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); return () =&gt; clearInterval(interval); &#125;, [isOn]); ...&#125;export default App;The interval is running whether the isOn boolean is true or false. It would be great to only run it when the stopwatch is activated.12345678910111213141516171819import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); useEffect(() =&gt; &#123; let interval; if (isOn) &#123; interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000); &#125; return () =&gt; clearInterval(interval); &#125;, [isOn]); ...&#125;export default App;Now introduce another state in your function component to keep track of the timer of the stopwatch. It is used to update the timer, but only when the stopwatch is activated.123456789101112131415161718192021222324252627282930313233343536373839import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); const [timer, setTimer] = useState(0); useEffect(() =&gt; &#123; let interval; if (isOn) &#123; interval = setInterval( () =&gt; setTimer(timer + 1), 1000, ); &#125; return () =&gt; clearInterval(interval); &#125;, [isOn]); return ( &lt;div&gt; &#123;timer&#125; &#123;!isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt; Start &lt;/button&gt; )&#125; &#123;isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt; Stop &lt;/button&gt; )&#125; &lt;/div&gt; );&#125;export default App;There is still one mistake in the code. When the interval is running, it updates the timer every second by increasing it by one. However, it always relies on a stale state for the timer. Only when the inOn boolean flag changes the state is fine. In order to receive always the latest state for the timer when the interval is running, you can use a function instead for the state update function which always has the latest state.1234567891011121314151617181920212223import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); const [timer, setTimer] = useState(0); useEffect(() =&gt; &#123; let interval; if (isOn) &#123; interval = setInterval( () =&gt; setTimer(timer =&gt; timer + 1), 1000, ); &#125; return () =&gt; clearInterval(interval); &#125;, [isOn]); ...&#125;export default App;An alternative would have been to run the effect also when the timer changes. Then the effect would receive the latest timer state.1234567891011121314151617181920212223import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); const [timer, setTimer] = useState(0); useEffect(() =&gt; &#123; let interval; if (isOn) &#123; interval = setInterval( () =&gt; setTimer(timer + 1), 1000, ); &#125; return () =&gt; clearInterval(interval); &#125;, [isOn, timer]); ...&#125;export default App;That’s the implementation for the stopwatch that uses the Browser API If you want to continue, you can extend the example by providing a “Reset” button too.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOn, setIsOn] = useState(false); const [timer, setTimer] = useState(0); useEffect(() =&gt; &#123; let interval; if (isOn) &#123; interval = setInterval( () =&gt; setTimer(timer =&gt; timer + 1), 1000, ); &#125; return () =&gt; clearInterval(interval); &#125;, [isOn]); const onReset = () =&gt; &#123; setIsOn(false); setTimer(0); &#125;; return ( &lt;div&gt; &#123;timer&#125; &#123;!isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt; Start &lt;/button&gt; )&#125; &#123;isOn &amp;&amp; ( &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt; Stop &lt;/button&gt; )&#125; &lt;button type=&quot;button&quot; disabled=&#123;timer === 0&#125; onClick=&#123;onReset&#125;&gt; Reset &lt;/button&gt; &lt;/div&gt; );&#125;export default App;That’s it. The useEffect hook is used for side-effects in React function components that are used for interacting with the Browser/DOM API or other third-party APIs (e.g. data fetching). You can read more about the useEffect hook in React’s documentation.Last but not least, after you have learned about the two most popular hooks that introduce state and side-effects in function components, there is one last thing I want to show you: custom hooks. That’s right, you can implement your own custom React Hooks that can be reused in your application or by others. Let’s see how they work with an example application which is able to detect whether your device is online or offline.12345678910111213import React, &#123; useState &#125; from &apos;react&apos;;function App() &#123; const [isOffline, setIsOffline] = useState(false); if (isOffline) &#123; return &lt;div&gt;Sorry, you are offline ...&lt;/div&gt;; &#125; return &lt;div&gt;You are online!&lt;/div&gt;;&#125;export default App;Again, introduce the useEffect hook for the side-effect. In this case, the effect adds and removes listeners that check if the device is online or offline. Both listeners are setup only once on mount and cleaned up once on unmount (empty array as second argument). Whenever one of the listeners is called, it sets the state for the isOffline boolean.12345678910111213141516171819202122232425262728293031import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function App() &#123; const [isOffline, setIsOffline] = useState(false); function onOffline() &#123; setIsOffline(true); &#125; function onOnline() &#123; setIsOffline(false); &#125; useEffect(() =&gt; &#123; window.addEventListener(&apos;offline&apos;, onOffline); window.addEventListener(&apos;online&apos;, onOnline); return () =&gt; &#123; window.removeEventListener(&apos;offline&apos;, onOffline); window.removeEventListener(&apos;online&apos;, onOnline); &#125;; &#125;, []); if (isOffline) &#123; return &lt;div&gt;Sorry, you are offline ...&lt;/div&gt;; &#125; return &lt;div&gt;You are online!&lt;/div&gt;;&#125;export default App;Everything is nicely encapsulated in one effect now. It’s a great functionality which should be reuse somewhere else too. That’s why we can extract the functionality as its a custom hook which follows the same naming convention as the other hooks.12345678910111213141516171819202122232425262728293031323334353637import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function useOffline() &#123; const [isOffline, setIsOffline] = useState(false); function onOffline() &#123; setIsOffline(true); &#125; function onOnline() &#123; setIsOffline(false); &#125; useEffect(() =&gt; &#123; window.addEventListener(&apos;offline&apos;, onOffline); window.addEventListener(&apos;online&apos;, onOnline); return () =&gt; &#123; window.removeEventListener(&apos;offline&apos;, onOffline); window.removeEventListener(&apos;online&apos;, onOnline); &#125;; &#125;, []); return isOffline;&#125;function App() &#123; const isOffline = useOffline(); if (isOffline) &#123; return &lt;div&gt;Sorry, you are offline ...&lt;/div&gt;; &#125; return &lt;div&gt;You are online!&lt;/div&gt;;&#125;export default App;Extracting the custom hook as function was not the only thing. You also have to return the isOffline state from the custom hook in order to use it in your application to show a message to users who are offline. Otherwise, it should render the normal application. That’s it for the custom hook that detects whether you are online or offline. You can read more about custom hooks in React’s documentation.React Hooks being reusable is the best thing about them, because there is the potential to grow an ecosystem of custom React Hooks that can be installed from npm for any React application. And not only for React applications. Evan You, creator of Vue, is hooked (!) by them as well. Maybe we will see a bridge between both ecosystems where it is possible to share hooks between Vue and React.If you want to dive deeper into the state and effect hooks, you can check out the following React hook tutorials:How to useReducer Hook?Migration from Class Components to HooksComparison useState vs useReducerModern State Management with HooksHow to fetch data with React HooksCheckout the official FAQ and Rules for hooks in React’s documentation to learn more about their fine-grained behaviour. In addition, you can checkout all officially available React Hooks too.For everyone who is still concerned about React Hooks: Give them a shot yourself. Implement a couple of React function components with state and side-effects. I had to do it myself to understand how they work and to feel comfortable with them. And I must say it feels pretty great to use them.The Road to learn ReactBuild a Hacker News App along the way. No setup configuration. No tooling. No Redux. Plain React in 200+ pages of learning material. Learn React like 50.000+ readers.Get the Book for freeNever miss an article about web development, JavaScript and self-growth.Take PartJoin 30.000+ DevelopersLearn Web Development with JavaScriptTips and TricksAccess Tutorials, eBooks and CoursesPersonal Development as a Software Engineer本文作者： Andy本文地址： https://andyxw.com/archives/ef81.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>前端</tag>
        <tag>React Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端相关文章收藏]]></title>
    <url>%2Farchives%2Ff37d.html</url>
    <content type="text"><![CDATA[前端架构支付宝前端应用架构的发展和选择本文作者： Andy本文地址： https://andyxw.com/archives/f37d.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>链接</tag>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器重置密码]]></title>
    <url>%2Farchives%2Ffe92.html</url>
    <content type="text"><![CDATA[有时候会忘记服务器密码，但是可以通过官网面板等方式连上时，可使用下面的命令修改root密码：整段赋值下面的命令（”新密码”处 替换为要修改的密码）：1234echo root:新密码 |sudo chpasswd rootsudo sed -i &apos;s/^.*PermitRootLogin.*/PermitRootLogin yes/g&apos; /etc/ssh/sshd_config;sudo sed -i &apos;s/^.*PasswordAuthentication.*/PasswordAuthentication yes/g&apos; /etc/ssh/sshd_config;sudo reboot重启后用root账户登录即可。本文作者： Andy本文地址： https://andyxw.com/archives/fe92.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Linux</tag>
        <tag>重置密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解密传统组件间通信与React组件间通信]]></title>
    <url>%2Farchives%2Fac71.html</url>
    <content type="text"><![CDATA[在React中最小的逻辑单元是组件，组件之间如果有耦合关系就会进行通信，本文将会介绍React中的组件通信的不同方式通过归纳范，可以将任意组件间的通信归类为四种类型的组件间通信，分别是父子组件，爷孙组件，兄弟组件和任意组件，需要注意的是前三个也可以算作任意组件的范畴，所以最后一个是万能方法父子组件父子组件间的通信分为父组件向子组件通信和子组件向父组件通信两种情况，下面先来介绍父组件向子组件通信，传统做法分为两种情况，分别是初始化时的参数传递和实例阶段的方法调用，例子如下12345678910111213141516171819202122232425262728class Child &#123; constructor(name) &#123; // 获取dom引用 this.$div = document.querySelector('#wp'); // 初始化时传入name this.updateName(name); &#125; updateName(name) &#123; // 对外提供更新的api this.name = name; // 更新dom this.$div.innerHTML = name; &#125;&#125;class Parent &#123; constructor() &#123; // 初始化阶段 this.child = new Child('yan'); setTimeout(() =&gt; &#123; // 实例化阶段 this.child.updateName('hou'); &#125;, 2000); &#125;&#125;在React中将两个情况统一处理，全部通过属性来完成，之所以能够这样是因为React在属性更新时会自动重新渲染子组件，下面的例子中，2秒后子组件会自动重新渲染，并获取新的属性值1234567891011121314151617181920class Child extends Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt; &#125;&#125;class Parent extends Component &#123; constructor() &#123; // 初始化阶段 this.state = &#123;name: 'yan'&#125;; setTimeout(() =&gt; &#123; // 实例化阶段 this.setState(&#123;name: 'hou'&#125;) &#125;, 2000); &#125; render() &#123; return &lt;Child name=&#123;this.state.name&#125; /&gt; &#125;&#125;下面来看一下子组件如何向父组件通信，传统做法有两种，一种是回调函数，另一种是为子组件部署消息接口先来看回调函数的例子，回调函数的优点是非常简单，缺点就是必须在初始化的时候传入，并且不可撤回，并且只能传入一个函数123456789101112131415class Child &#123; constructor(cb) &#123; // 调用父组件传入的回调函数，发送消息 setTimeout(() =&gt; &#123; cb() &#125;, 2000); &#125;&#125;class Parent &#123; constructor() &#123; // 初始化阶段，传入回调函数 this.child = new Child(function () &#123; console.log('child update') &#125;); &#125;&#125;下面来看看消息接口方法，首先需要一个可以发布和订阅消息的基类，比如下面实现了一个简单的EventEimtter，实际生产中可以直接使用别人写好的类库，比如@jsmini/event，子组件继承消息基类，就有了发布消息的能力，然后父组件订阅子组件的消息，即可实现子组件向父组件通信的功能消息接口的优点就是可以随处订阅，并且可以多次订阅，还可以取消订阅，缺点是略显麻烦，需要引入消息基类123456789101112131415161718192021222324252627282930313233// 消息接口，订阅发布模式，类似绑定事件，触发事件class EventEimtter &#123; constructor() &#123; this.eventMap = &#123;&#125;; &#125; sub(name, cb) &#123; const eventList = this.eventMap[name] = this.eventMap[name] || &#123;&#125;; eventList.push(cb); &#125; pub(name, ...data) &#123; (this.eventMap[name] || []).forEach(cb =&gt; cb(...data)); &#125;&#125;class Child extends EventEimtter &#123; constructor() &#123; super(); // 通过消息接口发布消息 setTimeout(() =&gt; &#123; this.pub('update') &#125;, 2000); &#125;&#125;class Parent &#123; constructor() &#123; // 初始化阶段，传入回调函数 this.child = new Child(); // 订阅子组件的消息 this.child.sub('update', function () &#123; console.log('child update') &#125;); &#125;&#125;Backbone.js就同时支持回调函数和消息接口方式，但React中选择了比较简单的回调函数模式，下面来看一下React的例子1234567891011121314class Child extends Component &#123; constructor(props) &#123; setTimeout(() =&gt; &#123; this.props.cb() &#125;, 2000); &#125; render() &#123; return &lt;div&gt;&lt;/div&gt; &#125;&#125;class Parent extends Component &#123; render() &#123; return &lt;Child cb=&#123;() =&gt; &#123;console.log('update')&#125;&#125; /&gt; &#125;&#125;爷孙组件父子组件其实可以算是爷孙组件的一种特例，这里的爷孙组件不光指爷爷和孙子，而是泛指祖先与后代组件通信，可能隔着很多层级，我们已经解决了父子组件通信的问题，根据化归法，很容易得出爷孙组件的答案，那就是层层传递属性么，把爷孙组件通信分解为多个父子组件通信的问题层层传递的优点是非常简单，用已有知识就能解决，问题是会浪费很多代码，非常繁琐，中间作为桥梁的组件会引入很多不属于自己的属性在React中，通过context可以让祖先组件直接把属性传递到后代组件，有点类似星际旅行中的虫洞一样，通过context这个特殊的桥梁，可以跨越任意层次向后代组件传递消息怎么在需要通信的组件之间开启这个虫洞呢？需要双向声明，也就是在祖先组件声明属性，并在后代组件上再次声明属性，然后在祖先组件上放上属性就可以了，就可以在后代组件读取属性了，下面看一个例子123456789101112131415161718192021222324import PropTypes from 'prop-types';class Child extends Component &#123; // 后代组件声明需要读取context上的数据 static contextTypes = &#123; text: PropTypes.string &#125; render() &#123; // 通过this.context 读取context上的数据 return &lt;div&gt;&#123;this.context.text&#125;&lt;/div&gt; &#125;&#125;class Ancestor extends Component &#123; // 祖先组件声明需要放入context上的数据 static childContextTypes = &#123; text: PropTypes.string &#125; // 祖先组件往context放入数据 getChildContext() &#123; return &#123;text: 'yanhaijing'&#125; &#125;&#125;context的优点是可以省去层层传递的麻烦，并且通过双向声明控制了数据的可见性，对于层数很多时，不失为一种方案；但缺点也很明显，就像全局变量一样，如果不加节制很容易造成混乱，而且也容易出现重名覆盖的问题个人的建议是对一些所有组件共享的只读信息可以采用context来传递，比如登录的用户信息等小贴士：React Router路由就是通过context来传递路由属性的兄弟组件如果两个组件是兄弟关系，可以通过父组件作为桥梁，来让两个组件之间通信，这其实就是主模块模式下面的例子中，两个子组件通过父组件来实现显示数字同步的功能123456789101112131415class Parent extends Component &#123; constructor() &#123; this.onChange = function (num) &#123; this.setState(&#123;num&#125;) &#125;.bind(this); &#125; render() &#123; return ( &lt;div&gt; &lt;Child1 num=&#123;this.state.num&#125; onChange=&#123;this.onChange&#125;&gt; &lt;Child2 num=&#123;this.state.num&#125; onChange=&#123;this.onChange&#125;&gt; &lt;/div&gt; ); &#125;&#125;主模块模式的优点就是解耦，把两个子组件之间的耦合关系，解耦成子组件和父组件之间的耦合，把分散的东西收集在一起好处非常明显，能带来更好的可维护性和可扩展性任意组件任意组件包括上面的三种关系组件，上面三种关系应该优先使用上面介绍的方法，对于任意的两个组件间通信，总共有三种办法，分别是共同祖先法，消息中间件和状态管理基于我们上面介绍的爷孙组件和兄弟组件，只要找到两个组件的共同祖先，就可以将任意组件之间的通信，转化为任意组件和共同祖先之间的通信，这个方法的好处就是非常简单，已知知识就能搞定，缺点就是上面两种模式缺点的叠加，除了临时方案，不建议使用这种方法另一种比较常用的方法是消息中间件，就是引入一个全局消息工具，两个组件通过这个全局工具进行通信，这样两个组件间的通信，就通过全局消息媒介完成了还记得上面介绍的消息基类吗？下面的例子中，组件1和组件2通过全局event进行通信12345678910111213141516171819202122232425262728293031class EventEimtter &#123; constructor() &#123; this.eventMap = &#123;&#125;; &#125; sub(name, cb) &#123; const eventList = this.eventMap[name] = this.eventMap[name] || &#123;&#125;; eventList.push(cb); &#125; pub(name, ...data) &#123; (this.eventMap[name] || []).forEach(cb =&gt; cb(...data)); &#125;&#125;// 全局消息工具const event = new EventEimtter;// 一个组件class Element1 extends Component &#123; constructor() &#123; // 订阅消息 event.sub('element2update', () =&gt; &#123;console.log('element2 update')&#125;); &#125;&#125;// 另一个组件。class Element2 extends Component &#123; constructor() &#123; // 发布消息 setTimeout(function () &#123; event.pub('element2update') &#125;, 2000) &#125;&#125;消息中间件的模式非常简单，利用了观察者模式，将两个组件之间的耦合解耦成了组件和消息中心+消息名称的耦合，但为了解耦却引入全局消息中心和消息名称，消息中心对组件的侵入性很强，和第三方组件通信不能使用这种方式小型项目比较适合使用这种方式，但随着项目规模的扩大，达到中等项目以后，消息名字爆炸式增长，消息名字的维护成了棘手的问题，重名概率极大，没有人敢随便删除消息信息，消息的发布者找不到消息订阅者的信息等其实上面的问题也不是没有解决办法，重名的问题可以通过制定规范，消息命名空间等方式来极大降低冲突，其他问题可以通过把消息名字统一维护到一个文件，通过对消息的中心化管理，可以让很多问题都很容易解决如果你的项目非常大，上面两种方案都不合适，那你可能需要一个状态管理工具，通过状态管理工具把组件之间的关系，和关系的处理逻辑从组建中抽象出来，并集中化到统一的地方来处理，Redux就是一个非常不错的状态管理工具除了Redux，还有Mobx，Rematch，reselect等工具，本文不展开介绍，有机会后面单独成文，这些都是用来解决不同问题的，只要根据自己的场景选择合适的工具就好了总结组件间的关系千变万化，都可以用上面介绍的方法解决，对于不同规模的项目，应该选择适合自己的技术方案，上面介绍的不同方式解耦的程度是不一样的，关于不同耦合关系的好坏，可以看我之前的文章《图解7种耦合关系》本文作者： Andy本文地址： https://andyxw.com/archives/ac71.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解7种耦合关系]]></title>
    <url>%2Farchives%2F7e29.html</url>
    <content type="text"><![CDATA[深入讲讲模块之间的耦合关系这个事情。本文将用图文详细讲解七种耦合的不同之处。高内聚与低耦合高内聚与低耦合是每个软件开发者追求的目标，那么内聚和耦合分别是什么意思呢？内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。耦合不同模块之间的关系就是耦合，根据耦合程度可以分为7种，耦合度依次变低。内容耦合公共耦合外部耦合控制耦合标记耦合数据耦合非直接耦合下面我们来说说每种耦合是什么，开始之前先来说下要实现的功能。m1和m2是两个独立的模块，其中m2种会显示m1的输入，m1会显示m2的输入。很显然，m1和m2两个模块之间会有一些联系（耦合），你也可以想想如何实现这个功能，下面用7种不同的方式来实现这个功能。注：项目的代码我放到了github，项目的demo，可以在这里查看。内容耦合内容耦合是最紧的耦合程度，一个模块直接访问另一模块的内容，则称这两个模块为内容耦合。为了实现功能，我们将m1的输入放到m2.m1input上，将m2的输入放到m1.m2input上。// m1.js root.m2.m1input = this.value; m2.update(); // m2.js root.m1.m2input = this.value; m1.update(); PS:不知道谁会这么写代码，除了我为了做演示之外。。。查看完整代码和demo。公共耦合一组模块都访问同一个全局数据结构，则称之为公共耦合。在这种case中，m1和m2将自己的输入放到全局的data上。// m1.js root.data.m1input = this.value; m2.update(); // m2.js root.data.m2input = this.value; m1.update(); 查看完整代码和demo。外部耦合一组模块都访问同一全局简单变量，而且不通过参数表传递该全局变量的信息，则称之为外部耦合。外部耦合和公共耦合很像，区别就是一个是简单变量，一个是复杂数据结构。在这种case中，m1和m2都将自己的输入放到全局上。// m1.js root.m1input = this.value; m2.update(); // m2.js root.m2input = this.value; m1.update(); 查看完整代码和demo。控制耦合模块之间传递的不是数据信息，而是控制信息例如标志、开关量等，一个模块控制了另一个模块的功能。从控制耦合开始，模块的数据就放在自己内部了，不同模块之间通过接口互相调用。在这个case中，得增加一个需求，就是当m1的输入为空时，隐藏m2的显示信息。// m1.js root.m1input = this.value; m2.update(); m2.toggle(!!this.value); // 传递flag 上面的代码中m1直接控制了m2的显示和隐藏。查看完整代码和demo。标记耦合调用模块和被调用模块之间传递数据结构而不是简单数据，同时也称作特征耦合。在这个case中，m1传给m2的是一个对象。// m1.js me.m1input = this.value; m2.update(me); // 传递引用 // m2.js me.m2input = this.value; m1.update(me); 查看完整代码和demo。数据耦合调用模块和被调用模块之间只传递简单的数据项参数。相当于高级语言中的值传递。在这个case中，m1传给m2的是一个简单数据结构。// m1.js me.m1input = this.value; m2.update(me.m1input); // 传递值 // m2.js me.m2input = this.value; m1.update(me.m2input); 查看完整代码和demo。非直接耦合两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。耦合度最弱，模块独立性最强。子模块无需知道对方的存在，子模块之间的联系，全部变成子模块和主模块之间的联系。在这个case种，增加一个index.js作为主模块。// index.js var m1 = root.m1; var m2 = root.m2; m1.init(function (str) { m2.update(str); }); m2.init(function (str) { m1.update(str); }); // m1.js me.m1input = this.value; inputcb(me.m1input); // inputcb是回调函数 // m2.js me.m2input = this.value; inputcb(me.m2input); 查看完整代码和demo。内聚其实关于内聚也分为很多种，如下所示，如果你感兴趣可以自己研究研究，我们下次再来分享内聚的问题。偶然内聚逻辑内聚时间内聚通信内聚顺序内聚功能内聚总结希望你看完上面的文章，搞懂了耦合的种类，也希望你以后能使用非直接耦合这种方式来写代码，祝好。本文作者： Andy本文地址： https://andyxw.com/archives/7e29.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鸡汤]]></title>
    <url>%2Farchives%2F201.html</url>
    <content type="text"><![CDATA[这是篇有密码的博客 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 技术栈]]></title>
    <url>%2Farchives%2F4a9b.html</url>
    <content type="text"><![CDATA[React 技术栈React 是目前最热门的前端框架。Facebook 公司2013年推出现在最好的社区支持和生态圈大量的第三方工具React 的优点组件模式：代码复用和团队分工虚拟 DOM：性能优势移动端支持：跨终端React 的缺点学习曲线较陡峭全新的一套概念，与其他所有框架截然不同只有采用它的整个技术栈，才能发挥最大威力总结：React 非常先进和强大，但是学习和实现成本都不低JSX 语法React 使用 JSX 语法，JavaScript 代码中可以写 HTML 代码。1let myTitle = &lt;h1&gt;Hello, world!&lt;/h1&gt;;JSX 语法解释（1）JSX 语法的最外层，只能有一个节点。12// 错误let myTitle = &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;;（2）JSX 语法中可以插入 JavaScript 代码，使用大括号。1let myTitle = &lt;p&gt;&#123;'Hello ' + 'World'&#125;&lt;/p&gt;Babel 转码器JavaScript 引擎（包括浏览器和 Node）都不认识 JSX，需要首先使用 Babel 转码，然后才能运行。123456&lt;script src="react.js"&gt;&lt;/script&gt;&lt;script src="react-dom.js"&gt;&lt;/script&gt;&lt;script src="babel.min.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt; // ** Our code goes here! **&lt;/script&gt;React 需要加载两个库：React 和 React-DOM，前者是 React 的核心库，后者是 React 的 DOM 适配库。Babel 用来在浏览器转换 JSX 语法，如果服务器已经转好了，浏览器就不需要加载这个库。课堂练习：JSX 语法浏览器打开demos/jsx-demo/index.html，按照《操作说明》，完成练习。1234ReactDOM.render( &lt;span&gt;Hello World!&lt;/span&gt;, document.getElementById('example'));示例：React 组件React 允许用户定义自己的组件，插入网页。浏览器打开demos/react-component-demo/index1.html，按照《操作说明》，仔细查看源码。12345678910class MyTitle extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello World&lt;/h1&gt;; &#125;&#125;;ReactDOM.render( &lt;MyTitle/&gt;, document.getElementById('example'));课堂练习：组件的参数组件可以从外部传入参数，内部使用this.props获取参数。打开demos/react-component-demo/index2.html，按照《操作说明》，完成练习。123456789class MyTitle extends React.Component &#123; render() &#123; return &lt;h1 style=&#123;&#123;color: this.props.color&#125;&#125; &gt;Hello World&lt;/h1&gt;; &#125;&#125;;&lt;MyTitle color="red" /&gt;,示例：组件的状态组件往往会有内部状态，使用this.state表示。浏览器打开demos/react-component-demo/index3.html，按照《操作说明》，仔细查看源码。课堂练习：React 组件实战浏览器打开demos/react-component-demo/index4.html，按照《操作说明》，完成练习。组件的生命周期React 为组件的不同生命阶段，提供了近十个钩子方法。componentWillMount()：组件加载前调用componentDidMount()：组件加载后调用componentWillUpdate(): 组件更新前调用componentDidUpdate(): 组件更新后调用componentWillUnmount()：组件卸载前调用componentWillReceiveProps()：组件接受新的参数时调用我们可以利用这些钩子，自动完成一些操作。课堂练习：组件的生命周期组件可以通过 Ajax 请求，从服务器获取数据。Ajax 请求一般在componentDidMount方法里面发出。123456componentDidMount() &#123; const url = '...'; $.getJSON(url) .done() .fail();&#125;打开demos/react-lifecycle-demo/index.html，按照《操作说明》，完成练习。React 组件库React 的一大优势，就是网上有很多已经写好的组件库，可以使用。React-Bootstrap：https://react-bootstrap.github.io/示例：ReChartsReCharts 是一个 React 图表组件库。http://recharts.org/浏览器打开demos/recharts-demo/index.html，按照《操作说明》，仔细查看源码，体会 JSX 语法对表达复杂组件的优势。1234567&lt;LineChart width=&#123;1000&#125; height=&#123;400&#125; data=&#123;data&#125;&gt; &lt;XAxis dataKey="name"/&gt; &lt;YAxis/&gt; &lt;CartesianGrid stroke="#eee" strokeDasharray="5 5"/&gt; &lt;Line type="monotone" dataKey="uv" stroke="#8884d8" /&gt; &lt;Line type="monotone" dataKey="pv" stroke="#82ca9d" /&gt;&lt;/LineChart&gt;React 的核心思想View 是 State 的输出。1view = f(state)上式中，f表示函数关系。只要 State 发生变化，View 也要随之变化。React 的本质是将图形界面（GUI）函数化。12345678const person = &#123; name: "michel", age: 31&#125;const App = (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body)React 没有解决的问题React 本身只是一个 DOM 的抽象层，使用组件构建虚拟 DOM。如果开发大应用，还需要解决两个问题。架构：大型应用程序应该如何组织代码？通信：组件之间如何通信？架构问题React 只是视图层的解决方案，可以用于任何一种架构。MVCMVVMObserverReactive…到底哪一种架构最合适 React ？通信问题组件会发生三种通信。向子组件发消息向父组件发消息向其他组件发消息React 只提供了一种通信手段：传参。对于大应用，很不方便。状态的同步通信的本质是状态的同步。React 同步状态的基本方法：找到通信双方最近的共同父组件，通过它的state，使得子组件的状态保持同步。Flux 架构Facebook 提出 Flux 架构的概念，被认为是 React 应用的标准架构。最大特点：数据单向流动。与 MVVM 的数据双向绑定，形成鲜明对比。Flux 的核心思想不同组件的state，存放在一个外部的、公共的 Store 上面。组件订阅 Store 的不同部分。组件发送（dispatch）动作（action），引发 Store 的更新。Flux 只是一个概念，有30多种实现。目前最流行的两个 React 架构React 架构的最重要作用：管理 Store 与 View 之间的关系。MobX：响应式（Reactive）管理，state 是可变对象，适合中小型项目Redux：函数式（Functional）管理，state 是不可变对象，适合大型项目MobX 架构MobX 的核心是观察者模式。Store 是被观察者（observable）组件是观察者（observer）一旦Store有变化，会立刻被组件观察到，从而引发重新渲染。MobX 的最简单例子1234567891011const &#123;observable&#125; = mobx;const &#123;observer&#125; = mobxReact;const person = observable(&#123;name: "张三", age: 31&#125;);const App = observer( (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;);ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body);person.name = "李四";代码：demos/mobx-demo/browser-demo目录示例：MobX进入demos/mobx-demo目录，按照《操作说明》，理解 MobX 框架。UI 层是观察者，Store 是被观察者。Store 所有的属性，分成两大类：直接被观察的属性和自动计算出来的属性。123456class Store &#123; @observable name = 'Bartek'; @computed get decorated() &#123; return `$&#123;this.name&#125; is awesome!`; &#125;&#125;UI 会观察到 Store 的变化，自动重新渲染。Redux 架构Redux 的核心概念所有的状态存放在Store。组件每次重新渲染，都必须由状态变化引起。用户在 UI 上发出action。reducer函数接收action，然后根据当前的state，计算出新的state。Redux 应用的架构Redux 层保存所有状态，React 组件拿到状态以后，渲染出 HTML 代码。示例：Redux进入demos/redux-demo目录，按照《操作说明》，理解 Redux 框架。Redux 将组件分成 UI 组件和容器组件两类。UI 组件是纯组件，不包含 state 和生命周期方法，不涉及组件的行为，只涉及组件的外观。1234567&lt;div className="index"&gt; &lt;p&gt;&#123;this.props.text&#125;&lt;/p&gt; &lt;input defaultValue=&#123;this.props.name&#125; onChange=&#123;this.props.onChange&#125; /&gt;&lt;/div&gt;容器组件正好相反。不涉及组件的外观，只涉及组件的行为。负责订阅 Store，将 Store 的数据处理以后，再通过参数传给 UI 组件。用户给出配置以后，由 Redux 生成。12345// MyComponent 是纯的 UI 组件const App = connect( mapStateToProps, mapDispatchToProps)(MyComponent);mapStateToProps: 定义 UI 组件参数与 State 之间的映射mapDispatchToProps：定义 UI 组件与 Action 之间的映射拆分 UI 组件和容器组件的好处UI 组件与后台数据无关，可以由设计师负责容器组件只负责数据和行为，一旦 Store 的数据结构变化，只要调整容器组件即可表现层和功能层脱钩，有利于代码重用，也有利于看清应用的数据结构和业务逻辑Reducer 函数reducer是一个纯函数，用来接收action，算出新的state。123456789101112function reducer(state = &#123; text: '你好，访问者', name: '访问者'&#125;, action) &#123; switch (action.type) &#123; case 'change': return &#123; name: action.payload, text: '你好，' + action.payload &#125;; &#125;&#125;Store由 Redux 提供的createStore方法生成，该方法接受reducer作为参数。为了把Store传入组件，必须使用 Redux 提供的Provider组件在应用的最外面，包裹一层。12345678const store = createStore(reducer);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.body.appendChild(document.createElement('div')));本文作者： Andy本文地址： https://andyxw.com/archives/4a9b.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 设计思想]]></title>
    <url>%2Farchives%2F7615.html</url>
    <content type="text"><![CDATA[React 设计思想译者序：本文是 React 核心开发者、有 React API 终结者之称的 Sebastian Markbåge 撰写，阐述了他设计 React 的初衷。阅读此文，你能站在更高的高度思考 React 的过去、现在和未来。原文地址：https://github.com/reactjs/react-basic我写此文是想正式地阐述我心中 React 的心智模型。目的是解释为什么我们会这样设计 React，同时你也可以根据这些论点反推出 React。不可否认，此文中的部分论据或前提尚存争议，而且部分示例的设计可能存在 bug 或疏忽。这只是正式确定它的最初阶段。如果你有更好的完善它的想法可以随时提交 pull request。本文不会介绍框架细节中的奇技淫巧，相信这样能提纲挈领，让你看清 React 由简单到复杂的设计过程。React.js 的真实实现中充满了具体问题的解决方案，渐进式的解法，算法优化，历史遗留代码，debug 工具以及其他一些可以让它真的具有高可用性的内容。这些代码可能并不稳定，因为未来浏览器的变化和功能权重的变化随时面临改变。所以具体的代码很难彻底解释清楚。我偏向于选择一种我能完全 hold 住的简洁的心智模型来作介绍。变换（Transformation）设计 React 的核心前提是认为 UI 只是把数据通过映射关系变换成另一种形式的数据。同样的输入必会有同样的输出。这恰好就是纯函数。123function NameBox(name) &#123; return &#123; fontWeight: 'bold', labelContent: name &#125;;&#125;12&apos;Sebastian Markbåge&apos; -&gt;&#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125;;抽象（Abstraction）你不可能仅用一个函数就能实现复杂的 UI。重要的是，你需要把 UI 抽象成多个隐藏内部细节，又可复用的函数。通过在一个函数中调用另一个函数来实现复杂的 UI，这就是抽象。123456789function FancyUserBox(user) &#123; return &#123; borderStyle: '1px solid blue', childContent: [ 'Name: ', NameBox(user.firstName + ' ' + user.lastName) ] &#125;;&#125;12345678&#123; firstName: &apos;Sebastian&apos;, lastName: &apos;Markbåge&apos; &#125; -&gt;&#123; borderStyle: &apos;1px solid blue&apos;, childContent: [ &apos;Name: &apos;, &#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125; ]&#125;;组合（Composition）为了真正达到重用的特性，只重用叶子然后每次都为他们创建一个新的容器是不够的。你还需要可以包含其他抽象的容器再次进行组合。我理解的“组合”就是将两个或者多个不同的抽象合并为一个。12345678910111213function FancyBox(children) &#123; return &#123; borderStyle: '1px solid blue', children: children &#125;;&#125;function UserBox(user) &#123; return FancyBox([ 'Name: ', NameBox(user.firstName + ' ' + user.lastName) ]);&#125;状态（State）UI 不单单是对服务器端或业务逻辑状态的复制。实际上还有很多状态是针对具体的渲染目标。举个例子，在一个 text field 中打字。它不一定要复制到其他页面或者你的手机设备。滚动位置这个状态是一个典型的你几乎不会复制到多个渲染目标的。我们倾向于使用不可变的数据模型。我们把可以改变 state 的函数串联起来作为原点放置在顶层。1234567891011121314151617181920212223function FancyNameBox(user, likes, onClick) &#123; return FancyBox([ 'Name: ', NameBox(user.firstName + ' ' + user.lastName), 'Likes: ', LikeBox(likes), LikeButton(onClick) ]);&#125;// 实现细节var likes = 0;function addOneMoreLike() &#123; likes++; rerender();&#125;// 初始化FancyNameBox( &#123; firstName: 'Sebastian', lastName: 'Markbåge' &#125;, likes, addOneMoreLike);注意：本例更新状态时会带来副作用（addOneMoreLike 函数中）。我实际的想法是当一个“update”传入时我们返回下一个版本的状态，但那样会比较复杂。此示例待更新Memoization对于纯函数，使用相同的参数一次次调用未免太浪费资源。我们可以创建一个函数的 memorized 版本，用来追踪最后一个参数和结果。这样如果我们继续使用同样的值，就不需要反复执行它了。1234567891011121314151617181920212223function memoize(fn) &#123; var cachedArg; var cachedResult; return function(arg) &#123; if (cachedArg === arg) &#123; return cachedResult; &#125; cachedArg = arg; cachedResult = fn(arg); return cachedResult; &#125;;&#125;var MemoizedNameBox = memoize(NameBox);function NameAndAgeBox(user, currentTime) &#123; return FancyBox([ 'Name: ', MemoizedNameBox(user.firstName + ' ' + user.lastName), 'Age in milliseconds: ', currentTime - user.dateOfBirth ]);&#125;列表（Lists）大部分 UI 都是展示列表数据中不同 item 的列表结构。这是一个天然的层级。为了管理列表中的每一个 item 的 state ，我们可以创造一个 Map 容纳具体 item 的 state。123456789101112131415function UserList(users, likesPerUser, updateUserLikes) &#123; return users.map(user =&gt; FancyNameBox( user, likesPerUser.get(user.id), () =&gt; updateUserLikes(user.id, likesPerUser.get(user.id) + 1) ));&#125;var likesPerUser = new Map();function updateUserLikes(id, likeCount) &#123; likesPerUser.set(id, likeCount); rerender();&#125;UserList(data.users, likesPerUser, updateUserLikes);注意：现在我们向 FancyNameBox 传了多个不同的参数。这打破了我们的 memoization 因为我们每次只能存储一个值。更多相关内容在下面。连续性（Continuations）不幸的是，自从 UI 中有太多的列表，明确的管理就需要大量的重复性样板代码。我们可以通过推迟一些函数的执行，进而把一些模板移出业务逻辑。比如，使用“柯里化”（JavaScript 中的 bind）。然后我们可以从核心的函数外面传递 state，这样就没有样板代码了。下面这样并没有减少样板代码，但至少把它从关键业务逻辑中剥离。123456789101112function FancyUserList(users) &#123; return FancyBox( UserList.bind(null, users) );&#125;const box = FancyUserList(data.users);const resolvedChildren = box.children(likesPerUser, updateUserLikes);const resolvedBox = &#123; ...box, children: resolvedChildren&#125;;State Map之前我们知道可以使用组合避免重复执行相同的东西这样一种重复模式。我们可以把执行和传递 state 逻辑挪动到被复用很多的低层级的函数中去。12345678910111213141516171819202122232425262728function FancyBoxWithState( children, stateMap, updateState) &#123; return FancyBox( children.map(child =&gt; child.continuation( stateMap.get(child.key), updateState )) );&#125;function UserList(users) &#123; return users.map(user =&gt; &#123; continuation: FancyNameBox.bind(null, user), key: user.id &#125;);&#125;function FancyUserList(users) &#123; return FancyBoxWithState.bind(null, UserList(users) );&#125;const continuation = FancyUserList(data.users);continuation(likesPerUser, updateUserLikes);Memoization Map一旦我们想在一个 memoization 列表中 memoize 多个 item 就会变得很困难。因为你需要制定复杂的缓存算法来平衡调用频率和内存占有率。还好 UI 在同一个位置会相对的稳定。相同的位置一般每次都会接受相同的参数。这样以来，使用一个集合来做 memoization 是一个非常好用的策略。我们可以用对待 state 同样的方式，在组合的函数中传递一个 memoization 缓存。12345678910111213141516171819202122232425262728function memoize(fn) &#123; return function(arg, memoizationCache) &#123; if (memoizationCache.arg === arg) &#123; return memoizationCache.result; &#125; const result = fn(arg); memoizationCache.arg = arg; memoizationCache.result = result; return result; &#125;;&#125;function FancyBoxWithState( children, stateMap, updateState, memoizationCache) &#123; return FancyBox( children.map(child =&gt; child.continuation( stateMap.get(child.key), updateState, memoizationCache.get(child.key) )) );&#125;const MemoizedFancyNameBox = memoize(FancyNameBox);代数效应（Algebraic Effects）多层抽象需要共享琐碎数据时，一层层传递数据非常麻烦。如果能有一种方式可以在多层抽象中快捷地传递数据，同时又不需要牵涉到中间层级，那该有多好。React 中我们把它叫做“context”。有时候数据依赖并不是严格按照抽象树自上而下进行。举个例子，在布局算法中，你需要在实现他们的位置之前了解子节点的大小。现在，这个例子有一点超纲。我会使用 代数效应 这个由我发起的 ECMAScript 新特性提议。如果你对函数式编程很熟悉，它们 在避免由 monad 强制引入的仪式一样的编码。123456789101112131415161718192021222324function ThemeBorderColorRequest() &#123; &#125;function FancyBox(children) &#123; const color = raise new ThemeBorderColorRequest(); return &#123; borderWidth: '1px', borderColor: color, children: children &#125;;&#125;function BlueTheme(children) &#123; return try &#123; children(); &#125; catch effect ThemeBorderColorRequest -&gt; [, continuation] &#123; continuation('blue'); &#125;&#125;function App(data) &#123; return BlueTheme( FancyUserList.bind(null, data.users) );&#125;本文作者： Andy本文地址： https://andyxw.com/archives/7615.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React中的state和props]]></title>
    <url>%2Farchives%2F992.html</url>
    <content type="text"><![CDATA[整理一下React中关于state和props的知识点。在任何应用中，数据都是必不可少的。我们需要直接的改变页面上一块的区域来使得视图的刷新，或者间接地改变其他地方的数据。React的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在props和state中，这两个属性有啥子区别呢？propsReact的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件。组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是props，所以可以把props理解为从外部传入组件内部的数据。由于React是单向数据流，所以props基本上也就是从服父级组件向子组件传递的数据。用法假设我们现在需要实现一个列表，根据React组件化思想，我们可以把列表中的行当做一个组件，也就是有这样两个组件：&lt;ItemList/&gt;和&lt;Item/&gt;。先看看&lt;ItemList/&gt;123456789import Item from &quot;./item&quot;;export default class ItemList extends React.Component&#123; const itemList = data.map(item =&gt; &lt;Item item=item /&gt;); render()&#123; return ( &#123;itemList&#125; ) &#125;&#125;列表的数据我们就暂时先假设是放在一个data变量中，然后通过map函数返回一个每一项都是&lt;Item item=&#39;数据&#39;/&gt;的数组，也就是说这里其实包含了data.length个&lt;Item/&gt;组件，数据通过在组件上自定义一个参数传递。当然，这里想传递几个自定义参数都可以。在&lt;Item /&gt;中是这样的：1234567export default class Item extends React.Component&#123; render()&#123; return ( &lt;li&gt;&#123;this.props.item&#125;&lt;/li&gt; ) &#125;&#125;在render函数中可以看出，组件内部是使用this.props来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个item属性，所以通过this.props.item来获取即可。只读性props经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的props是只读的，不可改变的。如果props在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的props传入组件中。默认参数在组件中，我们最好为props中的参数设置一个defaultProps，并且制定它的类型。比如，这样：1234567Item.defaultProps = &#123; item: &apos;Hello Props&apos;,&#125;;Item.propTypes = &#123; item: PropTypes.string,&#125;;关于propTypes，可以声明为以下几种类型：1234567optionalArray: PropTypes.array,optionalBool: PropTypes.bool,optionalFunc: PropTypes.func,optionalNumber: PropTypes.number,optionalObject: PropTypes.object,optionalString: PropTypes.string,optionalSymbol: PropTypes.symbol,注意，bool和func是简写。这些知识基础数据类型，还有一些复杂的，附上链接：https://facebook.github.io/react/docs/typechecking-with-proptypes.html总结props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。statestate是什么呢？State is similar to props, but it is private and fully controlled by the component.一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是props，而数据状态就是state。用法12345678910111213export default class ItemList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; itemList:&apos;一些数据&apos;, &#125; &#125; render()&#123; return ( &#123;this.state.itemList&#125; ) &#125;&#125;首先，在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。setStatestate不同于props的一点是，state是可以被改变的。不过，不可以直接通过this.state=的方式来修改，而需要通过this.setState()方法来修改state。比如，我们经常会通过异步操作来获取数据，我们需要在didMount阶段来执行异步操作：1234567componentDidMount()&#123; fetch(&apos;url&apos;) .then(response =&gt; response.json()) .then((data) =&gt; &#123; this.setState(&#123;itemList:item&#125;); &#125;&#125;当数据获取完成后，通过this.setState来修改数据状态。当我们调用this.setState方法时，React会更新组件的数据状态state，并且重新调用render方法，也就是会对组件进行重新渲染。注意：通过this.state=来初始化state，使用this.setState来修改state，constructor是唯一能够初始化的地方。setState接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：123456789101112export default class ItemList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name:&apos;axuebin&apos;, age:25, &#125; &#125; componentDidMount()&#123; this.setState(&#123;age:18&#125;) &#125;&#125;在执行完setState之后的state应该是{name:&#39;axuebin&#39;,age:18}。setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：123this.setState(&#123; name:&apos;xb&apos;&#125;,()=&gt;console.log(&apos;setState finished&apos;))总结state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。区别state是组件自己管理数据，控制自己的状态，可变；props是外部传入的数据参数，不可变；没有state的叫做无状态组件，有state的叫做有状态组件；多用props，少用state。也就是多写无状态组件。本文作者： Andy本文地址： https://andyxw.com/archives/992.html版权声明： 转载请注明出处！]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
</search>
